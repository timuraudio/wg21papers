\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}
\cftsetindents{paragraph}{1.02in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%PROPERTIES

% Macro to define custom subsubsubsections for properties
\newcommand{\prop}[2]{
  \paragraph*{\tcode{#1}: #2}
  \refstepcounter{paragraph}
  \label{#1}
  \addcontentsline{toc}{paragraph}{\tcode{#1}: #2}
  \mbox{}\vspace{0.5em} % hack to force the heading to not be run-in
  \nopagebreak[4]
}

% Macro to refer to properties
\newcommand{\propref}[1]{\hyperref[#1]{\tcode{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on virtual functions: \\ a principled design approach}
\author{
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\
John Lakos \small(\href{mailto:jlakos@bloomberg.net}{jlakos@bloomberg.net}) 
% TD: TODO: get Ville on board?
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3600R0 \\
Date: &2025-08-25 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we present a comprehensive analysis of the design space for supporting function contract assertions (\tcode{pre} and \tcode{post}) on virtual functions in C++. We identify a number of desirable properties that such a language feature should exhibit. We survey existing and proposed approaches and introduce a framework for classifying them according to a small number of key design decisions. For each decision, we examine its impact on the extent to which the desirable properties can be achieved. We find that no design that achieves all desirable properties is possible. We identify three candidate designs that realise different, meaningful subsets of these properties. We distill the choice between these candidate designs down to two design decisions with different tradeoffs. We conclude with a recommendation for a concrete design that seems to offer the best set of tradeoffs overall.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\tableofcontents*
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\subsection{Motivation and context}

Contract assertions (\cite{P2900R14}) are a major new facility in C++26. A key feature of this facility are \emph{function contract assertions}: \tcode{pre} and \tcode{post}. This feature allows expressing
% TD: I omitted the "the" from this sentence here because they only allow expressing a subset of the full set of preconditions and postconditions, so saying "the preconditions and postconditions" would be technically incorrect, however explaining why that is the case (or even saying something like "a subset of" here) feels like a distraction.
preconditions and postconditions of a function directly in C++ code, and optionally checking those conditions at runtime to identify and mitigate program defects, in a configurable and scalable fashion. 

Unlike assertion statements (\tcode{contract_assert}) or pre-C++26 macro-based assertions, function contract assertions are a part of the function's \emph{declaration} and are thus readily found by humans, compilers, IDEs, and static analysis tools without having to inspect the function's definition. 

However, a major limitation of the initial feature set in C++26 is that \tcode{pre} and \tcode{post} cannot be placed on a \emph{virtual} function; doing so renders the program ill-formed. This limitation exists due to ongoing disagreements in WG21 regarding the desired behaviour of \tcode{pre} and \tcode{post} on virtual functions that could not be resolved in the C++26 timeframe.

At the same time, virtual functions are widely used in C++ today. Many codebases and popular libraries rely on runtime polymorphism as a key aspect of their design. Therefore, to ensure a successful adoption of contract assertions across the C++ ecosystem, we must add meaningful and user-friendly support for \tcode{pre} and \tcode{post} on virtual functions (as pointed out in \cite{P3173R0}).

In this paper, we consider everything we have learned since the adoption of \cite{P2900R14} and undertake a new attempt at resolving the existing disagreements. The goal of this paper is to find a design for this feature that suits the needs of the C++ community and can get consensus in WG21.

\subsection{Prior art}

\subsubsection{Other programming languages}

Other popular programming languages, such as C\#, Java, and Python, offer assertions only as a library feature,\footnote{For C\# and Java, there exist language extensions that implement function contract assertions: Microsoft Code Contracts and the Java Modeling Language (JML), respectively. Neither of these facilities enjoys significant use today. Microsoft Code Contracts is officially deprecated. JML had some influence in the 2000s but is nowadays restricted to academic contexts; the tooling for it is somewhat arcane and difficult to install and use.} and as such do not offer true function contract assertions\footnote{To aid understanding, throughout this paper we use the terminology of the C++ Standard (such as overriding function, overridden function, function contract assertion, etc.) for analogous concepts in other programming languages, even though in many cases the users of those languages would choose different terminology.} that could meaningfully integrate with the  dynamic dispatch mechanisms in those languages. However, there is a small number of less popular programming languages that offer both true function contract assertions and dynamic dispatch as a language feature: Eiffel, D, and Ada. In these languages, function contract assertions and virtual functions can be composed in a meaningful way.

Eiffel, released in 1986, was the first programming language that allowed placing precondition and postcondition assertions on function declarations. In Eiffel, such assertions are spelled with \tcode{requires} and \tcode{ensures}, respectively. Eiffel was developed in conjunction with the Design by Contract (DbC) paradigm by Bertrand Meyer. Its design closely follows that paradigm.

In particular, Eiffel by construction enforces the constraint that in an overriding function, preconditions can only be widened and postconditions can only be narrowed. This is achieved by using a conjunction (via OR) of the precondition assertions and a disjunction (via AND) of the postcondition assertions of the overriding function and all functions in the inheritance hierarchy overridden by it.

The D programming language, released in 2001, offers function contract assertions since its inception. Precondition and postcondition assertions are spelled with \tcode{in} and \tcode{out} blocks, respectively. For virtual functions, D's design follows the Eiffel paradigm of OR-ing precondition assertions and AND-ing postcondition assertions across an inheritance hierarchy. However, there are also some notable differences in the detail.

The Ada programming language added the feature in Ada 2012. Ada seems to be the only language with true function contract assertions that enjoys a significant degree of active use in production code today (albeit it is still a niche language, primarily used in safety-critical and mission-critical industries such as aerospace, defence, transportation, and medical systems).

Ada's design for function contract assertions on virtual functions is particularly complex. The default syntax, \tcode{Pre} and \tcode{Post} respectively, corresponds to so-called \emph{specific} precondition and postcondition assertions. However, adding the \tcode{Class} attribute turns them into so-called  \emph{class-wide} precondition and postcondition assertions, \tcode{Pre\textquotesingle Class} and \tcode{Post\textquotesingle Class} respectively, with entirely different and rather unique semantics. Any given function can have both flavours of function contract assertions applied to it simultaneously.

A more detailed description of these historic designs, and how they could be applied to C++, can be found in Section~\ref{designs} of this paper.

The ability to express the contract of a function in code also exists in a number of academic research languages; Dafny and Spec\# are notable examples. However, the contract facilities in these languages are designed primarily for static correctness proofs rather than runtime checking. As a consequence, they are of a very different nature than the contract facility in C++26. The same is true for the experimental contracts facility in Kotlin. There also exists an experimental contracts facility for Rust that is realised via procedural macros; however, it does not seem to be integrated with Rust's mechanism for dynamic dispatch (trait objects). In this paper, we therefore do not consider applying these designs to C++.

\subsubsection{C++ proposals}

The first proposal for adding a contracts facility to C++ \cite{N1613} was directly inspired by the D language and therefore proposed the same design as realised in D: precondition and postcondition blocks that are OR-ed and AND-ed, respectively, across an inheritance hierarchy. The next revision, \cite{N1669}, changed this to OR-ing preconditions but enforcing that postconditions are the same across the entire hierarchy.
%, with the motivation that weakening postconditions is “useless in practice since the user cannot take advantage of the weaker precondition by performing a downcast.”
% TD: TODO: This motivation does not need to be in this overview; mention it somewhere else.
This proposal was revised a few more times, but ultimately did not succeed in WG21; the last revision was \cite{N1962}.

The second proposal for a contracts facility \cite{N3604} proposed contract assertions as a library feature, in the form of macros inside the function body. Therefore, it did not have true function contract assertions that could interact with dynamic dispatch. This proposal, too, did not succeed in WG21; the last revision was \cite{N4378}).

Following the abandonment of the second proposal, many different design options were explored in various papers. \cite{N4110} and \cite{P0147R0} argued in favour of the established DbC principle that preconditions should not be strengthened and postconditions should not be weakened. On the other hand, \cite{P0247R0} argued that inheriting checks on virtual functions, or requiring that checks on base class virtual interfaces match overriders ``does not work'', and that allowing an overriding function to both widen and narrow the preconditions of the overridden function might make sense because not everyone will want to call a function through the same interface.

\cite{N4415} and \cite{P0287R0} proposed a more conservative design than in previous proposals or in Eiffel, D, and Ada: virtual functions are constrained to have the same sequence of function contract assertions across the entire inheritance hierarchy. In an overriding function, the function contract assertion sequence of the overridden function can be either repeated or omitted (i.e., inherited implicitly); if it is repeated, it must be ODR-identical. \cite{P0380R0} made this design even more restrictive by requiring that the sequence be repeated on every overriding function; however, this restriction was rolled back again in \cite{P0380R1}. This was retained throughout C++2a Contracts (\cite{P0542R5}), which were adopted for the C++20 Working Draft and then removed again (\cite{P1823R0}).

After the failure of C++2a Contracts and the establishment of SG21, proposals continued to flip-flop between these two designs: \cite{P2388R4} made repeating the sequence on an overriding function optional, and \cite{P2521R5} made it mandatory again. \cite{P2954R0} added yet another variation: repeating the function contract assertion sequence on an overriding function was neither optional nor required but actually ill-formed; the sequence was always inherited implicitly. This design was approved by SG21.

However, after more investigation, implicit inheritance of the contract was found to be problematic (see \cite{P2932R3} Section 3.4). SG21 decided that, given the many concerns and disagreements over how function contract assertions should work on virtual functions, consensus on a comprehensive
solution could be deferred to a future extension, and virtual function support was thus removed
entirely from the proposal. This design was forwarded to EWG and LEWG.

However, in \cite{P3173R0}, a major compiler vendor stated that, given the importance and pervasive use of virtual functions in C++, a contracts facility that fails to support efficient use with virtual functions is inadequate for standardisation. It seemed unlikely at that point that EWG would adopt a contracts facility without support for virtual functions.

This led to the development of a new design for virtual function support in \cite{P3097R0} that resolved the known issues of previous designs. This design removed contract inheritance and introduced the notion of caller-facing and callee-facing function contract assertions. A counterproposal with yet another new design based on contract inheritance was made in \cite{P3169R0}. SG21 carefully considered all design options known at the time and forwarded the design in \cite{P3097R0} to EWG. This design was approved by EWG and incorporated into the C++26 proposal.

However, following this decision, concerns were raised in \cite{P3506R0} and in \cite{P3573R0} that the caller/callee model from \cite{P3097R0} that had been approved by EWG was a departure from the established DbC model; that it had insufficient deployment and usage experience in the field; and that it was too complex. A rebuttal paper \cite{P3506R0} argued that the caller/callee model is the most appropriate design for C++ and should be retained. EWG did not manage to resolve this disagreement in the C++26 timeframe and instead decided to ship contract assertions in C++26 without support for virtual functions.

A more detailed history of function contract assertions on virtual functions in C++, including poll results and references to all relevant papers, can be found in \cite{P2899R1} Section 3.3.2.

\subsection{Methodology}

The goals of this paper are twofold: to identify the design for supporting \tcode{pre} and \tcode{post} on virtual functions that best satisfies the needs of the C++ community, and to facilitate establishing consensus in WG21 in favour of such a design. To achieve these goals, we analyse the available design space as exhaustively and objectively as possible. Our analysis follows the method for finding consensus on technical design questions developed in \cite{P3850R0}. This method is an evolution and adaptation of the Principled Design method developed in \cite{P3004R0} and \cite{P3005R0}.

We begin by establishing the basic terms and concepts used in the remainder of the paper (Section~\ref{prerequisites}). We then identify the desirable properties that a design for this language feature should exhibit (Section~\ref{properties}). We take into account all relevant properties that were articulated by members of WG21. We describe each property as precisely as possible, along with motivation for and against, use cases, and code examples. To minimise bias, we treat all properties equally and do not attempt to rank them by importance or other criteria.

Next, we identify all known design options for this feature (Section~\ref{designs}), including all variations that have been shipped in other programming languages or proposed for C++ at some point. As a tool for efficiently navigating this design space, we introduce a framework for classifying all possible designs according to a small set of key design decisions, as well as a scheme to refer to each possible design with an unambiguous identifier that encodes this set of decisions.

We proceed by constructing an \emph{evolution graph}, i.e., determining which design options can be obtained by future evolution of other, more conservative design options (Section~\ref{evolution}). Such an evolution graph is useful in case the committee fails to get consensus one way or another between two mutually exclusive design options. In this case, we can fall back to the maximal common ancestor of both options in the evolution graph.

With this thorough mapping of the available design space, we conduct an analysis of how well each available design option satisfies the identified desirable properties (Section~\ref{matrix}). We visualise this analysis with a so-called \emph{conformance matrix}. 

In the final part of our analysis, we use the conformance matrix to identify the most promising candidate designs (Section~\ref{tree}). We distill the choice between these candidate designs down to two binary design decisions between concrete tradeoffs (``do we prefer satisfying property A or property B?'') that can be polled in EWG. We conclude with a recommendation for a concrete candidate design that seems to offer the best set of tradeoffs overall (Section~\ref{conclusion}).

\section{Prerequisites}
\label{prerequisites}

% TD: TODO: refer to this new section above

In this section, we establish the basic terms and concepts used in the remainder of the paper. We consistently follow the terminology specified in the C++ working draft \cite{N5014}. We also establish some additional concepts that help precisely describe different possible designs for supporting \tcode{pre} and \tcode{post} on virtual functions and their properties.

\subsection{Virtual functions and virtual function calls}

Here, we give a brief summary of how virtual functions and virtual function calls are specified in the C++ Standard.

A non-static member function is a \emph{virtual function} if it is declared with the keyword \tcode{virtual} or if it overrides a virtual function declared in a base class (\href{https://eel.is/c++draft/class.virtual#1}{[class.virtual]/1}). A non-static member function \tcode{f} in class \tcode{D} \emph{overrides} a virtual function \tcode{f} in class \tcode{B} if \tcode{D} is derived (directly or indirectly) from \tcode{B} and the two functions have corresponding signatures (\href{https://eel.is/c++draft/class.virtual#2.sentence-1}{[class.virtual]/1}).

%\item A virtual member function \tcode{g} of a class object $O$ is the \emph{final overrider} unless $O$ is a base class subobject and the most derived class of that object (which we also call the \emph{dynamic type} of the object) has another member function that overrides \tcode{g}.

A \emph{function call} is an expression of function type or function pointer type followed by parentheses containing a (possibly empty) argument list (\href{https://eel.is/c++draft/expr.call#1}{[expr.call]/1}). In this paper, we are primarily interested in function calls that refer to a member function of an object. If the expression refers to a virtual function other than by a qualified name, the function call is a \emph{virtual function call} (\href{https://eel.is/c++draft/expr.call#2}{[expr.call]/2}) or virtual call for short; otherwise the function call is a non-virtual call.

A virtual call performs dynamic dispatch and calls the final overrider (\href{https://eel.is/c++draft/expr.call#2.sentence-2}{[class.virtual]/1}), which depends on the dynamic type of the object. On the other hand, a non-virtual call simply calls the function that the function call expression refers to. Consider the following program:

\begin{codeblock}
struct Shape {
  virtual double area() const { 
    // dummy implementation
    return 0; 
  }
};

struct Circle : Shape {
  float radius = 0;
  float area() override { 
    return pi_v<float> * radius * radius; 
  }
};

void test1(Shape& s) {
  s.area();        // (1)
  s.Shape::area(); // (2)
}

int main() {
  Circle c {1};
  test1(c);
}
\end{codeblock}

In this example, (1) is a virtual function call that performs dynamic dispatch. The function referred to by the call expression, \tcode{Shape::area}, is called the \emph{statically chosen function} (\href{https://eel.is/c++draft/expr.call#4.sentence-1}{[expr.call]/4}). However, the function actually called is \tcode{Circle::area}, which is the final overrider in this case because the dynamic type of the object referred to by \tcode{s} is \tcode{Circle}. As a shorthand, we say that (1) calls the function \tcode{Circle::area} \emph{through} a virtual call to \tcode{Shape::area}.

On the other hand, (2) is \emph{not} a virtual function call, even though it calls a virtual function. It does not perform dynamic dispatch, but always calls the function \tcode{Shape::area}, regardless of the dynamic type of the object referred to by \tcode{s}.

Now, consider a slightly different way to call \tcode{Shape::area}:

\begin{codeblock}
void test2() {
  Shape s;
  s.area(); // (3)
}
\end{codeblock}

Notably, (3) \emph{is} a virtual function call, because it does not use a qualified name, even though in this case it is known at compile time that the dynamic type of the object \tcode{s2} will always be \tcode{Shape} because the object is used directly (not through a reference or pointer). Notionally, this call performs dynamic dispatch and calls the final overrider, which is \tcode{Shape::area}. In practice, any reasonable compiler will optimise away the dynamic dispatch and call \tcode{Shape::area} directly; this optimisation is permitted under the as-if rule because the observable abstract-machine behaviour is identical in both cases.

\subsection{Contracts and contract assertions}

Here, we give a brief summary of the terms and concepts used for describing contract assertions in C++; a more detailed discussion can be found in \cite{P2900R14} Section 2.1.

A \emph{contract} is a set of conditions describing the expected behaviour of a program or one of its components, such as a function or a class. The contract of a function consists of \emph{preconditions} and \emph{postconditions}. A precondition is a condition that is expected to hold when a function is called; a postcondition is a condition that is expected to hold when a function returns. Preconditions can be conditions on the arguments passed into a function or other program state at the point of the function call; postconditions can be conditions on the value returned by a function or other program state established by the function.

The contract of a function is usually a \emph{plain-language contract}, specified in human language explicitly (e.g., in the documentation and/or in the form of code comments) or assumed implicitly (e.g., as part of established coding conventions). However, a contract may also be specified directly in C++ using  \emph{contract assertions} (\href{https://eel.is/c++draft/basic.contract.general}{[basic.contract.general]}).
% TD: TODO: Consider mentioning the various benefits of assertions? Or does it not add anything valuable here?
C++26 adds three kinds of contract assertions: precondition assertions, postcondition assertions, and assertion statements. Precondition and postcondition assertions --- spelled using the contextual keywords \tcode{pre} and \tcode{post}, respectively --- apply to the declaration of a function and are thus collectively called \emph{function contract assertions} (\href{https://eel.is/c++draft/dcl.contract.func}{[dcl.contract.func]}).

In general, only a \emph{subset} of the plain-language contract can be expressed with contract assertions. For example, a precondition that an index passed into a function is within bounds can be expressed with a precondition assertion such as \mbox{\tcode{pre(index < size())}}, whereas a precondition that a pointer passed into a function points to a valid object of the correct type within its lifetime cannot (or at least not with the facilities available in C++26).

\subsection{Correctness}
\label{correctness}

A program or one of its components is \emph{correct} with respect to a specification if it behaves according to that specification when executed. Since the expected behaviour is described by the contract, a program or component is correct when it does not violate its contract. % TD: TODO: THIS IS CLUMSY I'M GETTING TIRED

However, in the remainder of this paper, we generally use the terms \emph{correct call} or \emph{correct implementation} of a function to mean {correct with respect to its contract assertions}, i.e., without violating them. Consistently, we use the term \emph{contract violation} to mean a violation of a contract assertion (regardless of whether that violation was detected by a runtime check), and not a violation of the plain-language contract.
 
\subsection{Direct and indirect calls}

The function contract assertions that \emph{apply to a function call} are the set of function contract assertions that will be evaluated\footnote{Note that \emph{evaluated} does not necessarily mean \emph{checked}, as contract assertions can also be evaluated with the \emph{ignore} evaluation semantic. However, it is recommended that implementations use checked evaluation semantics for contract assertions by default (see \href{https://eel.is/c++draft/basic.contract\#eval-3}{[basic.contract.eval]/3}).} as part of that function call. The key question that any design for supporting \tcode{pre} and \tcode{post} on virtual functions needs to answer is: which function contract assertions apply when a virtual function is called (for each possible way of doing so)?

To classify the possible answers to that question, it is useful to distinguish between \emph{direct} and \emph{indirect} function calls.\footnote{This terminology is not used by the C++ Standard but introduced for this paper.} A direct function call is a function call where the declaration of the function that will be called is known at the call site; an indirect function call is one where this is not the case.

A virtual function call is a form of indirect call; a call through a function pointer is another form of indirect call. On the other hand, a qualified call to a virtual function is a direct call. Further, any call to a non-virtual function (qualified or non-qualified) that does not involve indirection through a function pointer is also a direct call. 

The function contract assertions \emph{associated with a function} (\href{https://eel.is/c++draft/dcl.contract.func#1}{[dcl.contract.func]/1}) are the function contract assertions that apply to a direct call of \emph{that} function. For non-virtual functions  --- i.e., in all cases in C++26 today --- these are the function contract assertions defined on that function's first declaration (\href{https://eel.is/c++draft/dcl.contract.func#3.sentence-1}{[dcl.contract.func]/3}). If we allow function contract assertions on virtual functions, this may or may not continue to be the case, depending on the chosen design.

For example, if we choose a design that follows Eiffel or D, where function contract assertions are inherited from overridden functions, there will be additional function contract assertions associated with an overriding function that are not part of \emph{that} function's declaration. On the other hand, in a design like the one proposed in \cite{P3097R0}, this is not the case as function contract assertions are not inherited or otherwise silently pulled in from other places; in a direct call, only the function contract assertions specified on the called function's declaration are evaluated.

\subsection{Caller-facing and callee-facing assertions}

Finally, in order to discuss the behaviour for indirect calls more precisely, it is useful to distinguish between \emph{caller-facing} and the \emph{callee-facing} function contract assertions (a concept developed in \cite{P3097R0}). The caller-facing function contract assertions are those that are known at the call site. The callee-facing function contract assertions are those that are known at the definition of the function being called.

For a direct call, the caller-facing and callee-facing function contract assertions are the same set of assertions: they are the function contract assertions associated with the function being called. On the other hand, for an indirect call they are, in general, two different sets of assertions. 

For a call through a function pointer, the caller-facing function contract assertions are an empty set (as a function pointer cannot have function contract assertions in C++26; see \cite{P3327R0}), and the callee-facing contract assertions are those associated with the called function (the one whose address is contained in the value of the pointer).

For a virtual function call, the caller-facing function contract assertions are those associated with the statically chosen function, and the callee-facing function contract assertions are those associated with the called function (the final overrider chosen by dynamic dispatch). If we allow function contract assertions on virtual functions, it will depend on the chosen design whether the caller-facing and callee-facing function contract assertions that apply to a virtual function call can be different or must be the same set. For example, in Eiffel, D, and Ada, as well as in the design proposed in \cite{P3097R0}, they can be different, whereas the C++2a design (\cite{P0542R5}) requires that they be the same set.

There is also a compound case: indirection through a pointer to member function that results in a virtual call. In this case, the caller-facing contract assertions are an empty set, and the callee-facing contract assertions are those associated with the called function (the final overrider chosen by dynamic dispatch). Importantly, the contract assertions associated with the function that the pointer points to are \emph{not} in the set of function contract assertions that apply to the function call, as they are neither known at the call site, nor known at the definition of the function being called.

Figure~\ref{fig_callercallee} illustrates the concept of caller-facing and callee-facing function contract assertions. Note that the existence of caller-facing and callee-facing function contract assertions is not a property of any particular design for supporting \tcode{pre} and \tcode{post} on virtual functions, but a direct consequence of how indirect function calls work in C++.
% TD: Josh, do we need to clarify that this has nothing to do with TUs? I know why you think it doesn't (TUs are an implementation detail), and yet Lisa has "caller TU" and "callee TU" on her slides with that diagram.

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\begin{figure}[b]
\begin{center}
\includegraphics[scale=0.25]{images/D2900R9-callercallee}
\end{center}
\caption{Caller-facing and callee-facing function contract assertions in an indirect function call.}
\label{fig_callercallee}
\end{figure}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsection{Substitutability and the Liskov Substitution Principle}

The Liskov Substitution Principle (LSP) is an important but often-misunderstood design principle that is key to considering contract assertions on virtual functions. 
% TD: TODO: reformulate this. The concept of substitutability is derived from the LSP.

As originally stated by Barbara Liskov (TODO REFERENCES), the LSP does not directly talk about inheritance or virtual functions. Rather, it is formulated in the context of type theory. The LSP establishes a relationship between two types, ...

However, in the context of a programming language that features inheritance and polymorphism (such as C++), the term \emph{substitutable} usually means something slightly different. Given a class \tcode{Derived} that inherits from a class \tcode{Base}, \tcode{Base} is \emph{substitutable} by \tcode{Derived} if any correct use of \tcode{Base} --- in particular, any correct use of virtual functions through a reference or pointer to \tcode{Base} --- remains correct when the dynamic type of the object being accessed through such a reference or pointer is \tcode{Derived}. In this paper, we use this meaning in an even more specific sense, since by \emph{correct} we mean correct with respect to the contract assertions (see Section~\ref{correctness}). 

TODO GOOD EXAMPLES

\subsection{Bertrand Meyer's Design by Contract}

TODO

\section{Desirable properties}
\label{properties}

% TD: TODO: add a property that indirect calls where static and dynamic type are equal should have the same set of function contract assertions as direct calls.

\subsection{General approach and selection criteria}

In this section, we identify the desirable properties that a design for supporting \tcode{pre} and \tcode{post} on virtual functions should exhibit. We take into account all relevant properties articulated by members of WG21 (whether formally in papers or informally during meetings or on the committee mailing lists)  during discussions about this feature so far.

Each property is given a short unique identifier to easily refer to it later in the paper, for example \propref{ImplExp} for implementation experience. The entry for each property is structured as follows:
\begin{itemize}
\item \emph{Description}: A section describing each property as precisely as possible.
\item \emph{Motivation}: Known arguments for satisfying this property.
\item \emph{Countermotivation} (where applicable): Known arguments against satisfying this property; known incompatibilities with other properties.
\item \emph{Example} (where applicable): Code example(s) illustrating use cases and motivation for the property. We strive to provide realistic examples rather than ``toy code'' whenever possible. 
\end{itemize}
We follow the consensus-building method developed in \cite{P3850R0}; thus, we focus on data and objectively verifiable information rather than opinions, and do our best to minimise cognitive bias and value judgments when describing the desirable properties. In particular, we do not attempt to rank the listed properties by priority, relevance, or otherwise. 

Some of the listed properties were originally articulated as ``design principles that must be adhered to'',  ``very important use cases'', ``necessary conditions for successfully deploying the feature'', etc. For the purpose of this analysis, we carefully avoid such characterisations and instead treat all properties equally. For properties that are describing a use case, we avoid any claims of how common (or contrived) it is due to lack of data from real-world code bases backing up such claims.

In a number of cases, it may be controversial whether the motivation is sound, the use case is plausible, and the property in question is actually desirable. In these cases, we strive to adopt a neutral position and limit ourselves to describing the property and the known arguments for and against supporting it.

We only include properties for which we can objectively and unambiguously answer the following question: does a given language design for supporting \tcode{pre} and \tcode{post} on virtual functions exhibit this property? We therefore deliberately exclude properties that are vague, subjective, and/or cannot be measured directly, such as teachability or intuitiveness of a particular design. We also do not include properties that could in principle be measured, but for which no concrete, measurable criterion is evident and no such criterion has been proposed by the proponents of that property.

For example, \cite{P3573R0} mentions the concern that \tcode{pre} and \tcode{post} on virtual functions ``have not been tried at scale''. However, the paper does not specify a measurable criterion for what would constitute sufficient ``scale''. We are happy to include this property in a future revision of this paper if the authors can provide a measurable criterion (e.g., a particular number of lines of deployed code that they consider sufficient deployment experience). Similarly, \cite{P3506R0} listed as a concern that the design proposed in \cite{P3097R0} was ``too complex''. However, since the author did not indicate how the complexity of any possible design could be measured, or what degree of complexity would be acceptable, we exclude this concern from our analysis.

Importantly, we are not suggesting that properties like teachability or complexity are not relevant for language design; quite the opposite. However, since they are inherently subjective, we do not consider them directly alongside other properties in our analysis. Instead, we consider more specific, objectively measurable properties that contribute to the teachability and complexity of a design.

\subsection{List of properties}


\subsubsection{Standardisation requirements}

The following properties describe general requirements that any proposal for supporting \tcode{pre} and \tcode{post} on virtual functions should meet in order to be considered for inclusion in the C++ Standard.

\prop{Wording}{Fully specified in C++ wording}

\emph{Description:}

The proposed design should be fully specified in C++ wording that has been reviewed by at least one Core expert, and should have no known, unresolved specification issues.

\emph{Motivation:}

 This is a standard requirement for language proposals before they can be forwarded to CWG for wording review and inclusion in the C++ working paper.  Without this requirement, we cannot plausibly claim that a proposed design has been fully specified and understood.

\prop{ImplExp}{Implementation experience}

\emph{Description:}

The proposed design should be implemented \emph{completely} in at least one major C++ compiler front-end (GCC, Clang, MSVC, or EDG). We do not require that the implementation has been upstreamed into the main branch of that compiler and shipped to users; an implementation on a development branch is sufficient. However, we do require that the implementation is freely available to users in some form, for example by making the source code of that development branch public or by making that compiler version available on Compiler Explorer.

\emph{Motivation:}

Only actual implementation experience is sufficient proof of implementability. As long as a design only exists as a ``paper exercise'', even with wording, it is still possible that we overlooked some significant issues with that design that would render it non-viable.

% TD: TODO: should we have another property in this section that the design should be deployable without an ABI break? If yes, should the requirement include only Itanium and Microsoft, or also more exotic ABIs such as IBM, HP-UX, Solaris?

\subsubsection{Design constraints}

The following properties describe design constraints that may be placed on the behaviour of \tcode{pre} and \tcode{post} on virtual functions. Some of these constraints match existing practice in other programming languages; others are motivated by the desire to avoid complexity and non-locality; others yet others aim to facilitate the deployment of a design for \tcode{pre} and \tcode{post} on virtual functions to C++ code bases at scale.

% TD: TODO: Should Subst be a property in its own right or not??
% We probably don't want to go into OR-ing and AND-ing

\prop{MeyerDbC}{Enforce Bertrand Meyer's Design by Contract}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should follow enforce Bertrand Meyer's Design by Contract paradigm, which stipulates that in an overriding function, preconditions can only be widened and postconditions can only be narrowed, but not vice versa.
% Do we want to go into OR-ing and AND-ing?

\emph{Motivation:}

% TD: TODO: REFORMULATE THIS ONCE DbC IS COVERED IN SECTION 2
Following the DbC paradigm when  specifying the semantics of \tcode{pre} and \tcode{post} on virtual functions is a well-known approach to enforcing the substitution principle, and is existing practice in the Eiffel and D programming languages with decades of implementation and usage experience.

\emph{Countermotivation:} 

% TD: TODO: REFORMULATE THIS ONCE DbC IS COVERED IN SECTION 2
The DbC paradigm (``widen preconditions, narrow postconditions'') is \emph{not} just an application of the substitution principle to contract checking (even though that is a common misconception), but imposes additional constraints. In particular, a function that has wider postconditions than the function it overrides if and only if is called \emph{outside} of the overridden function's preconditions satisfies \propref{SubstPr}, but does not satisfy \propref{MeyerDbC}. 

Thus,  in addition to those use cases that are not compatible with any form of enforcing the substution principle (see properties \propref{NarrowPre}, \propref{WidenPostIn}), there are more use cases for contract assertions that are not compatible with the DbC paradigm (see properties  \propref{WidenPostOut} and \propref{WidenPostMult}).

Further, the established strategy for enforcing the DbC paradigm --- OR-ing precondition assertions and AND-ing postcondition assertions across the inheritance hierarchy like in Eiffel or D --- is not compatible with satisfying the \propref{FailFast} property.

% TD: TODO: check if there are any more properties unsatisfiable with DbC regardless of the exact design chosen!

\emph{Example:}

Consider again the example from \propref{SubstPr} above. Function \tcode{Derived3::f} in that example satisfies property \propref{SubstPr}, i.e., it is fully substitutable for \tcode{Base::f}. However, it does not satisfy property \propref{MeyerDbC}, because it widens the overridden function's postconditions. Following DbC, the function \tcode{Derived3::f} as written should therefore either not compile, or its semantics should be such that returning a number from this function that is larger than the number passed in will cause a postcondition assertion violation.

\prop{FailFast}{Fail immediately on contract violation}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should continue to ensure, as C++26 Contracts do today, that the user can configure their program to fail immediately when any individual contract assertion fails. When a function contract assertion on a virtual function is evaluated with a checked semantic and that check fails, the program should immediately proceed to handling the contract violation and/or terminate, and not attempt to first evaluate other function contract assertions. In particular, precondition assertions from different functions should not be OR-ed across the inheritance hierarchy before determining whether a contract violation occurred.

\emph{Motivation:}

Eiffel, which OR-s precondition assertions across the inheritance hierarchy, is a memory-safe language, while C++ is not. Unlike in Eiffel, in C++ continuing past any individual failed assertion check, regardless of where in an inheritance hierarchy it occurs, is potentially unsafe and may lead to undefined behaviour and security vulnerabilities. A design for supporting \tcode{pre} and \tcode{post} on virtual functions should not introduce new opportunities for such vulnerabilities.

\emph{Example:}

Consider a virtual function with a precondition assertion as follows:

\begin{codeblock}
struct Y : X {
  virtual void usePtr(void* ptr) 
    pre (ptr != nullptr);
}
\end{codeblock}

Whenever the assertion \mbox{\tcode{ptr != nullptr}} is evaluated with the \emph{enforce} or \emph{quick-enforce} semantic, the program should be terminated (with or without calling the contract-violation handler first, depending on the chosen semantic). The program should not attempt to evaluate other function contract assertions specified on functions overriding (or overridden by) \tcode{Y::usePtr} past the failed check as this may be unsafe:

\begin{codeblock}
struct Z : Y {
  virtual void usePtr(void* ptr) 
    pre (ptr->useIt());
}
\end{codeblock}

\prop{VacuousTrue}{Vacuousness of \tcode{pre(true)} and \tcode{post(true)}}

\emph{Description:} 

On the declaration of a virtual function, \tcode{pre(true)} and \tcode{pre(false)} should always be vacuous, i.e., they should be equivalent to not specifying any precondition or postcondition assertion at all on that declaration. Whether or not \tcode{pre(true)} and \tcode{pre(false)} are present should not change which function contract assertions will be evaluated. In particular, adding \tcode{pre(true)} or \tcode{pre(false)} to a function declaration should not cause other, non-vacuous contract assertions to no longer be evaluated.

\emph{Motivation:}

This design constraint is consistent with the vacuousness of \tcode{pre(true)} and \tcode{post(true)} on non-virtual functions, as well as the vacuousness of \tcode{assert(true)}, \mbox{\tcode{contract_assert(true)}}, \mbox{\tcode{static_assert(true)}}, \tcode{requires(true)}, etc. in C++ today. Further, if we could not rely on this constraint being satisfied, this could lead to surprising behaviour in cases where the presence of a function contract assertion is conditional.

\emph{Example:}

Consider a function that takes a file path as a parameter. On Windows, there is historically a strict limit on the length of such paths; however, this limit does not exist on other platforms. We could make the contract predicate platform-dependent:

\begin{codeblock}
#ifdef _WIN32
  #define PATH_OK(path) path.size() < MAX_PATH 
#else
  #define PATH_OK(path) true
#endif

Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
    pre(PATH_OK(path)) {
      // ...
};
\end{codeblock}

Alternatively, we could conditionally macro out the entire precondition assertion:

\begin{codeblock}
Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
#ifdef _WIN32
    pre(path.size() < MAX_PATH)
#endif
  {
    // ...
};
\end{codeblock}

Both programming styles seem reasonable in cross-platform code. It would arguably be surprising to users if a design for \tcode{pre} and \tcode{post} on virtual functions would introduce cases where they lead to different contract assertions being evaluated.

\prop{EquivUnqual}{Equivalence of unqualified and qualified calls}

\emph{Description}:

An unqualified call of a virtual function where the statically chosen function is simultaneously also the function selected by dynamic dispatch should remain equivalent to a qualified call of the same function.

\emph{Motivation}:

An unqualified call of a virtual function is a virtual function call, which means that in general, the function that will be called (selected by dynamic dispatch) is not known at the call site. However, in some situations, the compiler can reason about which function will be called... TODO

\emph{Example}:

TODO

% TD: TODO: idea; group the following two use cases in a group specific to deploying in code bases where different components are controlled by different entities. Add ABI break to this group!
\prop{BaseIndep}{\tcode{pre} and \tcode{post} should be usable independent of base}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow a client of a virtual function to override that function in a derived class, add function contract assertions to the overriding function, and have those assertions evaluated, even if the base class is written against an older C++ Standard and does not use contract assertions at all.

\emph{Motivation:}

A base class and derived class may be located in different, independent components owned by different people or companies. A client of the base class may be deriving from it and overriding some virtual functions, yet unable to modify the base class.

In order to be deployable in such scenarios, a design for supporting \tcode{pre} and \tcode{post} on virtual functions should ensure that the client can add function contract assertions to overriding functions, and have those checked, even if the base class does not specify any function contracts at all (for example, because the component that owns the base class predates the addition of contract assertions to C++).

% TD: TODO: we may want to beef up this motivation

\emph{Example:}

Consider a GUI framework with a \tcode{Widget} base class as follows:

\begin{codeblock}
class Widget {
public:
  // Preconditions:   
  // \phantom{xxx}\tcode{child} points to a \tcode{Widget};
  // \phantom{xxx}\tcode{child->isValid()} is \tcode{true}; 
  // \phantom{xxx}\tcode{zOrder} is between -32768 and +32767.
  virtual void addChildWidget (Widget* child, int zOrder);
  
// ...
};
\end{codeblock}
This GUI framework is third-party code that we do not control and cannot modify. The function \tcode{Widget::}\allowbreak\tcode{addChildWidget} has preconditions, but those are not checked with function contract assertions as the code predates the availability of the feature.

In our own codebase, we have a framework of custom widget types, all inheriting from the \tcode{Widget} class above. For our own custom widget types at least, we would like to introduce precondition assertions for checking the preconditions:
\begin{codeblock}
class CustomWidget : public Widget {
public:
  void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767) 
  {
    // custom child/parent widget tracking logic here...
    Widget::addChildWidget(child, zOrder);
  }
}
\end{codeblock}

The precondition assertions of \tcode{CustomWidget::}\allowbreak\tcode{addChildWidget} should be evaluated whenever that function is called, without having to modify the \tcode{Widget} base class and despite the absence of precondition assertions in that base class.

\prop{NoRemoteBreak}{Avoid remote code breakage}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the author of a base class to add function contract assertions to a virtual function without breaking correct uses of derived classes in remote client code.

\emph{Motivation:}

A base class and derived class may be located in different, independent components owned by different people or companies. A base class does not in general know about or control clients deriving from it. A derived class in a different component may be overriding a function in the base class and have wider preconditions than the base class (see also \propref{WidenPre}), for example accept a wider range of input values than the overridden function does. Introducing function contract assertions to the overridden function that check the preconditions of \emph{that} function should not break correct uses of overriding functions with wider preconditions.

% TD: TODO: we may want to beef up this motivation

% TD: TODO: we may want to have a terminology section at the front where we clarify the difference between "preconditions" and "precondition assertions"

\emph{Example:}

Consider again the GUI framework from property \propref{BaseIndep}. As the owners of the base class \tcode{Widget}, we might want to introduce precondition assertions for checking the preconditions of \tcode{Widget::}\allowbreak\tcode{addChildWidget}, and roll out these assertions to clients that have a recent enough compiler to take advantage of them: 

\begin{codeblock}
class Widget {
public:
  virtual void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767);
}
\end{codeblock}

At the same time, one of our clients may have a widget type in their code base that can handle a wider range of values for \tcode{zOrder} just fine, and they may be using this type in production:

\begin{codeblock}
class SuperWidget : public Widget {
  // this version can handle any values for \tcode{zOrder}!
  void addChildWidget(Widget* child, int zOrder) override {
    // ....
  } 
}

class MyWindow : public SuperWidget;
class MyButton : public SuperWidget;
// ...

void drawMyApp() {
  myWindow.addChildWidget(myButton, 99999);
}
\end{codeblock}
As long as the client uses the \tcode{SuperWidget} interface instead of the base \tcode{Widget} interface for their widgets above, their program is correct --- there is no contract violation. Adding the above function contract assertions to \tcode{Widget::}\allowbreak\tcode{addChildWidget} should not break the client's correct program by introducing a precondition assertion violation to it.

% TD: There are other possible properties, somewhat related, that we could consider here (some of them I have written up already but did not include in the paper):
% - a qualified (i.e., non-virtual) call to a virtual function should evaluate the same FCAs as a virtual call to the same function if it is both the statically chosen function and the final overrider selected by virtual dispatch;
% - the only FCAs that should be evaluated in a virtual function call are those associated with the statically chosen function and the final overrider; when debugging a contract violation, the developer should not have to browse the entire inheritance hierarchy (which may be complex and spread over different components) to find the offending assertion
% - P2900R14 Principle 10: The evaluation of a function contract assertion must be tied to the evaluation of the function to which the function contract assertion is attached so that the assertion will verify the plain-language contract (or some proper subset of the plain-language contract) of that function, not of some other function.

\subsubsection{Single inheritance use cases}

The following properties describe the ability of a design  for \tcode{pre} and \tcode{post} on virtual functions to support concrete use cases where a virtual function overrides at most \emph{one} other virtual function.

\prop{WidenPre}{Widening preconditions}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{widen} preconditions in an overriding function, i.e., to specify precondition assertions that are less strict than those specified on the overridden function, or even specify that there are \emph{no} precondition assertions on the overriding function. Whenever the overriding function is called \emph{directly} (i.e., it is the statically called function), those less strict precondition assertions should be evaluated instead of the overridden ones.

\emph{Motivation:}

A derived class should be able to extend the functionality of the base class and accept arguments that are designed to work with that extended functionality. This ability to widen preconditions in an overriding function is established practice in languages like Eiffel, D, and Ada, and does not compromise substitutability of the base class by the derived class. Contract checking in C++ should support this practice.

\emph{Example:}

Consider the following motivating use case from \cite{P0247R0}:
\begin{codeblock}
class Display {
public:
  virtual void post_message(std::string_view s)
     pre (is_ascii(s)) = 0;
};

class XDisplay : public Display {
   // ...
public:
  void post_message(std::string_view s) override
    pre (is_utf8(s));
 };
\end{codeblock}
In this example, we have a base class facility that accepts ASCII strings to display. However, the derived implementation accepts UTF-8. A program that does not rely on the \tcode{Display} base class interface, but uses the \tcode{XDisplay} class directly should be able to generate and post both ASCII and UTF-8 messages. In other words, the following program should not cause a contract violation when executed:
\begin{codeblock}
void test(XDisplay& xd) {
  xd.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}
In this program, the statically called function is \tcode{XDisplay::post_message}, and the dynamic type is \tcode{XDisplay} (it could also be a type deriving from \tcode{XDisplay}). The overridden function \tcode{Display::post_message} is not called, therefore satisfying its narrower precondition that the input string must be ASCII is not relevant to the correctness of this program.

\prop{ChkPreCaller}{Checking caller-facing preconditions}

\emph{Description:}

In a virtual function call, the precondition assertions specified on the statically called function should be evaluated by default, regardless of which function will be selected by dynamic dispatch and what  precondition assertions are specified on that function.

\emph{Motivation:}

Calling a virtual function in a way that violates the statically called function's preconditions is an incorrect use of that interface, regardless of the dynamic type of the called object. This bug should be detectable by contract checking. Even if the dynamic type of the object has wider preconditions and would work correctly for such a call, that dynamic type is not known at the call site and can change in the future, therefore the call site cannot rely on it.

\emph{Example:}

Consider again the \tcode{Display} --- \tcode{XDisplay} inheritance hierarchy from property \tcode{WidenPre}. Let us slightly alter the \tcode{test} function such that it takes a reference to the base class \tcode{Display}:
\begin{codeblock}
void test(Display& d) {
  d.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}
The above program should cause a contract violation when executed, because it violates the preconditions of the statically called function (\tcode{Display::post_message}), even though  the dynamic type of the object referenced by \tcode{d} happens to be \tcode{XDisplay}, which means the function actually executed will be \tcode{XDisplay::post_message} and the preconditions of that function are satisfied (it can handle non-ASCII strings).

\prop{NarrowPost}{Narrowing postconditions}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} postconditions in an overriding function, i.e. to specify postcondition assertions that are more strict than those of the overridden function. Whenever the overriding function is executed, its stricter postcondition assertions should be evaluated (regardless of what the statically called function is or what its postcondition assertions are). Failure should cause a contract violation, even if all postcondition assertions of the overridden function are satisfied.

\emph{Motivation:}

Subclasses that have compatible contracts with their base class can often provide additional guarantees that the base class does not require of all potential subclasses. Being able to express these additional guarantees in the form of postcondition assertions on the overridden function benefits users, compilers, and tools. Failing to meet these additional guarantees is a bug in the subclass that should be detected by contract checking. Importantly, this is true even when the direct caller does not directly depend on that guarantee because it is using the base class interface.

The ability to narrow postconditions in an overriding function is established practice in languages like Eiffel, D, and Ada, and does not compromise substitutability of the base class by the derived class. Contract checking in C++ should support this practice.

\emph{Example:}

Consider an abstract class that is used to generate sequences of integers through a virtual function:

\begin{codeblock}
struct Generator {
  virtual int next() = 0;
};
\end{codeblock}
Many different derived classes might be implemented that produce different sequences. A particularly simple implementation may always produce the same constant value, which can be specified by the user:
\begin{codeblock}
struct ConstantGenerator : Generator {
  void setValue(int value);
  int getValue(); 
  int next() override
    post (r: r == getValue());
}
\end{codeblock}
The above postcondition assertion is specific to the implementation of \tcode{ConstantGenerator::}\allowbreak\tcode{next()}. A violation of that postcondition assertion indicates a bug in the implementation of \tcode{ConstantGenerator}. Therefore, the following program should cause a contract violation when executed:
\begin{codeblock}
void test(Generator& gen) {
  std::print(gen.next());
}

int ConstantGenerator::next() override {
  return 0;  // dummy implementation  
} 

int main() {
  ConstantGenerator constGen;
  constGen.setValue(42);
  test(myGen);
}
\end{codeblock}


\prop{NarrowPre}{Narrowing preconditions}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} preconditions in an overriding function, i.e., to specify precondition assertions 
 that are \emph{more strict} than those of the overridden function. Whenever the overriding function is executed (regardless of what the statically called function is), these more strict precondition assertions should be evaluated. Failure should cause a contract violation, even if all precondition assertions of the overridden function are satisfied.
 
 \emph{Motivation:}
 
Narrowing preconditions becomes necessary when usage of the derived class depends on adhering to additional constraints or setting up additional state (database connections, threads, etc.) that the base class does not depend on.  Such designs can often have favourable tradeoffs such as simplicity and performance.

While narrowing preconditions violates the substitution principle (\propref{SubstPr}) and Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}), such \emph{non-canonical} designs are correct and useful when unconditional substitutability of the base class by the derived class is not required or expected. These designs exist and are used in practice, especially in performance-critical or domain-specific systems and in situations where the same team controls the entire codebase and is aware of the expected usage patterns.

Often, the narrower preconditions of the overriding function can be guaranteed non-locally by designing the program accordingly. Thus, the derived class is substitutable for the base class in \emph{that} program (even if not for all possible usages of that inheritance hierarchy). Failure to establish the substitutability criteria at runtime is a bug (an incorrect usage of the derived class). A design for supporting \tcode{pre} and \tcode{post} on virtual functions that accommodates this use case enables users to leverage contract checking to detect such bugs. 

On the other hand, users may not be able to afford refactoring their existing codebase to adhere to the substitution principle or Design by Contract paradigm; instead, if C++ contract checking does not support their current design, they will simply not add contract assertions to their code.
 
 \emph{Example:}
 
Consider a base class for rendering an image:

\begin{codeblock}
class Image {
public:
  virtual void render() const;
};
\end{codeblock}

Now consider a derived class that renders the image on a GPU. This implementation is more efficient and powerful, however it requires the user to perform an additional initialisation step before the image can be rendered:

\begin{codeblock}
class GPUImage : public Image {
public:
  bool prepare() { 
    // upload data to GPU, handle errors...
    return readyToRender;
  }
  
  void render() const override
    pre (readyToRender);
};
\end{codeblock}

A program that ensures a successful call to \tcode{prepare} always happens before a call to \tcode{render} is correct; failure to do so is a bug that should be detectable by contract checking. 

To support this use case and diagnose incorrect use, the precondition assertion \mbox{\tcode{pre(readyToRender)}} would need to be well-formed, evaluated whenever \tcode{GPUImage::render} is executed, and trigger a contract violation in case of failure, even if the statically called function is \tcode{Image::render} and all preconditions of that functions are met.


\prop{WidenPostOut}{Widening postconditions outside of base contract}

\emph{Description:}

In addition to allowing widening preconditions in overriding functions (see \propref{WidenPre}), a design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function in cases where the overriding function is called outside of the overridden function's preconditions (but within its own preconditions).

\emph{Motivation:}

The need to widen postconditions arises when an overriding function operates on a larger domain than the function it overrides (i.e., it has wider preconditions). When the overriding function is called outside of the overridden function's preconditions (but within its own preconditions), there is no need to satisfy the overridden function's postconditions as the call in question would not be a correct use of the overridden function anyway (even though it is a correct use of the overriding function). The overriding function therefore can have wider postconditions for such outside-of-base-contract calls. Contract checking in C++ should support this scenario.

When widening postconditions in this way, the overriding function is still fully substitutable for the overridden function. Supporting this use case is therefore compatible with the substitution principle (\propref{SubstPr}). However, it is not  compatible with Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}).

\emph{Example:}

Let \tcode{Number} be a generic type that can represent real or complex numbers. Now, consider a type \tcode{Sqrt} that computes a real-number square root. The function \tcode{Sqrt::compute} requires a nonnegative real number as input, and returns another nonnegative real number as output. We can specify this contract using function contract assertions:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre(x.isReal() && x.realPart() >= 0)
    post(r : r.isReal() && r.realPart() >= 0);
};
\end{codeblock}

This implementation of square root might have a number of useful properties, such as computing the result very efficiently with hardware instructions. However, \tcode{Sqrt} is also a polymorphic type, so that the user can substitute other implementations of square root that have different tradeoffs.

Later on, we might add an implementation of square root to our codebase that can handle the entire complex plane and therefore drops the precondition and postcondition assertions of \tcode{Sqrt::compute}:

\begin{codeblock}
struct ComplexSqrt : public Sqrt {
  Number compute(const Number& x) override;
};
\end{codeblock}

This implementation may or ma use the more optimised real-numbers only \tcode{Sqrt}

When used as a \tcode{Sqrt}, which requires satisfying the preconditions of the overridden function \tcode{Sqrt::compute}, \tcode{ComplexSqrt::}\allowbreak\tcode{compute} gives clients the same guarantee that clients  expect from any implementation of \tcode{Sqrt}: if the user passes a nonnegative real number, they will get back a nonnegative real number. It may even internally use the base class implementation \tcode{Sqrt::compute} for this case. \tcode{Sqrt} is therefore fully substitutable by \tcode{ComplexSqrt}. Consider, for example, the following function that uses an instance of \tcode{Sqrt} to compute the fourth root of a given \tcode{Number}:

\begin{codeblock}
Number quadroot(Number value, const Sqrt& sqrt) {
  if (!value.isReal() || value.realPart() < 0) {
    throw std::domain_error("Must pass a nonnegative real number");
  }
  Value v = sqrt.compute( {value} ); // v is a nonnegative real number
  return sqrt.compute( {v} ); // preconditions satisfied 
}
\end{codeblock}

Client code such as this last line of \tcode{quadroot}, which invokes a virtual function through a base class interface, invariably depends on the postconditions of that base class interface. Thus, the postconditions of that base class should be checked when calling an object of derived class through a base class interface.

However, the implementation \tcode{ComplexSqrt} does not --- and cannot --- guarantee that it will return a nonnegative real number in \emph{all} cases. Importantly, such a guarantee is not necessary or expected when the preconditions of the base class are not met. When the function \tcode{ComplexSqrt::compute} is used directly, the calling code is not required to satisfy the preconditions of \tcode{Sqrt::compute} and can pass any complex number:

\begin{codeblock}
int main() {
  Number complexUnit = ComplexSqrt().compute(-1);
}
\end{codeblock}

Here, \tcode{ComplexSqrt::compute} correctly returns a value that is \emph{not} a nonnegative real number. This code should not cause a contract violation; the fact that \tcode{ComplexSqrt::compute} does not satisfy the postconditions of \tcode{Sqrt::compute} in this particular case is irrelevant to the correctness of the program.

\prop{WidenPostIn}{Widening postconditions inside base contract}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function. Whenever that overriding function is the statically called function, its wider postcondition assertions should be evaluated instead of the overridden function's postcondition assertions. However, if the overridden function is the statically called function, its narrower postcondition assertions should be evaluated, even if the overriding function is selected by dynamic dispatch.

\emph{Motivation}:

Widening postconditions even if the preconditions of the overriding function are met becomes necessary when the overriding function is not substitutable for the overridden function for all inputs, but \emph{is} substitutable for the overridden function for the particular inputs used. Often, additional information is available about how the polymorphic object will be put to use in particular circumstances, and such limited-use overrides can therefore be used correctly. Situations where such designs are used in practice include testing and mocking. 

This use case is the dual to \propref{NarrowPre}; it is another \emph{non-canonical} design that violates the substitution principle (\propref{SubstPr}) and Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}). Nevertheless, it is not necessarily incorrect. A design for supporting \tcode{pre} and \tcode{post} on virtual functions that accommodates this use case enables users to leverage contract checking to verify correct usage of such a derived class and identify bugs.

\emph{Example}:

Consider again the base class \tcode{Sqrt} from property \propref{WidenPostOut}. We might want to add an implementation of square root \tcode{IntOnlySqrt} that is extremely efficient for perfect square integers (1, 4, 9, ...) but returns -1 for other integers, thus violating the postcondition of \tcode{Sqrt::compute} for some inputs.

As another example, consider how mock types are used in a test suite. Imagine an algorithm that depends on a \tcode{Sqrt} implementation:

% TD: TODO: you need to make compute() const in all implementations above
\begin{codeblock}
Value sumSqrts(const std::vector<Value>& values, const Sqrt& sqrtFunction) {
  Value sum = 0;
  for (auto&& value : values)
    sum += sqrtFunction(value);
    
  return sum;
}
\end{codeblock}

Now, we might want to write unit tests to verify the correctness of \tcode{sumSqrts}, but without pulling in a fully functional \tcode{Sqrt} implementation. Instead, we can use a mocking strategy. The following generic mock function template can be set to expect any specified value as an argument for and return any specified value from the next call to \tcode{compute}:

\begin{codeblock}
template <typename Base>
void MockFunction : public Base {
  void setInput(const std::vector<Value>& expectedArguments);
  const std::vector<Value>& getInput() const;
  
  void setOutput(const Value& value);
  Value getOutput() const;
  
  Value compute(const std::vector<Value>& arguments) override
    pre (arguments == getInput())
    post (r: r == getOutput());
};
\end{codeblock}

With this mock template, we can write a unit test for \tcode{sumSqrts} as follows:

\begin{codeblock}
void testSumSqrts() {
  // verify that \tcode{sumSqrts} works correctly to sum a vector of 4s:
  std::vector<Value> values = {4, 4, 4, 4};
  MockFunction<Sqrt> mockSqrt;
  mockSqrt.setInput({4});
  mockSqrt.setOutput({2});
  
  ASSERT(8 == sumSqrts(values, testSqrt));
}
\end{codeblock}

The function \tcode{MockFunction<Sqrt>::compute} does not \emph{always} establish the postconditions of \tcode{Sqrt::compute} (i.e., it has wider postconditions), but it does so for the inputs used in the above unit test. The unit test is therefore correct.

In order to support this use case, the precondition and postcondition assertions of the overriding function  (which may be narrower and/or wider than those of the overridden function) should be evaluated whenever it is selected by dynamic dispatch, to diagnose bugs in the implementation of that overriding function. Simultaneously, the precondition and postcondition assertions of the overridden function should also be evaluated whenever it is the statically called function, to diagnose erroneous use of the base class interface as well as failure of the derived class to establish the postconditions that the call site may rely on. 

\prop{InhDefault}{Inherit function contract assertions by default}

\emph{Description}:

When a virtual function specifies function contract assertions, and is then overridden by another virtual function in a derived class, the overriding function should, by default, \emph{inherit} the function contract assertions of the overridden function. That is, if the overriding function does not specify its own precondition or postcondition assertions, those of the overridden function should apply, even if the overriding function is called directly and not through the overridden interface.
% TD: TODO: here and everywhere else, replace "directly" with something like "...is the statically called function and the overridden function is not used".

\emph{Motivation}:

Function contract assertions introduced in a base class --- to detect incorrect use, incorrect implementations, or guard against program failure and security vulnerabilities --- can be equally useful for a derived class, even if that derived class is used directly, not through the base class interface.  At the same time, authors of derived classes may fail to consider that they want and need those assertions on their own implementation. Thus, having those derived classes inherit the function contract assertions from the base class automatically is a ``safe default''.

\emph{Countermotivation}:

If function contract assertions are inherited by default, then an opt-out to disable such inheritance (see \propref{InhOptDerived}) may be necessary to support use cases where precondition or postcondition assertions need to be widened in the overriding function (\propref{WidenPre}, \propref{WidenPostIn}, \propref{WidenPostOut}). 

Further, this property is incompatible with property \propref{NoRemoteBreak}. If function contract assertions are inherited by default, then a pre-existing override with no function contract assertions may break when function contract assertions are introduced to the overridden function. This may break a correct program if the overriding function has wider precondition or postcondition assertions and the existing program exploits this.

While it might be possible to work around such remote code breakage with the aforementioned opt-out, that requires a modification of the derived class, at which point it may be too late because the program already broke in production. Note that the base class may be coming in via a third-party component that the owner of the derived class may not control.
% TD: TODO: double check you don't have duplication between here and NoRemoteBreak.

\emph{Example}:

As an example for inheriting \emph{precondition} assertions by default, consider \tcode{QIODevice}, the base interface class of all I/O devices in the Qt framework.\footnote{Documentation available here: \url{https://doc.qt.io/qt-6/qiodevice.html}} This class has a number of virtual functions such as \tcode{readData} which take a raw data pointer to read bytes from. In a future version of Qt, one might want to add a precondition assertion to check that this pointer is not null:
\begin{codeblock}
class QIODevice {
public:
  virtual qint64 readData(char* data, qint64 maxSize)
    pre (data != nullptr) = 0;
};
\end{codeblock}
Now, if a user inherits from \tcode{QIODevice} and overrides \tcode{readData}, it would be useful if the same null pointer check automatically applied to their override, without them having to specify any function contract assertions themselves. Specifically, in the following program,
\begin{codeblock}
class MyIODevice : public QIODevice {
public:
  qint64 readData(char* data, qint64 maxSize) override {
    // my implementation...
  }
};

int main() {
  char* data = nullptr;
  qint64 size = 0;
  
  MyIODevice device;
  device.readData(data, size);
}
\end{codeblock}
the last line of \tcode{main} should trigger a contract violation when checks are enabled, even though the derived class \tcode{MyIODevice} is used directly rather than through the base class interface \tcode{QIODevice}. 

As an example for inheriting \emph{postcondition} assertions by default, consider a base class for different algorithms that choose one number out of a non-empty set of numbers:
\begin{codeblock}
struct NumberPicker {
  virtual int pick(const Array<int>& numbers)
    pre (!numbers.empty())
    post (r: numbers.contains(r)) = 0;
};
\end{codeblock}
Now consider different implementations of this base class:
\begin{codeblock}
struct FirstNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[0];
  }
};

struct RandomNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[rand() % numbers.size()];
  }
};
\end{codeblock}
We expect that any correct implementation of  \tcode{NumberPicker} must satisfy both the precondition and postcondition assertions of \tcode{NumberPicker::pick}. Therefore, those assertions should be checked even in cases in which the derived class interface is used directly, for example in a statically polymorphic context:
\begin{codeblock}
template <typename T>
int pickNumber(T& picker, const Array<int>& numbers) {
  return picker.pickNumber();
}

int rollDice() {
  return pickNumber(RandomNumberPicker(), {1, 2, 3, 4, 5, 6});
}
\end{codeblock}
In the above case, if the implementation of \tcode{RandomNumberPicker::pick} fails to satisfy the postcondition assertion of \tcode{NumberPicker::pick}, we should get a contract violation.

There are also examples where inheriting function contract assertions can lead to the kind of remote code breakage that property \propref{NoRemoteBreak} seeks to avoid. Consider an override of \tcode{QIODevice::}\allowbreak\tcode{readData}  that can handle null pointers just fine, or an override of \tcode{NumberPicker::}\allowbreak\tcode{pick} that returns a dummy value for some inputs, and correct uses of such functions (see also \propref{WidenPre}, \propref{WidenPostOut}, and \propref{WidenPostIn}). 

\subsubsection{Multiple inheritance use cases}

The following properties describe the ability of a design  for \tcode{pre} and \tcode{post} on virtual functions to support concrete use cases where a virtual function overrides more than one other virtual function.

\prop{WidenPreMult}{Override multiple functions with incompatible preconditions}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should make it well-formed to override multiple functions with different --- and potentially mutually exclusive --- precondition assertions. Which of these precondition assertions are evaluated should depend on the statically called function. 

\emph{Motivation}:

This property is an extension of property \propref{WidenPre} to multiple inheritance. It seems reasonable to inherit from multiple base classes which have mutually exclusive preconditions on a function, and to provide an implementation with wider preconditions that satisfies both domains. Such designs are correct and do not violate the substitutability principle (\propref{SubstPr}) or Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}).  C++ contract checking should support such designs.

\emph{Example}:

Consider a function-type hierarchy that might be used, for example, when writing
a simple expression interpreter, where all types in the hierarchy extend a common abstract base
class:

\begin{codeblock}
struct Function {
  virtual Value compute(const std::vector<Value>& arguments);
};
\end{codeblock}

For certain situations, a unary or binary function might be required and we could choose to model
this as subclass of \tcode{Function}:

\begin{codeblock}
struct UnaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    pre(arguments.size() == 1);
};

struct BinaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    pre(arguments.size() == 2);
};
\end{codeblock}

Now, there are variadic functions that can be used as both unary and binary functions:

\begin{codeblock}
struct VariadicFunction : public UnaryFunction, public BinaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    /*no preconditions */;
};
\end{codeblock}

Any code that uses a \tcode{UnaryFunction} is obliged to pass a single-element list of arguments to that
code (see also \propref{ChkCallerPre}). Similarly, two arguments are necessary for anything that uses \tcode{BinaryFunction}. Functions that make use of a \tcode{UnaryFunction}, however, will work completely correctly when handed a \tcode{VariadicFunction} that could take additional arguments when used differently. C++ contract checking should support all of these cases.

\prop{WidenPostMult}{Override multiple functions with incompatible postconditions}

\emph{Description}:
A design for supporting \tcode{pre} and \tcode{post} on virtual functions should make it well-formed to override multiple functions with different --- and potentially mutually exclusive --- postcondition assertions. Which of these postcondition assertions are evaluated should depend on the statically called function. 

\emph{Motivation}:

This property is an extension of property \propref{WidenPostOut} to multiple inheritance. A virtual function might override two functions that have not only mutually exclusive preconditions, but also mutually exclusive postconditions, and yet be fully substitutable for either. Such a design is correct and should be supported by C++ contract checking. Like  \propref{WidenPostOut}, this use case is compatible with the substitution principle (\propref{SubstPr}), but not with Bertrand Meyer’s Design by Contract paradigm (\propref{MeyerDbC}). 

\emph{Example}:

Consider a function type that requires
an even number as input and guarantees an even number as output, and another that operates in
the same fashion on odd numbers:

\begin{codeblock}
struct EvenComputer {
  virtual int compute(int x)
    pre(isEven(x))
    post(r : isEven(r));
};

struct OddComputer {
  virtual int compute(int x)
    pre(isOdd(x))
    post(r : isOdd(r));
};
\end{codeblock}

Now consider the following function, which inherits from both and satisfies the contract of both:

\begin{codeblock}
struct Identity : EvenComputer, OddComputer {
  int compute(int x) override { 
    return x; 
  }
}
\end{codeblock}

The type \tcode{Identity} is substitutable for both \tcode{EvenComputer} and \tcode{OddComputer}. Therefore, the above definition of such a type, and correct usages of it, should be allowed and should not cause contract violations.

%TD: TODO: Do we need a property to say that virtual inheritance should work? I'm having a hard time coming up with a use case for virtual inheritance where we would have interesting things going on with pre/post

\subsubsection{Optional behaviour}

All properties presented so far relate to the possible \emph{default} behaviour of \tcode{pre} and \tcode{post} on virtual functions. However, during discussions of this feature a concern came up repeatedly that specifying the default behaviour, regardless of how this is done, cannot provide the flexibility needed to  satisfy all relevant use cases for \tcode{pre} and \tcode{post} on virtual functions.

Therefore, the following properties describe use cases where the user might want to explicitly opt into --- or out of --- different possible behaviours for \tcode{pre} and \tcode{post} on virtual functions.

\prop{InhOptBase}{Choose in the overridden function whether to inherit}
 
\emph{Description}: 
 
A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a base class the option to choose whether a particular function contract assertion should be automatically inherited by any overriding functions.

\emph{Motivation}:

Some function contract assertions in a base class may not be relevant when a derived class is used directly (not through a reference to the base class). Other such assertions may be relevant for the derived class even in this case, for example because they specify expectations the author of the base class has on \emph{any} derived class in order to be considered correct, and/or because they guard against program failures and security vulnerabilities that the user of the derived class may benefit from even if they are unaware of that. 

In order to cover both situations, it would be useful for the author of the base class to specify explicitly whether or not any particular function contract assertions should be automatically inherited by any overriding functions. Such an explicit choice could be useful regardless of whether such inheritance of function contract assertions happens by default (\propref{InhDefault}) or not.

\emph{Countermotivation}:

Any design that offers the user this choice would need to consider whether an opt-out, i.e., \emph{not} inheriting that assertion, should still be possible on the derived class, even if the base class specified that the assertion should be inherited. If such an opt-out on the derived class is allowed, it would make the design more complex; on the other hand, if no opt-out is possible, it would make widening those assertions in an overriding function outright impossible, precluding use cases like \propref{WidenPre}, \propref{WidenPostOut}, and \propref{WidenPostIn} for those assertions.

\emph{Example}:

Consider again the \tcode{Sqrt} type from \propref{WidenPostOut}. We might want to add another postcondition assertion verifying that the numerical value returned from the \tcode{compute} member function actually \emph{is} the square root of the value passed in, or at least some acceptable approximation of it:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre(x.isReal() && x.realPart() >= 0)
    post(r : r.isReal() && r.realPart() >= 0)
    post(r: approxEquals(r * r, x));
};
\end{codeblock}

Now, we might want to specify that the first two function contract assertions should not be automatically inherited by  overrides (because we expect derived classes to operate on a wider domain than the base class), while the last function contract assertion should be (because we consider it essential for any correct implementation of \tcode{Sqrt::compute} to satisfy that condition):

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre /* do not inherit */  (x.isReal() && x.realPart() >= 0)
    post /* do not inherit */ (r : r.isReal() && r.realPart() >= 0)
    post /* inherit */       (r: approxEquals(r * r, x));
};
\end{codeblock}

On the other hand, even if the last postcondition assertion is inherited by default, a derived class like \tcode{IntOnlySqrt} or \tcode{MockFunction<Sqrt>} (as discussed in \propref{WidenPostIn}) may still need to opt out of that inheritance in order to be usable.

\prop{InhOptDerived}{Choose in the overriding function whether to inherit}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a derived class the option to choose whether a particular override should inherit the function contract assertions of the overridden function. If the virtual function in question overrides multiple functions, it should be possible to choose which override(s) to inherit assertions from.

\emph{Motivation}:

Regardless of whether function contract assertions are inherited by default (\propref{InhDefault}), an overriding function should have the option to choose whether such inheritance should happen.

If function contract assertions are inherited automatically, an opt-out is necessary to support use cases where precondition or postcondition assertions need to be widened in the overriding function (\propref{WidenPre}, \propref{WidenPostIn}, \propref{WidenPostOut}). 

If function contract assertions are \emph{not} inherited automatically, it may still be useful to have them apply to the overriding function as well (even if that overriding function is the statically called function). Note that simply repeating the sequence of function contract assertions from the overridden function on the overriding function is not an acceptable solution: lexical repetition may be too cumbersome and verbose, it is brittle because it would need to be manually kept in sync with the overridden sequence, and it may even be impossible because the function contract assertions in the base class may be referring to private members (so the same predicates may not compile in the context of the derived class, or worse, may compile but lead to a different result because name lookup finds different entities).

\emph{Example}:

TODO

\prop{VirtOnly}{Check \tcode{pre} and \tcode{post} only in a virtual call}

\emph{Description}:

TODO

\emph{Motivation}:

TODO

\emph{Example}:

TODO 

\prop{NonVirtOnly}{Check \tcode{pre} and \tcode{post} only in a non-virtual call}

\emph{Description}:

TODO

\emph{Motivation}:

TODO

\emph{Example}:

TODO 

\prop{CallerOnly}{Check \tcode{pre} and \tcode{post} only when caller-facing}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give users the option to specify that a particular function contract assertion should only be evaluated if it is caller-facing, i.e., if the function it is specified on is the statically called function.

% TD: TODO: make it clear that it also applies to a fully qualified call

\emph{Motivation}:




This can be useful for assertions that express contracts applying to the interface, but not the implementation of a function.

\emph{Example}:

Consider a virtual function hierarchy where different implementations share a common interface
precondition:

% TD: TODO: can we come up with less "toy" examples?
\begin{codeblock}
struct Animal {
  virtual void eat(Food* foodPtr)
    pre (foodPtr && foodPtr->isEdible());
};

struct Cat : Animal {
  void eat(Food* foodPtr) override
    /* ... */;
}

struct Dog : Animal {
  void eat(Food* foodPtr) override
    /* ... */;
}
\end{codeblock}

Now, suppose we want to add a dummy implementation to the base class function \tcode{Animal::eat} --- perhaps for testing or prototyping purposes --- that does nothing and therefore works with any input value:

\begin{codeblock}
virtual void Animal::eat(Food* /* unused */) {
  // dummy implementation
}
\end{codeblock}

Complementary to property \propref{CalleeOnly}, we can add support for such \emph{interface contract assertions} (checked only if the function is the statically called function in a virtual function call) with an explicit syntactic marker, for example

\begin{codeblock}
struct Animal {
  virtual void eat(Food* foodPtr)
    pre interface (foodPtr && foodPtr->isEdible()) {
      // dummy implementation
    }
};
\end{codeblock}

The intention of the above code is that, in the case of invalid input, \tcode{Animal::eat} would raise a contract violation when called polymorphically but work fine when called directly via a fully qualified call:
\begin{codeblock}
int main {
  Animal testAnimal;
  testAnimal.eat(nullptr);  // contract violation
  testAnimal.Animal::eat(nullptr); // OK
};
\end{codeblock}

 and therefore is not subject to the same
preconditions as any of the overriding functions when called via a fully qualified call because such a
call can be made with any input value. The contract is therefore an interface contract, but not an
implementation contract.


\prop{CalleeOnly}{Check \tcode{pre} and \tcode{post} only when callee-facing}

\emph{Description}:

TODO

\emph{Motivation}:

For example, a virtual function intended to be overridden may also provide a concrete implementation — perhaps as a default, or perhaps as a utility to aid in implementation of overrides. In this case, the base class implementation might provide a set of preconditions and postconditions that should only be asserted when that base class implementation is called, never when a derived class implementation
is called (even if the latter is called through a pointer or reference to base)

\emph{Example}:

TODO

\section{Design space}
\label{designs}

TODO

\section{Evolution graph}
\label{evolution}

TODO

\section{Conformance matrix}
\label{matrix}

TODO

\section{Decision tree}
\label{tree}

TODO

\section{Conclusion}
\label{conclusion}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
%Thanks to Oliver Rosten for his review of the paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}

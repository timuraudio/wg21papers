\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Implicit contract assertions}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) 
\\ Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net})  
% TODO: Is Gasper still in?  \\ Ga\v sper A\v zman \small(\href{mailto:gasper.azman@gmail.com}{gasper.azman@gmail.com})   \\
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & P3100R2 \\
Date: &2025-05-19 \\
Project: & Programming Language C++ \\
Audience: & EWG
\end{tabular}

\begin{abstract}
This paper is a proposed additon to the core language UB white paper \cite{P3656R1}. We enumerate all explicitly specified cases of language UB in C++, group them into categories, and classify them along a number of relevant criteria. We discuss appropriate mitigation strategies for all identified cases of UB, and find that runtime checks are an appropriate strategy for the majority of cases. We propose to systematically introduce such runtime checks to the C++ Standard via \emph{implicit contract assertions}, building on the Contracts framework adopted for C++26. 
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{intro}

Eliminating or at least meaningfully reducing the amount of unbounded \emph{undefined behaviour} (UB) is a critically important objective for improving ``safety''\footnote{In this paper, we never use the term ``safety'' unqualified except in quotes because of the crucial importance to distinguish between different conflicting definitions of that term, such as functional safety and language safety.  See \cite{P3500R1} and \cite{P3578R0} for a discussion of those definitions and recommendations regarding usage of the term ``safety'' in the context of C++.}
and security for the future evolution of the C++ language. WG21 has been continuously working in that direction (for a recent status update, see \cite{Sutter2025} and references therein; for background, see \cite{Sutter2024} and references therein).

At the February 2025 WG21 meeting in Hagenberg, EWG agreed on a framework for a systematic
treatment of core language undefined behaviour in C++: the pursuit of a core language UB white paper in the C++26 timeframe, covering Erroneous Behaviour, Profiles, and Contracts. The current version of that white paper is \cite{P3656R1}, proposing the process and major work items. The proposed process calls for papers to be adopted into the white paper working draft via EWG approval. This is the first such paper.

Further, as major work items, \cite{P3656R1} proposes to enumerate and group all language UB in C++, identify tools to address them, and take a first pass at penciling in which tool to use for each UB case. The goal of this paper is to contribute to all of the above major work items.

In Section~\ref{ub}, we identify and enumerate all language UB explicitly specified in the C++ Standard. We then group all language UB into broad categories such as ``Arithmetic'' and ``Bounds''. We then classify cases of UB along several relevant criteria: whether they are locally diagnosable, how expensive that diagnosis is, and whether there is well-defined fallback behaviour for each case. Finally, we discuss appropriate mitigation strategies for all identified cases of UB, and find that runtime checking is an appropriate strategy for the large majority of cases.

In Section~\ref{design}, we focus on systematically introducing runtime checks for UB detection and mitigation. We propose to implement them via the introduction of \emph{implicit contract assertions} to C++, building on the basic Contracts framework adopted for C++26 via \cite{P2900R14}. We describe how such implicit contract assertions should be specified and how to apply them to all appropriate cases of language UB. For cases of UB where well-defined fallback behaviour exists, we discuss how specifying it allows the program to continue execution past a violated implicit contract assertion without UB. We conclude by proposing an escape hatch to mitigate the runtime cost of such fallback behaviour and avoid performance regressions.

In Section~\ref{wording}, we propose wording for the design in Section~\ref{design} for approval into the white paper.

The first revision (R0) of this paper was published in May 2024. Following informal discussions at the St. Louis meeting, the paper was revised (R1) and presented to SG21 at the Wroc{\l}aw meeting. SG21 voted \emph{unanimously} in favour of our direction for implicit contract assertions:
\vspace{2mm}
\begin{wgpoll}{{SG21 Poll 6, Wroc{\l}aw, 2024-11-22}}
We support the direction of P3100R1 and encourage the authors to come back with a fully specified proposal.
\wgpollresult{19}{6}{0}{0}{0}
Result: Consensus
\end{wgpoll}
\vspace{2mm}

The present revision (R2) is a complete rewrite of the paper that takes into account the above poll, the adoption of \cite{P2900R14} into the C++26 working paper, EWG's decision to publish the core language UB white paper, and the current state of that white paper \cite{P3656R1}.

\section{Enumerating and grouping core language UB}
\label{ub}

\subsection{Methodology and scope}

For this paper, we manually inspected all occurrences of the word ``undefined'' in the current C++ working paper \cite{N5008}. We then constructed a list of all cases of explicitly specified language UB. Our complete list, containing 83 cases of UB, can be found in Appendix~A of this paper. % TODO: add \ref to appendix

We compiled our list independently from another, ongoing effort by a group of WG21 members to enumerate cases of language UB directly in the C++ Standard document  \LaTeX{} source, based on work by Shafik Yaghmour (\cite{P1705R1}, \cite{P3075R0}) and following the process outlined in \cite{P3656R1}. Wherever possible, we use the same stable identifiers for our own list as the \LaTeX-based list does, although we identified a number of defects and omissions in Shafik's list as well as some other differences between the two lists. We are actively contributing to the \LaTeX-based effort to merge the two lists. 

Throughout this paper, we place stable identifiers for cases of UB between \{curly braces\} to visually distinguish them from stable identifiers for clauses in the C++ Standard, which we place between [square brackets].

Note that unlike the \LaTeX-based effort, our list excludes cases of IFNDR, as we focus on runtime checking as a mitigation strategy. While UB is fundamentally a runtime property of a particular program execution, and thus runtime checking is a natural mitigation approach, IFNDR typically represents link-time issues and is therefore out of scope for this paper.

Note further that we exclude \emph{library undefined behaviour}, as the natural mitigation approach for it is library hardening \cite{P3471R4}, which is likewise out of scope for this paper. We therefore only take into account UB is specified in the core language part of the C++ Standard (Clauses 1 --- 15). Further, we found one case of UB that is specified in the core language part of the C++ Standard but actually represents a precondition on C++ Standard library functions;\footnote{\textbf{[basic.start.term]/6}: If there is a use of a standard library object or function not permitted within signal handlers ([support.runtime]) that does not happen before ([intro.multithread]) completion of destruction of objects with static storage duration and execution of \tcode{std::atexit} registered functions ([support.start.term]), the program has undefined behavior.}
that case is also not considered in this paper.

\subsection{Categories}
\label{categories}

We found that all identified cases of language UB in the core language can be broadly classified into one of the following basic categories:
\begin{itemize}
\item \textbf{Initialisation} --- 1 case. Evaluating an expression that produces an indeterminate value.
\item \textbf{Bounds} --- 5 cases. Using a pointer in a way that fails to respect the range of the pointed-to object or array. Examples: incrementing a pointer beyond the past-the-end position; performing single-object delete on an operand obtained from an array-new expression;  dereferencing a pointer returned from a request for zero size.
\item \textbf{Type and Lifetime} --- 45 cases. Operations that access storage and/or use pointers or references to storage in an inappropriate way that is not already covered by Initialisation and Bounds. Examples: attempting to access a value of one type through  a pointer of a different, incompatible type; attempting to access the value of an object after its lifetime has ended. 
\item \textbf{Arithmetic} --- 9 cases. Executing an arithmetic operation whose operands fail to meet certain preconditions. Examples: division by zero; conversion of a value to a different arithmetic type that cannot represent that value. 
\item \textbf{Threading} --- 1 case. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from different threads where neither access happens-before the other.
\item \textbf{Sequencing} --- 1 case. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from the same thread where neither access is sequenced before the other.
\item \textbf{Assumptions} --- 1 case. Reaching an \tcode{[[assume]]} declaration whose operand would not evaluate to \tcode{true}.
\item \textbf{Control flow} --- 6 cases. Examples: flowing off the end of a function; re-entering the same declaration recursively when initialising a static variable.
\item \textbf{Replacement functions} --- 3 cases. Executing a user-defined replacement function (\tcode{operator new}/\tcode{delete}) that fails to meet the specified requirements. Examples: returning \tcode{null} from a user-defined placement \tcode{new}; throwing an exception from a user-defined \tcode{delete}.
\item \textbf{Coroutines} --- 2 cases. Misusing coroutine machinery. Destroying a coroutine that is not suspended; invoking a resumption member function for a coroutine that is not suspended.
\item \textbf{Compilation} --- 1 case. Infinite recursion during template instantiation.
\item \textbf{Preprocessor} --- 8 cases. Misusing preprocessor directives. Examples: \tcode{\#define}-ing a predefined macro name; passing an out-of-range integer to the \tcode{\#line} directive.
\end{itemize}

The categories Initialisation, Bounds, Type and Lifetime correspond to the common terms  ``initialisation safety'',  ``bounds safety'', ``type safety'',  and ``lifetime safety'', respectively, and collectively represent undefined behaviour that is commonly referred to with the umbrella term ``memory safety''. 

Note that we grouped ``type safety'' and ``lifetime safety'' into a single combined category Type and Lifetime. This is because it is often impossible to unambiguously categorise a particular case of UB into one or the other bucket as it concerns both. While there are cases of UB that are primarily caused by type aliasing, and others that are primarily caused by out-of-lifetime accesses, they form a spectrum, and many common operations in C++ (e.g., using a reference) rely on \emph{both} type and lifetime constraints to be satisfied. Note further that this combined category Type and Lifetime contains the majority (54\%) of all cases of UB that we identified.

The next two categories, Arithmeric and Threading, correspond to the common terms ``arithmetic safety'' and ``thread safety'', respectively.

The following category, Sequencing, contains just one case of UB: unsequenced operations such as \mbox{\tcode{i++ + ++i}}. It might seem surprising at first that we grouped threading and sequencing into two separate categories as their specification has a very similar same shape (except that one is inter-thread and the other is intra-thread). However, as we will see in Section~\ref{mitigation}, these two categories actually require very different approaches to mitigation.

The next category, Assumptions, also contains just one case of UB: Reaching an \tcode{[[assume]]} declaration whose operand would not evaluate to \tcode{true}. As we will see in Section~\ref{mitigation}, this case of UB is of a different nature than the others and warrants its own category.

The final five categories (Control flow, Replacement functions, Coroutines, Compilation failures, and Preprocessor) are much less frequently discussed in the current discourse around UB. Nevertheless, they represent UB that needs to be mitigated somehow.

\subsection{Security-related?}

\cite{P3656R1} asks the question which cases of UB are security-related. The paper suggests to have security experts tag which cases of UB have security impact always, never, or sometimes. As we are not security experts, we do not attempt to do this here. However, we will note that cases of UB commonly associated with security vulnerabilities (see for example the CWE list at \url{https://cwe.mitre.org/}) fall into the categories Initialisation, Bounds, Type and Lifetime. 

Other cases of UB, such as those in categories Arithmetic and Threading, are a common source of program defects, and those program defects do sizeable damage to existing software, so there is a lot of value in mitigating them, but to our knowledge they are not commonly exploited by malicious attackers.

\subsection{Locally diagnosable?}
\label{locally}

The second question that \cite{P3656R1} asks is which cases of UB are ``efficiently locally diagnosable''. Here, we break this down into two separate questions: which cases of UB are known to be locally diagnosable (this subsection), and what the cost of diagnosis is (next subsection).

Most cases in the security-critical Initialisation, Bounds, Type and Lifetime categories are \emph{not} locally diagnosable. 

From the Bounds category, 
\{expr.add.out.of.bounds\} 
and \{expr.add.sub.diff.pointers\} 
are partially locally diagnosable (only if the array bound is statically known).

From the Type and Lifetime category,
\{expr.static.cast.downcast.wrong.derived.type\},
\{expr.unary.dereference\},
\{conv.ptr.virtual.base\}, and
\{expr.dynamic.cast.lifetime\}
are partially locally diagnosable (for the null pointer case).
\{expr.mptr.oper.member.func.null\} is locally diagnosable because this case requires \emph{only} a null pointer check.
\{basic.align.object.alignment\} is locally diagnosable by checking the alignment of storage when creating an object at runtime.
\{expr.assign.overlap\} is locally diagnosable by checking the overlap of the two address ranges (the ranges are known because the address and \tcode{sizeof} are known at runtime for both the source and the destination object). \{class.abstract.pure.virtual\} is locally diagnosable by adding a runtime check to  the pure virtual function stub that the base class vtable points to.

All other cases of UB in the Initialisation, Bounds, Type and Lifetime categories require additional instrumentation to be diagnosable, of the kind that is implemented in sanitisers such as ASan and UBSan (see Section~\ref{cost} for details).

All cases of UB in the Arithmetic category are locally diagnosable as they are all cases of an arithmetic operation producing a value that is somehow inappropriate (mathematically invalid, not representable in the target type, etc.) and that value can be inspected at runtime.

UB in the Threading category (\{intro.races.data\}) is not locally diagnosable, but UB in the Sequencing category (\{intro.execution.unsequenced.modification\}) is. 

UB in the Assumption category is in principle locally diagnosable by evaluating the operand of the assumption and checking whether the resulting value, contextually converted to \tcode{bool}, equals \tcode{true}. However, if that evaluation has any side effects, the check could alter the observable state of the program. This means that even if the given assumption holds and there is no UB, the check itself might render the program invalid by altering its state. Therefore, this UB is only meaningfully diagnosable at all in any automated fashion if the operand has no side effects when evaluated. However, proving that the operand has no side effects is in general not possible either (Halting problem). 

Some cases of UB in the Control Flow category are locally diagnosable. \{stmt.return.flow.off\} and \{stmt.return.coroutine.flow.off\} can be diagnosed by inserting a check at the end of every function body that does not end with a \tcode{return} or \tcode{co_return} statement. \{dcl.attr.noreturn.eventually.returns\} can be diagnosed by inserting a check into every function declared \tcode{[[noreturn]]}

Some cases of UB in the Replacement Function category are partially or fully locally diagnosable. In particular, some of the constraints specified in \{basic.stc.alloc.dealloc.constraint\} and \{expr.new.non.allocating.null\} are locally diagnosable, while others are not. In particular, it is possible to check locally that a deallocation function does not exit via an exception, and that an allocation function does not return null. However, is not possible to check the other constraints (locally or at all).

All cases of UB in the Coroutine category are not locally diagnosable.

UB in the Compilation and Preprocessor categories is unique in that it does not actually represent run-time UB and therefore, run-time diagnosis does not make any sense. In particular, UB in the Compilation category (\{temp.inst.inf.recursion\}) is diagnosable at compile time, while UB in the Preprocessor category should be IFNDR instead (see also Section~\ref{mitigation}).

\subsection{Cost of diagnosis}
\label{cost}

To estimate the cost of diagnosis, it is useful to consider locally diagnosable and not locally diagnosable cases of UB separately. Note that in this paper, we study the theoretical, relative cost based on the current specification of the C++ language, however we do not measure the actual cost of diagnosis in real implementations and we do not present benchmarks; this is left for future studies.

\subsubsection{Locally diagnosable}

For locally diagnosable cases, there is always some kind of runtime check --- an \emph{assertion} --- that could be inserted by the implementation and then evaluated at runtime. The total cost of diagnosis is therefore equal to the cost of evaluating that check multiplied by the number of times the check needs to be evaluated.

The cheapest kind of check, and the only one that has no overhead for the happy case, is the ``fail if you get here'' check --- effectively a \tcode{pre}/\tcode{post}/\tcode{contract_assert(false)}. This kind of check is sufficient to diagnose \{class.abstract.pure.virtual\}, \{stmt.return.flow.off\}, \{stmt.return.coroutine.flow.off\}, and \{dcl.attr.noreturn.eventually.returns\}.

A slightly more expensive, but still cheap and optimiser-friendly kind of check is a null check, required to diagnose the null pointer cases  
(
\{expr.static.cast.downcast.wrong.derived.type\},
\{expr.unary.dereference\},
\{conv.ptr.virtual.base\}, and
\{expr.dynamic.cast.lifetime\}, 
\{expr.mptr.oper.member.func.null\}, and
\{expr.new.non.allocating.null\}
) as well as division by zero (\{expr.mul.div.by.zero\}).

Similarly cheap and optimiser-friendly are integer comparisons. These are  required for bounds checks with statically known array bounds
(
\{expr.add.out.of.bounds\},
\{expr.add.sub.diff.pointers\}
), as well as for \{expr.shift.neg.and.width\} and for \{intro.execution.unsequenced.modification\}.

Beyond this, there are a number of UB cases that can still be checked by a straightforward arithmetic expression, but with increasingly expensive expressions: \{expr.assign.overlap\} requires computing whether two integer ranges overlap, and  \{basic.align.object.alignment\} requires computing an integer modulo. 

At the expensive end of this spectrum lie runtime checks for which there is no corresponding C++ expression; instead the compiler would have to generate elaborate ``magic'' checks based on knowledge not available in the C++ abstract machine. In particular, this is the case for all arithmetic UB except \{expr.add.out.of.bounds\} and
\{expr.add.sub.diff.pointers\}. The compiler would have to validate the bit patterns of values of arithmetic types according to knowledge it has about how values of such types are represented on the given platform. Such checks can be done locally, but they can make operations involving built-in types and in particular floating-point types very slow.

In addition to the cost of the check itself, we need to consider the frequency with which these checks would need to be done. Checks that would need to happen once when a function is called or when a function returns are likely to be acceptable in most scenarios. Extensive checks for arithmetic UB will probably be acceptable in fewer scenarios because they would significantly slow down arithmetic operations, which are performance-sensitive in many contexts. On the extreme end, if we wanted to diagnose \{intro.execution.unsequenced.modification\} via a runtime check, the check in itself would not be very expensive but the compiler would have to put this check on every possible pair of unsequenced operations everywhere, which can lead to a combinatorial explosion for complex expressions.
% TODO: Is this last statement actually true? I'm not sure.
\subsubsection{Not locally diagnosable}

As we saw in Section~\ref{locally}, most cases of UB are not locally diagnosable but require additional instrumentation. To get an idea of the possible cost, it is useful to nail down exactly which additional properties that are not normally known from within the C++ abstract machine would need to be covered by such additional instrumentation. These properties would need to be tracked  at runtime throughout the \emph{entire} program and checked for \emph{every} runtime operation that may be affected.

To diagnose \emph{all} cases of UB in the memory safety categories Initialization, Bounds, Type and Lifetime, instrumentation would have to track all of the following properties:

\begin{itemize}
\item Provenance of all pointers and pointers-to-member;
\item For all storage, whether it has been allocated/freed;
\item For all storage, whether it has been initialised;
\item For all storage, whether it has been created such that it can hold implicit lifetime objects;
\item For all storage, the type of the object associated with it (if any), including whether it is \tcode{const} or \tcode{volatile};
\item For all objects, whether their lifetime has been started/ended;
\item For all objects, whether they are currently being constructed or destroyed;
\item The dynamic type of all \emph{non}-polymorphic objects of class type;
\item For all references, whether they have been initialized;
\item For all addresses that point to  functions, the type of the function.
\end{itemize}

To diagnose UB in the Threading category, instrumentation would have to track, for \emph{all} memory accesses, from which threads that memory is accessed and when these accesses synchronise with each other.

The non-locally diagnosable UB in the Control Flow category concerns operations that are not allowed during construction and destruction of objects with static or thread-local storage duration (\{basic.start.main.exit.during.destruction\} and \{basic.start.term.use.after.destruction\}). To diagnose these, instrumentation would have to insert guards tracking whether such objects are currently being constructed and destroyed.  

Finally, to diagnose UB in the Coroutine category, instrumentation would have to track the suspension state associated with every coroutine handle.

As we know from existing sanitisers, such instrumentation is expensive enough that it is almost never affordable in production. If we were to add instrumentation covering \emph{all} of the above, we would have removed vast swathes of UB from the language, but performance would worsen by (at least) an order of magnitude, unless special hardware-acceleration for these checks becomes available.
% TD: should we also talk about the fact that instrumentation can add new security vulnerabilities?

Given the overhead of the instrumentation itself, it is not particularly important how expensive the actual \emph{checks} would be (whether a specific pointer is valid at a specific time, etc.), because the performance penalty would be dominated by the instrumentation overhead. 

\subsection{Well-defined fallback behaviour}
\label{fallback}

If we want to turn UB into well-defined behaviour, a particularly relevant question is whether there actually exists any well-defined behaviour that the affected operation could exhibit instead of UB in the presence of a bug. Here, we call such well-defined behaviour \emph{fallback behaviour}.

We could also use the term \emph{erroneous behaviour} (EB), which is conceptually the same thing. However, since the approval of \cite{P2795R5} for C++26, EB has very specific semantics. Here, we are considering the wider concept of introducing new well-defined behaviour for error cases, rather than the exact semantics that EB has in C++26, therefore we use a different term for now.

For fallback behaviour to happen, the necessary instructions need to be laid down by the compiler. However, all cases of language UB (except those in categories Compilation and Preprocessor) are fundamentally \emph{not} diagnosable at compile time (see Section~\ref{locally}), i.e., whether or not the UB will occur depends on runtime parameters. Fallback behaviour can therefore \emph{not} depend on knowing that an error occurred. For non-locally diagnosable UB, fallback behaviour can also not depend on any extra instrumentation being present.

In this section, we systematically identify all cases of language UB for which such fallback behaviour exists. As we will see, even if such fallback behaviour exists, it is not necessarily cheap.

UB in the Initialization category (\{basic.indet.value\}) has a possible fallback behaviour for built-in types: return an erroneous value instead. For variables with automatic storage duration, this fallback behaviour is already part of C++26 as EB via \cite{P2795R5}, because for this case, the fallback behaviour is particularly cheap. The same fallback behaviour could also be employed for dynamically allocated variables, but at greater cost (see \cite{P2723R1} Section 6 for discussion). 

For user-defined types, such fallback behaviour does not exist in general. Even if we could zero out all the memory for user-defined types, that does not always produce a valid value for that type which can be accessed without UB (consider a user-defined type that relies on a member of pointer type never being null). Therefore, (\{basic.indet.value\} does not have fallback behaviour for the general case.

Practically \emph{none} of the UB in the categories Bounds, Type and Lifetime has fallback behaviour. The only exception is \{conv.lval.valid.representation\}: if the bits in the value representation of an object of built-in type are not valid for that type, the compiler could instead coerce the value into an erroneous value. For example, in the code example given in the C++ Standard,

\begin{codeblock}
bool f() {
  bool b = true;
  char c = 42;
  memcpy(&b, &c, 1);
  return b;         // undefined behavior if \tcode{42} is not a valid value representation for \tcode{bool}
}
\end{codeblock}

the UB could be replaced by well-defined behaviour by appropriately bit-masking every accessed \tcode{bool} value. Similar mitigations could be put in place for other built-in types since the space of allowed bit representations for values of those types, for the target platform in question, are known to the compiler. Obviously such mitigations would have a very significant performance overhead.

All UB in the Arithmetic category has the same possible fallback behaviour: if an arithmetic operation would produce an inappropriate value, it can be coerced into an erroneous value instead, at the cost of incurring significant overhead on common arithmetic operations.

It is possible to define fallback behaviour for UB in the Threading category (\{intro.races.data\}): we can make all primitive memory accesses implicitly atomic, as in the Java model. The overhead incurred by such a model will heavily depend on the memory model of the underlying hardware; on weakly-ordered platforms such as ARM it will be larger than on strongly-ordered platforms such as x86. Note that while such fallback behaviour is well-defined, it still leads to a pretty bad user experience as user-defined types with multiple members can end up with torn values.

The fallback behaviour for UB in the Sequencing category (\{intro.execution.unsequenced.modification\}) is much more straightforward: we can simply define that the unsequenced operations happen in some unspecified order. This fallback behaviour can still have performance overhead in the form of losing  optimisation opportunities, but it seems likely that such overhead will be manageable. This case may be a good candidate for a study actually implementing the mitigation and measuring the overhead.

The fallback behaviour for UB in the Assumption category (\{dcl.attr.assume.false\}) is trivial: just ignore the assumption, instead of optimising based on it. The performance overhead is limited to losing any optimisation opportunities from placing the assumption there. Of course, this mitigation makes the assumption itself completely useless. We will discuss this case in more detail in Section~\ref{assume}.

Finally, we can define partial fallback behaviour for two cases of UB in the Control Flow category  (\{stmt.return.flow.off\} and \{stmt.return.coroutine.flow.off\}): whenever the function or coroutine would return a value of built-in type, we can define that flowing off the end returns an erroneous value. This case is analogous to \{basic.indet.value\}; again, no fallback behaviour exists for user-defined return types in the general case.

For all other cases of UB (80\% of all cases) we cannot come up with any meaningful fallback behaviour.

\subsection{Mitigation strategies}
\label{mitigation}

In this section, we attempt, at a very high level, to systematically identify candidate mitigation strategies for all cases of language UB.

Arguably, the best mitigation strategy is to make the offending construct ill-formed. However, if we want to avoid breaking existing correct C++ code, we can only do this for cases where we can unambiguously identify at \emph{compile time} that UB will occur. This is the case only for one case of UB: 
\{temp.inst.inf.recursion\}. There is no good reason for this kind of error to be specified as UB; it should be specified as ill-formed instead.

Similarly, UB in the Preprocessor category should not be specified as UB either. We defer to \cite{P2843R2}, which proposes to specify all these cases as IFNDR instead, placing them outside of the scope of this paper.

There is one more case of UB which should not actually be considered UB: \{class.dtor.not.class.type\}. While the wording for this case says that ``if the object is not of the destructor's class type and not of a class derived from the destructor's class type (including when the destructor is invoked via a null pointer value), the program has undefined behaviour'', this is not a new case of UB but already falls out from the specification of other cases of UB elsewhere. This section should therefore be a non-normative note referring to those sections.

This leaves us with 73 cases of UB for which we need to identify candidate mitigation strategies. All of those cases represent \emph{run-time} UB that cannot be diagnosed at compile time. Therefore, one possible mitigation strategy for \emph{all} of those cases of UB is to insert \emph{run-time} checks.

Fundamentally, inserting run-time checks is possible for all those 73 cases of UB. However, as we saw in Section~\ref{locally}, the majority of those cases require expensive sanitiser-like instrumentation to perform the checks, and even for locally diagnosable cases of UB where additional instrumentation is not required, the checks themselves have a significant runtime overhead in almost all cases. Therefore, the checks need to be \emph{optional}: we need a mechanism to enable and disable each kind of check, and we cannot require an implementation to support all checks.

For example, a compiler may choose to support enabling runtime checks for arithmetic UB (they already do today for some cases, for example GCC offers the \tcode{-ftrapv} flag which enables checks for signed integer overflow) while not supporting any checks that require expensive instrumentation. On the other hand, a different compiler that comes with a suite of a sanitisers may choose to support some subset of those more expensive checks (and again, they already do today).

It is therefore useful to define such optional run-time checks for all those 73 cases of UB. These checks cost \emph{nothing} unless they are turned on, no implementation is actually \emph{required} to implement them, but specifying them in the Standard has a number of advantages. It allows us to assign standard names and categories to them; it allows for implementations of such run-time checks (including existing compiler options and sanitisers) to leverage a shared paradigm and shared terminology; and it brings those tools into the scope of the C++ Standard. % JMB: Are there other benefits we should be talking about here?

The natural way to introduce such optional run-time checks to C++ is to leverage the Contracts framework. All the necessary machinery and terminology for optional run-time checks --- called \emph{contract assertions} --- is already present in C++26, thanks to the foundation laid by \cite{P2900R14}. The only missing part is to introduce compiler-generated checks, i.e., \emph{implicit} contract assertions, in addition to the user-authored, i.e., \emph{explicit} contract assertions added by \cite{P2900R14}, and to hook those contract assertions into the same contract-checking and violation-handling machinery. We propose to do exactly this in Sections \ref{defineicas} --- \ref{applyicas}.

In addition to introducing implicit contract assertions, which let us \emph{diagnose} the UB, we can actually \emph{remove} the UB for those 17 cases of run-time UB where meaningful, well-defined fallback behaviour exists (see Section~\ref{fallback}). This can be accomplished by defining that the behaviour of the operation in question is that fallback behaviour; we propose to do this in Section~\ref{specifyfallback}.

However, practically all of this fallback behaviour comes with non-negligible --- and in some cases, even very large --- performance overhead. Therefore, to avoid unacceptable performance regressions in existing, correct C++ code, we \emph{must} offer an escape hatch that reverts to today's ``unsafe'' semantics. We propose such an escape hatch in Section~\ref{assume}.

For the 56 cases of run-time UB where meaningful, well-defined fallback behaviour does not exist (and therefore, continuation after an error has occurred is not possible), there are in principle only two known ways to give all those cases defined behaviour at runtime:
\begin{itemize}
\item to \emph{diagnose} them (and pay all the overhead for the associated run-time checks) and then terminate the program, or
\item to make the entire construct that could potentially exhibit the given case of UB ill-formed, and provide its functionality via a different, ``safer'' language feature.
\end{itemize}

The fundamental dilemma is that for many cases, neither alternative is acceptable. The instrumentation required to diagnose Bounds, Type, and Lifetime UB in the general case already exists, but its overhead is prohibitively large for most production scenarios. On the other hand, replacement by ``safer'' alternative features, such as replacing pointers and references with borrow checking as proposed in \cite{P3390R0}, is viable for newly written code but fundamentally not compatible with legacy code as it would make vast swathes of existing, \emph{correct} C++ ill-formed.

Such subsetting of the language is exactly where we see the role of Profiles. Enabling a particular profile would make the associated set of ``unsafe'' legacy features ill-formed. By leveraging profiles, the user can explicitly distinguish between newly written, ``safe'' parts of the code and legacy, ``unsafe'' parts, similarly to how this is done in languages like Rust, but with much greater granularity.

On the other hand, we do not believe that Profiles should intersect with runtime behaviour, as proposed by  \cite{P3081R1}. Enabling or disabling a profile should never change the runtime semantics of a C++ program. % JMB: please explain why not!! 
At most, a profile could reject the program if a certain run-time check required by the chosen ``safety'' level is not available (making Profiles a useful auditing tool), but a profile should never dictate whether a run-time check is enabled or disabled, or what should happen if that check fails. The reason is that, as we will see in Section~\ref{design} of this paper, all the required machinery for configuring run-time checks is already provided by the Contracts framework in a more consistent manner.

\section{Proposed design}
\label{design}

\subsection{Defining implicit contract assertions}
\label{defineicas}

In this section, we propose a framework for introducing run-time checks that guard against UB to C++. This framework builds on top of Contracts.

For C++26, we adopted an initial subset of Contracts functionality via \cite{P2900R14}. This initial subset contains three kinds of \emph{contract assertions}: \tcode{pre}, \tcode{post}, and \tcode{contract_assert}. Since these contract assertions are specified by the user with explicit syntax, in this paper we call them \emph{explicit} contract assertions. For example, the author of a vector-like class can add a precondition assertion to its subscript operator to guard against out-of-bounds access:

\begin{codeblock}
T& operator[] (size_t index)
  pre (index < size());
\end{codeblock}

The precondition assertion \tcode{pre (index < size())} can be evaluated with a checked assertion  (\emph{observe}, \emph{enforce}, or \emph{quick-enforce}), which allows the user to opt into defined behaviour --- program termination and/or a call to a contract-violation handler --- when their vector is accessed out-of-bounds. Further, the contract-violation handler can be replaced by the user, allowing them to query information about the error and implement their own mitigation strategy. Alternatively, the user can also opt out of the runtime check by choosing an unchecked evaluation semantic (\emph{ignore}) if their use case requires it. 

To implement run-time checks that guard against language UB, we propose to introduce \emph{implicit contract assertions}, which are added implicitly by the implementation, rather than explicitly by the user. In all other aspects, they work exactly the same as explicit contract assertions.

As an example, let us consider indexing into a plain array rather than a user-defined vector-like class. Let us further assume for the purpose of this example that the size \tcode{N} of this array is statically known:

\begin{codeblock}
int main() {
  int a[10] = { 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 };
  std::size_t i; 
  std::cin >> i;
  return a[i];
}
\end{codeblock}

In C++ today, the behaviour of this program is undefined if the value of \tcode{i} is not smaller than 10 (\{expr.add.out.of.bounds\}). However, instead of saying that out-of-bounds access into a plain array is undefined behaviour, we can say that access into a plain array has an \emph{implicit precondition assertion} that the index is not out-of-bounds. Then, the program behaves as-if the compiler had wrapped every raw array subscript operation for which it statically knows the array bound \tcode{N} into an inline function with a precondition assertion:

\begin{codeblock}
template <typename T, std::size_t N>
T& __index_into_array(T (&a)[N], std::size_t i)
pre (i < N) {
  return a[i];
}
\end{codeblock}

Other than being an implicit precondition assertion automatically generated by the compiler, \tcode{pre (i < N)} behaves the same as an explicit precondition assertion. That is, the user has the same choice of four evaluation semantics (\emph{ignore}, \emph{observe}, \emph{enforce}, or \emph{quick-enforce}) to specify the desired behaviour depending on the tradeoffs that are most suitable for their application, and when an out-of-bounds access is detected and the semantic is \emph{observe} or \emph{enforce}, the same contract-violation handler as for explicit contract assertions is called.

\subsection{Adjusting the library API}
\label{library}

To give the user a way to programmatically distinguish explicit and implicit contract assertions in the contract-violation handler, we propose to add a new enum value \tcode{implicit} to the enum \mbox{\tcode{assertion_kind}}. We simply append the new enumerator to the existing ones, which gives it the numerical value \tcode{4}, without attaching any particular meaning to that numerical value. Alternatively, we could define its numerical value to be \tcode{0}, as that value is not yet taken; however, we believe it is useful to not use \tcode{0} to retain the ability to detect the case where the enum has not been explicitly initialised with a valid value.\footnote{See also \cite{P3227R0}, which was adopted into \cite{P2900R14} and made the same argument for adding new enumerators to the enumeration \tcode{evaluation_semantic}.}

No other changes to the library API for contract-violation handling are necessary. In particular, unlike in the previous revision of this paper, and unlike in \cite{P3081R1} which adopted its library API from that earlier revision, we no longer propose to add new enumerators to the enumeration \mbox{\tcode{detection_mode}} to encode the category of error (Initialization, Bounds, and so on); instead, this can be accomplished more effectively via labels (see Section~\ref{idlabels}).

Further, we do not propose any changes to the specification of \tcode{comment()} and \tcode{location()}. C++26 non-normatively recommends that these functions return a textual representation of the expression that triggered the contract violation and the source location of the contract violation, respectively. While this is in principle possible for violations of implicit contract assertions, generating a textual representation for every possible expression that could lead to UB is likely to cause an unacceptable amount of code bloat. However, it is equally conforming to generate some other string that may help the user identify the problem, such as the diagnostic message already printed by existing sanitisers. It is also conforming to simply return an empty string and a default-constructed source location if no information is available, or if the information is not programmatically accessible in the contract-violation handler (for example,
because it located in a separate debug information file). 

Finally, we do not propose a separate contract-violation handler for implicit contract assertions. Having a single program-wide handler for all contract violations is a central aspect of the \cite{P2900R14} design. By standardising on a central reporting mechanism we clearly separate the responsibility for reporting from the responsibility of knowing all of the different mechanisms within a program by which a bug might be detected. For example, the user might want to hard-code a particular form of termination, or use a particular logger. Forcing them to repeat these things in multiple places is not good design. If the user  wishes to use a different handler for implicit contract assertions, they can always branch on the \tcode{assertion_kind} in the global contract-violation handler, and dispatch to a custom handler from there.

\subsection{Applying implicit contract assertions}
\label{applyicas}

Now that we have a framework in place for specifying what an implicit contract assertion is, and how it behaves, we can apply that specification to \emph{every} case of UB  that is --- at least in principle --- run-time checkable. As we saw in Section~\ref{mitigation}, this is true for 73 cases of UB --- the vast majority of UB in C++ today.

The required transformation is to change every occurrence of â€œif $A$ is not \tcode{true}, operation $X$ has undefined behaviour'' to ``Operation $X$ has an implicit precondition that $A$ is \tcode{true}; continuing execution past a violation of this precondition is undefined behaviour''.
% TD: JMB, I really think that instead of repeating this "continuing execution... is UB" wording 73 times, it would be better to find a term for it. I again propose "non-continuable precondition". I am happy to use something else if you have a better idea.

Note that we do not specify any restrictions on the evaluation semantics of any of these 73 newly introduced  implicit contract assertions; every implementation can choose for themselves which evaluation semantics to offer for which one, and which should be the default semantic. One possible choice is to simply say that all 73 always have the \emph{ignore} semantic, which makes all existing implementations of C++ already conforming with our proposal. Another possible choice is to say that  \emph{ignore} is the default, but other semantics are available. Yet another possible choice is to enable certain checks by default.

Since the choice of semantic is implementation-defined, implementations are expected to document which semantics they support for which implicit contract assertions, and which selection mechanism they offer. Once we have standard labels (see Section~\ref{ext}) for each case of UB guarded by an implicit contract assertion, implementations and users can refer to each case by name, giving us a shared, portable, universally-agreed standard framework with terminology for reasoning about run-time UB.

Many possible choices for the evaluation semantics of implicit contract assertions map directly to existing compiler and sanitiser options. For example, for signed integer overflow, the GCC flag \tcode{-ftrapw} is a conforming implementation of the \emph{quick-enforce} semantic; sanitisers like ASan and UBSan are conforming implementations of the \emph{enforce} semantic for those cases of UB that they identify. These tools can continue to work in the way they do; however, bringing them into the scope of the C++ Standard as proposed here has the benefit that they can now opt into using the unified standard framework.

Today, the integration between such tools and user code tends to be poor. For example, all clang sanitisers have a callback \tcode{__sanitizer_set_death_callback}, but this callback takes no arguments. It can be used to inform the user that the process is about to terminate, but it does not provide an API to programmatically query what happened or where. ASan has a slightly more sophisticated callback \tcode{__asan_set_error_report_callback} which takes a single argument of type \tcode{const char*}. This argument provides a string that contains the generated error report. With our proposal, all these tools can instead hook into the standard contract-violation handling API. This API provides not only a user callback in the form of a  program-wide replaceable contract-violation handler, but also programmatically accessible information about the defect via the  \mbox{\tcode{contract_violation}} object passed into the contract-violation handler. This more comprehensive API can serve as a uniform standard callback mechanism for sanitisers and other tools.

Further, coding guidelines can place restrictions on which evaluation semantics are permitted for which kinds of implicit contract assertions; our proposal provides the necessary standard terminology for this. For example, in a safety-critical context, a set of coding guidelines may prescribe that unchecked semantics may not be used for certain kinds of implicit contract assertions, and a matching profile could render non-conforming programs ill-formed. Thus, the usage of toolchains and compiler options that could lead to the program exhibiting a particular kind of UB could be prevented by construction. Of course, this requires alternatives to exist that offer checked semantics for the associated implicit contract assertions with acceptable performance tradeoffs.

Finally, applying implicit contract assertions throughout the language in the proposed fashion addresses another much-discussed issue: the fact that \emph{explicit} contract assertions in C++26, as specified in \cite{P2900R14}, can themselves have UB when checked, because explicit contract assertion predicates are boolean expressions and thus follow the usual rules for evaluating expressions in C++. This property has been repeatedly raised as a concern (see \cite{P2680R1}, \cite{P3173R0}, \cite{P3285R0}, and \cite{P3362R0}).

The approach suggested in those papers is to constrain explicit contract assertion predicates to expressions that can be statically proven to have no UB. However, this approach does not seem to be specifiable, implementable, or usable in practice (see  \cite{P3376R0}, \cite{P3386R0}, and \cite{P3499R1}) and has thus been rejected by WG21. What \emph{does} work is to specify a framework for mitigating UB across the entire language, as proposed here. Once we have this framework, it will then automatically also apply to the evaluation of explicit contract assertions.

\subsection{Specifying the fallback behaviour}
\label{specifyfallback}

The next part of our proposal is to introduce defined fallback behaviour for all 17 cases of language UB for which such fallback behaviour exists (see Section~\ref{fallback}). We accomplish this by modifying the specification of each affected operation such that, if the condition occurs that would have previously made the behaviour of the operation undefined, the behaviour is instead the defined fallback behaviour.

The required transformation is to change every occurrence of â€œif $A$ is not \tcode{true}, operation $X$ has undefined behaviour'' to ``Operation $X$ has an implicit precondition that $A$ is \tcode{true}; if this precondition is violated, the behaviour is \emph{<fallback behaviour>}''.

As discussed in Section~\ref{fallback}, if we make this change and do nothing further, it would introduce significant --- and in many cases, unacceptable --- performance regressions to existing code. Therefore, we must offer an escape hatch that reverts to today's semantics where a violation of the implicit precondition leads to undefined behaviour.

\subsection{Providing an escape hatch}
\label{assume}

For indeterminate values, \cite{P2795R5} introduced a specific escape hatch: the \tcode{[[indeterminate]]} attribute. However, in many cases such a specific, syntactic escape hatch is simply not viable. Consider e.g. arbitrary arithmetic expressions where some integer operations may overflow --- where would we place a syntactic escape hatch? Instead, we need a \emph{generic} escape hatch that works for all cases and does not rely on syntax.

Further, this escape hatch needs to be flexible enough that implementations can choose whether or not it should be engaged by default. Engaging the escape hatch by default seems counter-intuitive, because doing so would fail to provide a ``safe default'', however in some cases the fallback behaviour will simply be infeasible to enable. It is nevertheless useful to notionally define it.

Considering all of the above, it becomes evident that such a generic, non-syntactic escape hatch to revert back to today's semantics --- a violation of the implicit precondition leads to undefined behaviour --- is nothing other than a new, fifth evaluation semantic in addition to the four existing ones (\emph{ignore}, \emph{observe}, \emph{enforce}, \emph{quick-enforce}) that can be applied to the evaluation of the affected implicit contract assertions. This evaluation semantic is called the \emph{assume} semantic.

Just like the \emph{ignore} semantic, the \emph{assume} semantic is a \emph{non-checking} semantic, i.e., its predicate is not evaluated. Further, just like with the \emph{ignore} semantic, if the predicate would  evaluate to \tcode{true} at the point where the contract assertion appears, it simply has no effect (i.e., the program behaves exactly as if it was not there. However, unlike the \emph{ignore} semantic, if the predicate would \emph{not} evaluate to \tcode{true}, the behaviour is undefined.

With this definition, we can map all five evaluation semantics for implicit contract assertions that guard UB to concrete behaviours, for example for signed integer overflow as follows:
\begin{itemize}
\item The GCC compiler option \tcode{-ftrapv}, which aborts the program on signed integer overflow, is a conforming implementation of the \emph{quick_enforce} semantic;
\item A sanitiser which detects signed integer overflow and prints a diagnostic is a conforming
implementation of the \emph{enforce} or \emph{observe} semantic (depending on whether the
process is terminated or execution continues after printing the diagnostic);
\item The GCC compiler option \tcode{-fwrapv}, which implements signed integer addition using wrap around using twos-complement representation, is a conforming implementation of the \emph{ignore} semantic, which silently executes the safe fallback behaviour;
\item The default behaviour in C++ today, which is to assume that signed integer addition can never overflow, and optimise based on this assumption when the appropriate optimisation flags are selected by the user, is a conforming implementation of the \emph{assume} semantic.
\end{itemize}
Just like with all other evaluation semantics, the mechanism by which the \emph{assume} semantic is selected is implementation-defined and will in practice be accomplished by vendor-provided compiler flags. In addition, labels (see Section~\ref{semantic}) will provide the ability to choose and constrain the evaluation semantic in code with arbitrary granularity.

Importantly, in light of the sustained opposition to allowing the \emph{assume} semantic for explicit contract assertions,\footnote{This opposition is the reason why  no such semantic was included in \cite{P2900R14}. The presence of the \emph{assume} semantic in the C++2a Contracts proposal \cite{P0542R5} contributed to that proposal being removed from the C++20 Working Draft.}, we propose that the \emph{assume} semantic is only allowed for \emph{implicit} contract assertions. \emph{Explicit} contract assertions (\tcode{pre}, \tcode{post}, and \tcode{contract_assert}) may \emph{not} be evaluated with the \emph{assume} semantic.

This restriction is important because for explicit contract assertions, the \emph{assume} semantic  has the potential to introduce undefined behaviour to an otherwise correct program if the user wrote a buggy contract predicate. On the other hand, for implicit contract assertions, this risk does not exist as they are generated by the compiler; for error cases that cause UB, the \emph{assume} semantic is merely a name for the behaviour that those error cases already have in C++ today.

Once we get labels, as proposed in \cite{P3400R1}, it will become possible to introduce an explicit label that would allow the \emph{assume} semantic to apply to an explicit contract assertion as well. For example, the limiter example from \cite{P1774R8} could be written as follows:
\begin{codeblock}
void limiter(float* data, size_t size)
  pre<may_be_assumed>(size > 0);
  pre<may_be_assumed>(size % 32 == 0);
\end{codeblock}
For explicit contract assertions, the \emph{assume} semantic would only ever be allowed when the \mbox{\tcode{may_be_assumed}} label is present. Thus, contract assertions would not be any less safe than they are in C++26. Such a label would be a vast improvement over \tcode{[[assume]]} as it would allow for \emph{checkable} assumptions (see \cite{P2064R0} for context). Once we are at that stage, we will have achieved the integration between assertions and assumptions that we failed to achieve in the C++20 cycle, and the \tcode{[[assume]]} attribute --- a temporary solution that was introduced instead --- can safely be deprecated.

\section{Future extensions}
\label{ext}

We already briefly touched upon labels in the previous section. In this section, we explore other extensions that rely on labels as proposed in \cite{P3400R1} and provide important additional functionality for implicit contract assertions that is not proposed in this paper.

\subsection{Identifying the UB category}
\label{idlabels}

\cite{P3400R1} proposes the addition of \emph{identification labels} to contract assertions. These identification labels can be used to identify groups of contract assertions by name. For explicit contract assertions, the user would have to introduce these identification labels manually; however, for implicit contract assertions, we can define and assign such identification labels directly in the C++ Standard (see \cite{P3400R1} Section 2.2.8). This would make it possible to programmatically identify, in the contract-violation handler, whether the violated implicit contract assertion  is related to an out-of-bounds issue, an arithmetic issue, and so forth, for example:

\begin{codeblock}
TODO JMB PLEASE PROVIDE CODE EXAMPLE
\end{codeblock}

Notably, the \cite{P3400R1} approach has an important advantage over using the \tcode{detection_mode} enum, as proposed in \cite{P3081R1} and in earlier versions of this paper: a single implicit contract assertion can belong to multiple groups. This could be useful for cases of UB like those identified in Section~\ref{categories} which are simultaneously type and lifetime issues.

\subsection{Granular control of the evaluation semantic}
\label{semantic}

Another important feature enabled by labels is the possibility to control and constrain the evaluation semantic in code. This possibility also extends to implicit contract assertions (see \cite{P3400R1} Section 2.2.8). Any possible label such as ``always enforce'', ``never enforce'', etc., can be applied to any group of implicit contract assertions at any granularity --- per file, per namespace, per function, per block, etc.:

\begin{codeblock}
TODO JMB PLEASE PROVIDE CODE EXAMPLE
\end{codeblock}

TODO // JMB please write a few sentences here why this is better than doing it with profiles and profile attributes!! //

\section{Proposed wording}
\label{wording}

TODO

\addcontentsline{toc}{section}{Appendix: UB list}
\section*{Appendix: UB list}

TODO
%Note: this will contain some rendering of the big spreadsheet.

\section*{Document history}
\begin{itemize}
\item \textbf{R0}, 2023-03-08: Initial version.
\item \textbf{R1}, 2024-10-16: Complete rewrite after the WG21 meeting in St. Louis.
\item \textbf{R2}, 2025-05-19: Complete rewrite after the WG21 meeting in Hagenberg.
\end{itemize}

\section*{Acknowledgements}

We wish to thank Herb Sutter, Oliver Rosten, Andrzej Krzemie\' nski, and Roger Orr for their helpful feedback on a previous revision of this paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}


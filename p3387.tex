\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on coroutines}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
// Coauthors? //
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3327R0 \\
Date: &2024-09-09 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we explore the design space for an extension to the Contracts MVP proposal \cite{P2900R8} that allows placing function contract assertions --- \tcode{pre} and 
\tcode{post} --- on coroutines. We analyse the available solution space, formulate our design goals, and propose the solution that best satisfies those design goals, taking into account the fundamental design principles behind both Contracts and coroutines.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Motivation}
\label{intro}

The current Contracts MVP proposal \cite{P2900R8} makes it ill-formed for a function \tcode{f} to have function contract assertions --- \tcode{pre} and \tcode{post} --- if \tcode{f} is a coroutine; it merely allows \tcode{contract_assert} inside the body of \tcode{f}. This is in many ways unfortunate. As \cite{P3173R0} points out, coroutines are a foundational facility of modern C++ and thus a Contracts proposal should adequately address uses of contract assertions in combination with coroutines.

It has been argued that coroutines are complex and that therefore, their interaction with Contracts is not straightforward and supporting \tcode{pre} and \tcode{post} on coroutines should be delayed post-MVP. However, hampering the ability to apply \tcode{pre} and \tcode{post} to coroutines does not solve the confusion. We should not give users more reasons to avoid coroutines.

The fundamental design principle of coroutines is that whether \tcode{f} is a coroutine is an implementation detail that is not known at the declaration of \tcode{f}, or at a call to \tcode{f}. This design principle should be applied to Contracts as well. If a Contracts proposal introduces new ways in which coroutines are different from other functions --- such as disallowing the usage of \tcode{pre} and \tcode{post} on them --- then such a design is in contradiction with how coroutines are designed and specified in C++ today. Ideally, coroutines should work exactly the same as other functions with respect to Contracts.

As \cite{P3251R0} points out, there is a workaround to achieve such behaviour with \cite{P2900R8}. Instead of applying function contract assertions on the coroutine \tcode{f} directly, we can wrap \tcode{f} into a non-coroutine wrapper \tcode{g}, and apply the function contract assertions to \tcode{g}:
\begin{codeblock}
auto g()  // not a coroutine
pre (/*...*/) 
post (r: /*...*/) { 
  return f();  // a coroutine
} 
\end{codeblock}
%JMB: Note that this alternate approach avoids many of the complexities:
%  There *is* a function body to which pre and post apply just as normal
%  The user must make the choice of copying or moving parameters that might be used in postconditions
%  There is no question as to whether pre or post apply to the original or copies of parameters - only the originals are visible to this function.  (Actually, only parameters that will be forwarded to initialize the pre-copy parameters will be available in this function)

%TD: That all makes sense but is a bit too early to explain here as we haven't even mentioned the parameter weirdness at this point. I am mentioning all this at the end of section 4.3 now, please have a look, is that OK?

%JMB: I still think that it should be menionted that this workaround is fundamentally different from what happens when you don't introduce this wrapping layer.  C++ doesn't have perfect forwrding, and coroutines make it even less perfect.

% TD: I get what you're saying, but don't know how to do that here, as the things you refer to have not yet been explained at this point. I have softened the language a bit, removed the notion that the workaround is "straightforward" and the comment that we can provide "the same functionality". Is this enough? Or, if you want me to be more specific at this point of the paper, can you provide the wording?

%JMB: I've made an attempt to add something the the end to clarify that this isn't straightforward.

Given the existence of this workaround, it seems reasonable to provide the ability to place \tcode{pre} and \tcode{post} on \tcode{f} directly.  On the other hand, as with any other attempt to wrap a function in C++, once additional parameters are being passed there are subtle yet important differences in behavior that must be considered.

\section{Prior work}

The C++2a Contracts proposal \cite{P0542R5} did not take coroutines into account because they were not yet part of the C++ Standard at the time.

Post-C++20, SG21 decided to not support \tcode{pre} and \tcode{post} in the Contracts MVP proposal ``until we have a more complete picture of what we intend to provide'' (see \cite{P2932R3}).

Later, \cite{P2957R0} proposed to add support for \tcode{pre} and \tcode{post} on coroutines, with semantics analogous to non-coroutine functions (see Section \ref{impldetail}). This paper was seen by SG21 in Kona (November 2022) and rejected due to uncertainty about the semantics of referring to parameters in \tcode{post}, which might be moved into the coroutine frame and become moved-from values even if the parameter is \tcode{const} (see Section \ref{paramsinpost}).

In \cite{P3173R0}, seen by EWG in Tokyo (February 2023), support for coroutines was named by a major compiler vendor as one of the criteria for the viability of a Contracts MVP proposal.

Subsequently, it was proposed in \cite{P2957R1} and in \cite{P3251R0} that we should allow \tcode{pre} on coroutines, but not \tcode{post}, to avoid the known problem regarding moved-from parameters in \tcode{post}. Neither paper has yet been seen by SG21 at the time of writing.

This paper builds on \cite{P2957R1} and \cite{P3251R0}, and has significant overlap with those papers, but approaches the problem with a design goal-driven approach and seeks to provide a more exhaustive analysis of the available solution space.

\section{The basics}

\subsection{Coroutine-ness is an implementation detail}
\label{impldetail}

As we established in Section \ref{intro}, the fundamental design principle behind C++ coroutines, which any Contracts proposal must respect, is that the coroutine-ness of a function \tcode{f} is an implementation detail.

For example, assuming that \tcode{generator<T>} is a conforming promise type (\href{https://eel.is/c++draft/dcl.fct.def.coroutine}{[dcl.fct.def.coroutine]}), given a function declaration 
\begin{codeblock}
generator<int> iota(int n); 
\end{codeblock}
it is impossible to tell if \tcode{iota} is a coroutine implemented as follows:
\begin{codeblock}
generator<int> iota(int n) {
  while (true)
    co_yield n++;
}
\end{codeblock}
or whether \tcode{iota} is a non-coroutine function wrapping a coroutine as follows:
\begin{codeblock}
generator<int> iota(int n) {
  return iota_impl(n);
}
\end{codeblock}
or whether no coroutines are involved at all, and \tcode{iota} is a non-coroutine function that manually initialises an object of type \tcode{generator<int>} and returns it, without using any of the C++ coroutine machinery. Ideally, \tcode{pre} and \tcode{post} should behave the same in all of the above cases.

\subsection{The ramp function}

It follows directly from the above design principle that when \tcode{pre} and \tcode{post} are applied to the declaration of a coroutine, then the function they apply to is the so-called \emph{ramp function} creating the coroutine frame, whose function body is defined by ([\href{https://eel.is/c++draft/dcl.fct.def.coroutine#5}{dcl.fct.def.coroutine.5}]), and \emph{not} to the coroutine body, i.e. the function body that the user wrote. Therefore, \tcode{pre} on a coroutine is an assertion on the parameters passed into the ramp function, \emph{before} the coroutine frame is constructed, and the state of the program at that point; \tcode{post} on a coroutine is an assertion on the object that the ramp function returns, and the state of the program when control is returned from the ramp function to the caller, regardless of what happens in the coroutine frame.

This might seem confusing if one is not familiar with how coroutines work. According to one of the design principles of the Contracts MVP (\cite{P2900R8}, Section 3.1, Design Principle 11), \tcode{pre} and \tcode{post} sit at the boundary of the interface and the implementation of a function, and serve both  the caller and the callee. However, for coroutines, there is a certain disconnect between the interface (the function declaration) and the implementation (the function body that the user wrote) that does not exist for non-coroutine functions: the function body may run long before or long after the postconditions that apply to the declaration are checked, and even on another thread. However, it is important to realise that this disconnect is a fundamental property of coroutines in C++ and is not changed or made any worse by adding Contracts.

In the framework of the Contracts MVP, \tcode{pre} and \tcode{post} on a coroutine declaration are therefore \emph{caller-facing} contract assertions (see \cite{P2900R8}, Section 3.5.1). The \emph{callee-facing} function contract assertions for a coroutine would be preconditions and postconditions on the entry and exit points of the coroutine body (i.e. the resume and suspend points). Supporting these will need a novel feature, but such a feature is not needed for consistency between coroutines and non-coroutine functions and is therefore a pure extension that can be deferred post-MVP (to our knowledge, so far nobody has claimed that such an extension must be included in the MVP). In the meantime, expressing contracts on the coroutine's resume and suspend points can be emulated with \tcode{contract_assert} or, as suggested in \cite{P3251R0}, be placed on the relevant functions of the promise type rather than in the coroutine itself.

\subsection{Point of evaluation}

As pointed out in \cite{P2957R1}, the way in which the point of evaluation of \tcode{pre} and \tcode{post} is defined in \cite{P2900R8} needs some slight clarifications for coroutines, however, according to the mental model described in the previous section, this does not conceptually change the point of evaluation itself or compromise the equivalence between coroutines and non-coroutine functions.

\cite{P2900R8} specifies that the precondition assertions are evaluated ``immediately after function parameters are initialised and before entering the function body''. For a coroutine, we need to clarify that by ``function body'', we do not mean the coroutine body that the user wrote, but the body of the ramp function that the compiler generated. This means that the precondition assertions are evaluated before any of the other things that happen in the ramp function: creating a copy of the parameters, allocating the coroutine frame, initialising the promise object, etc.

\cite{P2900R8} further specifies that the postcondition assertions are evaluated ``after the return value has been initialised and local automatic variables have been destroyed but prior to the destruction of function parameters''. Again, we need to clarify that this specification should be applied to the body of the ramp function and not the coroutine body, meaning that the ``return value'' is that of the ramp function (and not any values yielded by the coroutine), and its type is the declared return type of the coroutine; and likewise, the ``local variables'' are those created by the ramp function (and \emph{not} the local variables in the coroutine body).

\subsection{The problem: referring to parameters in \tcode{post}}
\label{paramsinpost}

Unfortunately, there is one difference between coroutines and non-coroutine functions that is unobservable caller-side today, but would be made observable in the predicate of a \tcode{post} that applies to a coroutine. This difference is what makes a proposal to allow function contract assertions on coroutines non-trivial, and has prevented the adoption of such a feature until now.

When the ramp function is invoked, after initialising the function parameters (and checking the precondition assertions, if we allow this), a copy of each parameter is created in the coroutine frame, and the value of each parameter is moved into that copy ([\href{https://eel.is/c++draft/dcl.fct.def.coroutine#13}{dcl.fct.def.coroutine.13}]), leaving the original parameter object in a moved-from state. This is necessary to make the parameters accessible in the coroutine frame, whose lifetime can extend far beyond the ramp function returning. Notably, this moving-from a parameter happens even if that parameter is \tcode{const}: the ramp function removes the top-level \tcode{const} from the parameter, as if by performing a \tcode{const_cast}, and then modifies that parameter by using it to move-construct the copy. In a non-coroutine function, this cannot happen, as attempting to move from a \tcode{const} object would be undefined behaviour. However, in a coroutine, the parameter object is not considered \tcode{const} in the ramp function even if declared as such ([\href{https://eel.is/c++draft/dcl.fct.def.coroutine#note-2}{dcl.fct.def.coroutine.13 Note 2}]).

This specification seems strange, but does not cause issues in C++ today because the moved-from parameter values in a coroutine are not exposed or made accessible to the user in any way. However, this would change if we allowed referring to a function parameter in \tcode{post}. Since \tcode{post} will be evaluated after the move-from has happened, an \emph{id-expression} that refers to a parameter in the predicate of \tcode{post} would now refer to a moved-from value, even if the parameter object is \tcode{const}, making an implementation detail of C++ coroutines observable to the user in a potentially unexpected and undesirable way.

\section {Discussion}

\subsection{The solution space}
There are different possible solutions to the moved-from parameter problem. In order from least to most consistent with the principle that coroutine-ness should be an implementation detail, these are:
\begin{enumerate}
\item Do not allow \tcode{pre} or \tcode{post} on coroutines at all (status quo in \cite{P2900R8});
\item Allow \tcode{pre} on coroutines, but not \tcode{post} (proposed in \cite{P2957R1} and in \cite{P3251R0});
\item Allow \tcode{post} on coroutines, but do not allow referring to parameters;
\item Allow referring to parameters in \tcode{post}; an \emph{id-expression} naming a parameter refers to the copy made for the coroutine frame;
\item Allow referring to parameters in \tcode{post}; an \emph{id-expression} naming a parameter refers to the original object, and:
\begin{enumerate}[label=\alph*.,ref=\theenumi\alph*]
        \item copy-construct instead of move-construct the copy made for the coroutine frame;
        \item make it ill-formed to refer to a parameter whose type has a non-trivial move constructor (i.e., the parameter can have a moved-from value);
        \item do not add any special provision, meaning that the \emph{id-expression} may refer to a moved-from value, even if the parameter type is \tcode{const}.
\end{enumerate}
\end{enumerate}

If our only concern was to optimise for the design goal that coroutine-ness is an implementation detail, it seems that 5c would be the correct solution. However, in order to make the proposed Contracts facility as user-friendly as possible, we might wish to consider other design goals as well, making the choice of the correct solution a non-trivial task. We discuss these other design goals in the following section.

\subsection{Design goals}

\subsubsection{The Contracts Prime Directive}

The most fundamendal design principle of the Contracts MVP, the so-called Contracts Prime Directive (\cite{P2900R8}, Section 3.1, Principle 1) states that adding \tcode{pre} or \tcode{post} to an existing program should not alter the correctness of that program, as this would undermine the purpose of contract assertions --- instead of checking the correctness of the program you wrote, they would check the correctness of some other program, potentially leading to so-called ``Heisenbugs'' as well as other problems.

A corollary of this fundamental principle is that adding \tcode{pre} or \tcode{post} to an existing program should not change the compile-time or run-time semantics of that program (see \cite{P2900R8}, Section 3.1, Principles 2 and 3).

Solution 4 violates this principle. While making parameters in \tcode{post} refer to the object in the coroutine frame seems implementable, it will require changes to the semantics of the coroutine, such as extending its lifetime (otherwise, the coroutine frame may be destroyed during initial suspend, i.e. before \tcode{post} is checked, and the parameter object along with it). Without making changes to the coroutine semantics, there would be no point where the parameter copies and the return value necessarily exist at the same time, and therefore no point at which \tcode{post} could be checked.

Solution 5a violates this principle as well, as adding \tcode{post} to a coroutine would incur an additional copy, even if the \emph{ignore} semantic is used and predicate is never checked. For the same reason, we made it ill-formed in \cite{P2900R8} for a contract assertion to trigger an implicit lambda capture.

\subsubsection{Do not refer to moved-from \tcode{const} parameters}

On the one hand, exposing the moved-from parameter value in \tcode{post} is the ``honest'' choice, as it simply reflects what is going on under the hood. On the other hand, it exposes an implementation detail of C++ coroutines to the caller that is currently not being exposed. This not only violates the principle that the coroutine-ness of a function should be an implementation detail, but is also likely to be surprising to the user, and can lead to unexpected behaviour and unintended bugs that will be very difficult to diagnose.

Furthermore, it does not seem useful to be able to write a postcondition on a parameter that can be moved-from, as we cannot reason about the meaning of such a postcondition, in the same way in which we cannot reason about the meaning of a postcondition on a parameter that is not \tcode{const} (which \cite{P2900R8} makes ill-formed for that reason).

It is therefore a reasonable design goal to avoid this scenario. Solution 5c directly violates this design goal.
%JMB: 5b violates it too, and relies on what is often not considered a semantic change in a type to decide that it "works" anyway.   Even if there's no move constructor, you are still unquestionably using an object that has been moved-from as a non-const xvalue to initialize another object, and not consistently applying the rule that we don't we the value of such objects is confusing.

%TD: I don't agree with this characterisation. If your type doesn't have a non-trivial move constructor, there is literally no way to "move-from" an object of this type, as this operation does not exist for this type, so moved-from values cannot exist either. Note that `int i = 42; int j = std::move(i);` is exactly equivalent to `int i = 42; int j = i;` and it is guaranteed by the Standard that it is exactly equivalent. Same for non-trivial types that have a user-provided copy constructor but no move constructor: the Standard guarantees that when you try to move-from, what actually happens is a normal copy. So I don't see how 5b violates this design goal, and I don't see how your statement "you are still unquestionably using an object that has been moved-from" can be true for those types.

%JMB: The fact that a trivially moveable thign leaves its moved-from object in an empty state is just the result of an optimization --- it's still moved-from.   `int` might promise not to change the source when doing a move, but my type that happens to be trivially movable today shouldn't ever be beholden to that promise going forward just becuase a memcpy suffices today.
% If I write this code:
%   void f(T t)
%   {
%       g(std::move(t));
%       h(std::move(t));
%   }
% Your response should be "that's broken", not "that's OK if T happens to be trivially movable".
%
% THis is the same thing.

% TD: I think this is a purely philosophical debate. My reply to your code above is indeed "that's OK if T happens to be trivially movable" because that's just what falls out of the current specification. I suggest we don't spend more time on this here as whether or not 5b gets a green mark or a red cross in this row is pretty much irrelevant, because we are already discarding 5b as a viable solution due to it violating the "do not facilitate remote code breakage" design goal. Are you OK with leaving this discussion be for now, in the interest of getting the paper out sooner?

% JMB: I still think we need to mention something --- especially since solution 5b isn't just trivial moves but also moves that degrade to copies (whichi might modify mutable members of the source).  How about something like "Solution 5b violates this goal in principle, although it limits use of move operations to those types where the source is known to be unmodified or which are totally move-unaware."

\subsubsection{Do not introduce additional inconsistencies between \tcode{pre} and \tcode{post}}

A well-designed Contracts feature will naturally compose with other C++ language features, including coroutines. We should avoid adding more complexity to make Contracts and coroutines work together. In particular, we should avoid introducing new inconsistencies between \tcode{pre} and \tcode{post} that do not exist in the current design, as that could be surprising to the user and hinder effective usage and wider adoption of Contracts.

Arguably, Solution 2 violates this design goal, because it would introduce the notion that not all kinds of function contract assertions can apply to all functions. Being able to apply \tcode{pre}, but not \tcode{post} to a function is arguably surprising.

Solution 4 also violates this design goal. Currently, if a function has a \tcode{pre} and a \tcode{post}, and their predicates odr-use the same function parameter, then the corresponding \emph{id-expression} will refer to the same parameter object with the same address. Solution 5c breaks this symmetry, which can lead to unexpected consequences.

Finally, Solution 5c violates this design goal because an \emph{id-expression} referring to the same parameter might see different values in \tcode{pre} and \tcode{post}, respectively, even if the parameter in question is \tcode{const}. This is highly unintuitive and cannot happen with \tcode{pre} and \tcode{post} as specified in \cite{P2900R8} today.

Note that Solution 3 does not violate this design goal because it does not introduce a new inconsistency. One of the necessary limitations of \tcode{post}, compared to \tcode{pre}, is that it is ill-formed to refer to non-reference parameters in the predicate of \tcode{post} that might have been modified in the function body, as that would make it impossible for the caller to reason about the postcondition. In \cite{P2900R8}, this applies to non-\tcode{const} parameters. Solution 3 extends this to \tcode{const} parameters in a coroutine, as those parameters may be moved from and are thus effectively never \tcode{const}, even if declared as such. Solution 3 therefore applies the existing Contracts design to coroutines in a consistent way.

\subsubsection{Do not facilitate remote code breakage}

Our design for how Contracts and coroutines work together should not facilitate situations that can lead to unintended, remote code breakage. Solution 5b violates this design goal because it would create a new dependency between the trivial movability of a type and the ability to use it as a function parameter.

For example, if the user adds a move constructor to a type that previously only had a copy constructor (something that we explicitly encourage people to do to modernise their code!), this will break clients who happen to use this type as a coroutine parameter. Likewise, if there is a struct with an \tcode{int} and a \tcode{float} data member, and the user adds a \tcode{std::string} data member, this will also break clients who happen to use this type as a coroutine parameter. Such breakage would happen for highly non-obvious reasons, does not have a good workaround (at least not until we get postcondition captures as a post-MVP extensions), and therefore seems user-hostile.

\subsubsection{Support caller-side checking of \tcode{post}}

The Contracts MVP has been designed from the start to accommodate a wide range of implementation strategies and usage scenarios. In particular, it allows implementations to check precondition and postcondition assertions caller-side and/or callee-side, and enables the two translation units involved to make the decision on contract evaluation semantics independently.

In particular, if one has deployed a pre-built library with all contracts ignored, and the user of that pre-built library wishes to verify that it is working correctly when used from particular other translation units, enabling caller-side checking of that library's precondition and postcondition assertions can be very useful, for example to validate a new version of such a library before integrating it into the shipping product. In general, any time we cross the boundary between translation units, it is very helpful (and currently intentionally supported by \cite{P2900R8}) to have both sides of that boundary be able to enable contract checks.

However, in order to be able to enable caller-side postcondition checks, the predicate of \tcode{post} cannot depend on anything that is not accessible caller-side and only known callee-side. For coroutines, it means that \tcode{post} cannot refer to the coroutine frame copies of parameter objects. Solution 4 is therefore not compatible with caller-side checking of \tcode{post}.


\subsection{Proposed solution}

Having formulated our design goals, we can now construct a decision matrix that visualises which possible solutions in the available design space satisfy which design goals:


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak % Necessary to enforce !h
\newcommand{\yes}{\includegraphics[width=4mm]{images/yes.png}}
\newcommand{\no}{\includegraphics[width=4mm]{images/no.png}}
%\vspace{4mm}
\begin{table}[!h]
\begin{tabular}{|p{6.7cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|p{0.9cm}|}
\hline 
 & $1$ & $2$ & $3$ & $4$ & $5$a & $5$b & $5$c  \\
\hline
Allow \tcode{pre} on coroutines & \no & \yes & \yes & \yes & \yes & \yes & \yes  \\
\hline
Allow \tcode{post} on coroutines  & \no & \no & \yes & \yes & \yes & \yes & \yes  \\
\hline
Satisfy Contracts Prime Directive & \yes & \yes & \yes & \no & \no & \yes & \yes  \\
\hline
Do not expose moved-from parameters & \yes & \yes & \yes & \yes  & \yes & \yes & \no  \\
\hline
Do not make \tcode{pre}/\tcode{post} more inconsistent & \yes & \no & \yes & \no & \no & \yes & \no \\
\hline
Do not facilitate remote code breakage & \yes & \yes & \yes & \yes & \yes & \no & \yes \\
\hline
Support caller-side checking of \tcode{post} & \yes & \yes & \yes & \no & \yes & \yes & \yes  \\
\hline
\end{tabular}
\vspace{2mm}
\label{table:matrix}
\end{table}

The decision matrix reveals that the only possible solution that satisfies all our design goals is Solution 3: allow \tcode{pre} and \tcode{post} on coroutines, but make it ill-formed to odr-use a parameter of a coroutine in \tcode{post} (even if that parameter is \tcode{const}). Therefore, we propose to adopt Solution 3 for the Contracts MVP. We are convinced that this is the best option for the C++ language and its users.

Note that with Solution 3, if it is really necessary to refer to the function parameters in the postcondition, a workaround exists: one can wrap the coroutine into a non-coroutine wrapper as shown in Section \ref{intro}. With such a wrapper, the user themselves has to make the choice whether to copy or move a parameter, and there is no question as to whether \tcode{post} applies to the original or copy of the parameter, as only the original is visible to the wrapper. The situation will become even simpler once we get postcondition captures \cite{P3098R0} as a post-MVP extension, as parameters can be explicitly copied for later use in the postcondition, and the need for a wrapper will go away.

\section{Wording}

The proposed wording is relative to \cite{P2900R8}.

Modify [basic.contract.eval], paragraph 15:
\begin{adjustwidth}{0.5cm}{0.5cm}
If a contract-violation handler invoked from the evaluation of a function contract assertion exits via an exception, the behavior is as if the function body\added{, or if the function is a coroutine ([dcl.fct.def.coroutine]), the replacement of the function body, }exits via that same exception.
\end{adjustwidth}

Modify [dcl.contract.func], paragraph 6:
\begin{adjustwidth}{0.5cm}{0.5cm}
A \removed{coroutine ([dcl.fct.def.coroutine]), }a deleted function ([dcl.fct.def.delete])\removed{,} or a function defaulted on its first declaration ([dcl.fct.def.default]) may not have a \emph{function-contract-specifier-seq}.
\end{adjustwidth}

Modify [dcl.contract.func], paragraph 8:
\begin{adjustwidth}{0.5cm}{0.5cm}
If the predicate of a postcondition assertion of a function odr-uses ([basic.def.odr]) \added{a parameter of that function, the function shall not be a coroutine ([dcl.fct.def.coroutine]); if that parameter is not a reference, it }\removed{a non-reference parameter of that function, that parameter} shall be declared \tcode{const} and shall not have array or function type.
\end{adjustwidth}

%JMB: dcl.fct.def.coroutine p5 already says the same as what you originally said about throwing.   In all ways the coroutine behaevs as-if the function body was the replacement, not the original.
%    The thing that is missing in that section, in think, is clearly stating that the allocation function and the copy initialization all happen as part of the replacement body.  If we do that, then we get all the other orderings that we want.
%
%Modify dcl.fct.def.coroutine p5:  (new bullet at teh staart of the list, because it's the first thing that happens):
%  ... 
%  * Allocation of the coroutine state and initialization of parameter copies (described below) occurs at the beginning of this replacement body.
%
% That covers what we need normatively.
%
% The thing you have about p13 I think should be a note --- it also covers only half the question, as when we evaluate the allocation function is also not answered unless we go with incoroporating these into the function-body-replacement like i did above.
%
% The notes about exception handling for function-try-block are specific because a function-try-block catches any other exception emitted by a function body, coroutines don't have such a special relationship with exceptions.
% I would leave out notes for now --- intro.execution doesn't have special notes about coroutines and their replacement body.

Modify [dcl.fct.def.coroutine], paragraph 13:
\begin{adjustwidth}{0.5cm}{0.5cm}
When a coroutine is invoked, after initializing its parameters ([expr.call])\added{ and evaluating its precondition assertions ([dcl.contract.func])}, a copy is created for each coroutine parameter. For a parameter of type $cv$ \tcode{T}, the copy is a variable of type $cv$ \tcode{T} with automatic storage duration that is direct-initialized from an xvalue of type \tcode{T} referring to the parameter.
\end{adjustwidth}

%JMB: Andrzej did have a good point on the reflector that this is yet another case of SG21 producing too many papers.  I think that a consolidated paper that includes you, gor, peter, andrzej, and iain would be good.  I think it would be very good to have the disucssion on one paper and not have "let's talk about this issue and see 3 people present basically the same thing" again like we did when we first started tackling virtual functions.   Whether that means folding this into andrzej and iain's paper, or folding their points into this paper, is up to you guys --- but i would suggest doing one of those two things.
% TD: agreed!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak % MANUAL %%%%%%%%%
%\phantom{I really need a pagebreak here!}
%\pagebreak % MANUAL %%%%%%%%%

%\section*{Acknowledgements}
% TODO - nothing here yet

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak % MANUAL %%%%%%%%%
%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}


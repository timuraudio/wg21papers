\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}
\cftsetindents{paragraph}{1.02in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on virtual functions: \\ a principled design approach}
\author{
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\
John Lakos \small(\href{mailto:jlakos@bloomberg.net}{jlakos@bloomberg.net}) 
% TD: TODO: get Ville on board?
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3600R0 \\
Date: &2025-08-25 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we present a comprehensive analysis of the design space for supporting function contract assertions (\tcode{pre} and \tcode{post}) on virtual functions in C++. We begin by identifying a number of desirable properties that such a language feature should exhibit. We survey existing and proposed approaches and introduce a framework for classifying them according to a small number of key design decisions. For each decision, we examine its impact on the extent to which the desirable properties can be achieved. We find that no design achieving all desirable properties is possible. We identify three candidate designs that realise different, meaningful subsets of these properties. We distill the choice between these candidate designs down to two design decisions with different tradeoffs. We conclude with a recommendation for a concrete design that seems to offer the best set of tradeoffs overall.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\tableofcontents*
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\subsection{Motivation and context}

Contract assertions (\cite{P2900R14}) are a major new facility in C++26. A key feature of this facility are \emph{function contract assertions}: \tcode{pre} and \tcode{post}. This feature allows expressing
% TD: I omitted the "the" from this sentence here because they only allow expressing a subset of the full set of preconditions and postconditions, so saying "the preconditions and postconditions" would be technically incorrect, however explaining why that is the case (or even saying something like "a subset of" here) feels like a distraction.
preconditions and postconditions of a function directly in C++ code, and optionally checking those conditions at runtime to identify and mitigate program defects, in a configurable and scalable fashion. 

Unlike assertion statements (\tcode{contract_assert}) or pre-C++26 macro-based assertions, function contract assertions are a part of the function's \emph{declaration} and are thus readily found by humans, compilers, IDEs, and static analysis tools without having to inspect the function's definition. 

However, a major limitation of the initial feature set in C++26 is that \tcode{pre} and \tcode{post} cannot be placed on a \emph{virtual} function; doing so renders the program ill-formed. This limitation exists due to ongoing disagreements in WG21 regarding the desired semantics for \tcode{pre} and \tcode{post} on virtual functions that could not be resolved in the C++26 timeframe.

At the same time, virtual functions are widely used in C++ today. Many popular libraries and frameworks rely on runtime polymorphism as a key aspect of their design. Therefore, to ensure a successful adoption of contract assertions across the C++ ecosystem, we must add meaningful and user-friendly support for \tcode{pre} and \tcode{post} on virtual functions (as pointed out in \cite{P3173R0}).

In this paper, we consider everything we have learned since the adoption of \cite{P2900R14} and undertake a new attempt at resolving the existing disagreements. The goal of this paper is to find a design for this feature that suits the needs of the C++ community and can get consensus in WG21.

\subsection{Prior art}

\subsubsection{Other programming languages}

Other popular programming languages, such as C\#, Java, and Python, offer assertions only as a library feature,\footnote{For C\# and Java, there exist language extensions that implement function contract assertions: Microsoft Code Contracts and the Java Modeling Language (JML), respectively. Neither of these facilities enjoys significant use today. Microsoft Code Contracts is officially deprecated. JML had some influence in the 2000s but is nowadays restricted to academic contexts; the tooling for it is somewhat arcane and difficult to install and use.} and as such do not offer true function contract assertions\footnote{To aid understanding, throughout this paper we use the terminology of the C++ Standard (such as overriding function, overridden function, function contract assertion, etc.) for analogous concepts in other programming languages, even though in many cases the users of those languages would choose different terminology.} that could meaningfully integrate with the  dynamic dispatch mechanisms in those languages. However, there is a small number of less popular programming languages that offer both true function contract assertions and dynamic dispatch as a language feature: Eiffel, D, and Ada. In these languages, function contract assertions and virtual functions can be composed in a meaningful way.

Eiffel, released in 1986, was the first programming language that allowed placing precondition and postcondition assertions on function declarations. In Eiffel, such assertions are spelled with \tcode{requires} and \tcode{ensures}, respectively. Eiffel was developed in conjunction with the Design by Contract (DbC) paradigm by Bertrand Meyer. Its design closely follows that paradigm.

In particular, Eiffel by construction enforces the constraint that in an overriding function, preconditions can only be widened and postconditions can only be narrowed. This is achieved by using a conjunction (via OR) of the precondition assertions and a disjunction (via AND) of the postcondition assertions of the overriding function and all functions in the inheritance hierarchy overridden by it.

The D programming language, released in 2001, offered function contract assertions from its inception. Precondition and postcondition assertions are spelled with \tcode{in} and \tcode{out} blocks, respectively. For virtual functions, D's design follows the Eiffel paradigm of OR-ing precondition assertions and AND-ing postcondition assertions across an inheritance hierarchy. However, there are also some notable differences in the detail.

The Ada programming language added the feature in Ada 2012. Ada seems to be the only language with true function contract assertions that enjoys a significant degree of active use in production code today (albeit it is still a niche language, primarily used in safety-critical and mission-critical industries such as aerospace, defence, transportation, and medical systems).

Ada's design for function contract assertions on virtual functions is particularly complex. The default syntax, \tcode{Pre} and \tcode{Post} respectively, corresponds to so-called \emph{specific} precondition and postcondition assertions. However, adding the \tcode{Class} attribute turns them into so-called  \emph{class-wide} precondition and postcondition assertions, \tcode{Pre\textquotesingle Class} and \tcode{Post\textquotesingle Class} respectively, with entirely different and rather unique semantics. Any given function can have both flavours of function contract assertions applied to it simultaneously.

A more detailed discussion of these historic designs, and how they could be applied to C++, can be found in Section~\ref{designs} of this paper.

The ability to express the contract of a function also exists in a number of academic research languages; Dafny and Spec\# are notable examples. However, the contract facilities in these languages are designed for static correctness proofs rather than runtime checking. Thus, they are very different in nature from the contract facility in C++26. The same is true for the experimental contracts facility in Kotlin. There also exists an experimental contracts facility for Rust that is realised via procedural macros; however, it does not seem to be integrated with Rust's mechanism for dynamic dispatch (trait objects). All these designs are therefore not directly relevant for the purposes of this paper.

\subsubsection{C++ proposals}

The first proposal for adding a contracts facility to C++ \cite{N1613} was directly inspired by the D language and therefore proposed the same design as realised in D: precondition and postcondition blocks that are OR-ed and AND-ed, respectively, across an inheritance hierarchy. The next revision, \cite{N1669}, changed this to OR-ing preconditions but enforcing that postconditions are the same across the entire hierarchy.
%, with the motivation that weakening postconditions is “useless in practice since the user cannot take advantage of the weaker precondition by performing a downcast.”
% TD: TODO: This motivation does not need to be in this overview; mention it somewhere else.
This proposal was revised a few more times, but ultimately did not succeed in WG21; the last revision was \cite{N1962}.

The second proposal for a contracts facility \cite{N3604} proposed contract assertions as a library feature, in the form of macros inside the function body. Therefore, it did not have true function contract assertions that could interact with dynamic dispatch. This proposal, too, did not succeed in WG21; the last revision was \cite{N4378}).

Following the abandonment of the second proposal, many different design options were explored in various papers. \cite{N4110} and \cite{P0147R0} argued in favour of the established DbC principle that preconditions should not be strengthened and postconditions should not be weakened. On the other hand, \cite{P0247R0} argued that inheriting checks on virtual functions, or requiring that checks on base class virtual interfaces match overriders ``does not work'', and that allowing an overriding function to both widen and narrow the preconditions of the overridden function might make sense because not everyone will want to call a function through the same interface.

\cite{N4415} and \cite{P0287R0} proposed a more conservative design than in previous proposals or in Eiffel, D, and Ada: virtual functions are constrained to have the same sequence of function contract assertions across the entire inheritance hierarchy. In an overriding function, the function contract assertion sequence of the overridden function can be either repeated or omitted (i.e., inherited implicitly); if it is repeated, it must be ODR-identical. \cite{P0380R0} made this design even more restrictive by requiring that the sequence be repeated on every overriding function; however, this restriction was rolled back again in \cite{P0380R1}. This was retained throughout C++2a Contracts (\cite{P0542R5}), which were adopted for the C++20 Working Draft and then removed again (\cite{P1823R0}).

After the failure of C++2a Contracts and the establishment of SG21, proposals continued to flip-flop between these two designs: \cite{P2388R4} made repeating the sequence on an overriding function optional, and \cite{P2521R5} made it mandatory again. \cite{P2954R0} added yet another variation: repeating the function contract assertion sequence on an overriding function was neither optional nor required but actually ill-formed; the sequence was always inherited implicitly. This design was approved by SG21.

However, after more investigation, implicit inheritance of the contract was found to be problematic (see \cite{P2932R3} Section 3.4). SG21 decided that, given the many concerns and disagreements over how function contract assertions should work on virtual functions, consensus on a comprehensive
solution could be deferred to a future extension, and virtual function support was thus removed
entirely from the proposal. This design was forwarded to EWG and LEWG.

However, in \cite{P3173R0}, a major compiler vendor stated that, given the importance and pervasive use of virtual functions in C++, a contracts facility that fails to support efficient use with virtual functions is inadequate for standardisation. It seemed unlikely at that point that EWG would adopt a contracts facility without support for virtual functions.

This led to the development of a new design for virtual function support in \cite{P3097R0} that resolved the known issues of previous designs. This design removed contract inheritance and introduced the notion of caller-facing and callee-facing function contract assertions. A counterproposal with yet another new design based on contract inheritance was made in \cite{P3169R0}. SG21 carefully considered all design options known at the time and forwarded the design in \cite{P3097R0} to EWG. This design was approved by EWG and incorporated into the C++26 proposal.

However, following this decision, concerns were raised in \cite{P3506R0} and in \cite{P3573R0} that the caller/callee model from \cite{P3097R0} that had been approved by EWG was a departure from the established DbC model; that it had insufficient deployment and usage experience in the field; and that it was too complex. A rebuttal paper \cite{P3506R0} argued that the caller/callee model is the most appropriate design for C++ and should be retained. EWG did not manage to resolve this disagreement in the C++26 timeframe and instead decided to ship contract assertions in C++26 without support for virtual functions.

A more detailed history of function contract assertions on virtual functions in C++, including poll results and references to all relevant papers, can be found in \cite{P2899R1} Section 3.3.2.

\subsection{Methodology}

The goal of this paper is to identify the design for supporting \tcode{pre} and \tcode{post} on virtual functions that best satisfies the needs of the C++ community and to facilitate establishing consensus in WG21 in favour of such a design. To achieve this goal, we analyse the available design space as exhaustively and objectively as possible. Our analysis follows the method for finding consensus on technical design questions developed in \cite{P3684R0}. This method is an evolution and adaptation of the Principled Design method developed in \cite{P3004R0} and \cite{P3005R0}.

We begin by identifying the desirable properties that a design for this language feature should exhibit (Section~\ref{properties}). We take into account all relevant properties that were articulated by members of WG21. We describe each property as precisely as possible, along with motivation, use cases, and code examples. We treat all properties equally and do not attempt to rank them.

We then identify all known design options for this feature (Section~\ref{designs}), including all variations that have been shipped in other programming languages or proposed for C++ at some point. As a tool for efficiently navigating this design space, we introduce a framework for classifying all possible designs according to a small set of key design decisions, as well as a scheme to refer to each possible design with an unambiguous identifier that encodes this set of decisions.

We proceed by constructing an \emph{evolution graph}, i.e., determining which design options can be obtained by future evolution of other, more conservative design options (Section~\ref{evolution}). Such an evolution graph is useful in the case where the committee fails to get consensus on a decision between two different design options. In this case, we can fall back to the maximal common ancestor of both options in the evolution graph.

With this thorough mapping of the available design space, we conduct an analysis of how well each available design option satisfies the identified desirable properties (Section~\ref{matrix}). We visualise this analysis with a so-called \emph{conformance matrix}. 

In the final part of our analysis, we use the conformance matrix to identify the most promising candidate designs (Section~\ref{tree}). We distill the choice between these candidate designs down to a small number of binary design decisions between concrete tradeoffs (``do we prefer satisfying property A or property B?'') that can be polled in EWG. We conclude with a recommendation for a concrete candidate design that seems to offer the best set of tradeoffs overall (Section~\ref{conclusion}).


\section{Desirable properties}
\label{properties}

% TD: TODO: add a property that indirect calls where static and dynamic type are equal should have the same set of function contract assertions as direct calls.

% TD: TODO: add a property that pre(true) and post(true) should mean the same thing as nothing

\subsection{General approach and selection criteria}

In this section, we identify the desirable properties that a design for supporting \tcode{pre} and \tcode{post} on virtual functions should exhibit. We take into account all relevant properties that were articulated by members of WG21 (whether formally in papers or informally during meetings or on the committee mailing lists).

We describe each desirable property as precisely as possible and provide known motivation for supporting it. Where applicable, we include concrete code examples; we strive to provide realistic use cases rather than ``toy code'' whenever possible. Each property is given a short unique identifier to easily refer to it later in the paper, for example \tcode{ImplExp} for implementation experience (a non-design requirement). 

We follow the consensus-building method developed in \cite{P3684R0}; thus, we focus on data and objectively verifiable information rather than opinions, and do our best to avoid bias and value judgments. In particular, we do not attempt to rank the listed properties by priority, relevance, or otherwise. However, we do point out cases where two or more properties are at odds with each other.

Some of the listed properties were originally articulated as ``design principles that must be adhered to'',  ``very important use cases'', ``necessary conditions for successfully deploying the feature'', etc. For the purpose of this analysis, we carefully avoid such characterisations and instead treat all properties equally. For properties that are describing a use case, we avoid any claims of how common (or contrived) it is due to lack of data from real-world code bases backing up such claims.

In a number of cases, it may be controversial whether the motivation is sound, the use case is plausible, and the property in question is actually desirable. In these cases, we strive to adopt a neutral position and limit ourselves to describing the property and the known motivation for and against supporting it.

We only include properties for which we can objectively and unambiguously answer the question ``does a given language design exhibit this property?''. We therefore deliberately exclude properties that are vague, subjective, and/or cannot be measured directly, such as teachability or intuitiveness. We also do not include properties that could in principle be measured, but for which no concrete, measurable criterion has been proposed.

For example, \cite{P3573R0} mentions the concern that \tcode{pre} and \tcode{post} on virtual functions ``have not been tried at scale''. However, the paper does not specify a measurable criterion for what would constitute sufficient ``scale''. We are happy to include this property in a future revision of this paper if the authors can provide a measurable criterion (e.g., a particular number of lines of deployed code that they consider sufficient deployment experience). Similarly, \cite{P3506R0} listed as a concern that the design proposed in \cite{P3097R0} was ``too complex''; however, since the author did not provide an objective criterion for measuring the complexity of any possible design, we exclude this concern from our analysis.

Importantly, we are not suggesting that properties like teachability or complexity are not relevant for language design; quite the opposite. However, since we cannot objectively measure them, it will be up to each member of WG21 to decide how to weigh these more subjective properties against the objective ones presented in this paper when considering a concrete proposed design for inclusion in Standard C++.

\subsection{List of properties}

%::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

% Macro to define custom subsubsubsections for properties
\newcommand{\prop}[2]{
  \paragraph*{\tcode{#1}: #2}
  \refstepcounter{paragraph}
  \label{#1}
  \addcontentsline{toc}{paragraph}{\tcode{#1}: #2}
  \mbox{}\vspace{0.5em} % hack to force the heading to not be run-in
  \nopagebreak[4]
}

% Macro to refer to properties
\newcommand{\propref}[1]{\hyperref[#1]{\tcode{#1}}}

%::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


\subsubsection{Design constraints}

The following properties describe desirable design constraints on the behaviour of \tcode{pre} and \tcode{post} on virtual functions: design paradigms that should be followed or design patterns that must or must not be possible.

\prop{FullQualEq}{Equivalence of virtual and fully qualified direct calls}

% TD: Josh, I included this property anyway because it's a nice easy way to start the list of properties: surely this is one that we can all agree on. Also, it's important to JL.

In a virtual function call, when the statically called function and the function chosen by dynamic dispatch are the same function, the effect of such a call should be equivalent to a fully qualified (i.e., non-virtual) call to that function. In particular, the same function contract assertions should be evaluated in both cases.

Consider the following simple inheritance hierarchy:

\begin{codeblock}
struct Base {
  virtual void f() /* ... */;
};

struct Derived : Base {
  void f() override /* ... */;
};
\end{codeblock}
No matter which (if any) function contract assertions are specified in \textit{/* ... */}, both of the following function calls should evaluate the same function contract assertions when executed:

\begin{codeblock}
int main() {
  Derived d;
  d.f();     // (1)
  d.D::f();  // (2)
}
\end{codeblock}
In C++ today, the observable behaviour of the two calls above is identical in all cases as long as \tcode{Derived} is the dynamic type of \tcode{d}. It would be arguably very surprising to users if a design for \tcode{pre} and \tcode{post} on virtual functions would break that equivalence.

% TD: TODO: Is there better motivation for this property? Asked JL

\prop{VacuousTrue}{Vacuousness of \tcode{pre(true)} and \tcode{post(true)}}

On the declaration of a virtual function, \tcode{pre(true)} and \tcode{pre(false)} should always be vacuous, i.e., they should be equivalent to not specifying any precondition or postcondition assertion at all on that declaration. In particular, whether or not \tcode{pre(true)} and \tcode{pre(false)} are present should not change which function contract assertions will be evaluated.

This constraint is consistent with the vacuousness of \tcode{pre(true)} and \tcode{post(true)} on non-virtual functions, as well as the vacuousness of \tcode{assert(true)}, \tcode{static_assert(true)}, \tcode{requires(true)}, etc. in C++ today. Further, if we could not rely on this constraint being satisfied, it could lead to surprising behaviour in cases where the presence of function contract assertions is conditional.

Consider, for example, a function that takes a file path as a parameter. On Windows, there is historically a strict limit on the length of such paths; however, this limit does not exist on other platforms. We could make the contract predicate platform-dependent:

\begin{codeblock}
#ifdef _WIN32
  #define PATH_OK(path) path.size() < MAX_PATH 
#else
  #define PATH_OK(path) true
#endif

Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
    pre(PATH_OK(path)) {
      // ...
};
\end{codeblock}

Alternatively, we could conditionally macro out the entire precondition assertion:

\begin{codeblock}
Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
#ifdef _WIN32
    pre(path.size() < MAX_PATH)
#endif
  {
    // ...
};
\end{codeblock}

Both programming styles seem reasonable in cross-platform code. It would arguably be surprising to users if a design for \tcode{pre} and \tcode{post} on virtual functions would introduce cases where they lead to different contract assertions being evaluated.

\prop{SubstPr}{Substitution principle}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should follow the \emph{substitution principle}, which stipulates that objects of a base class should be replaceable with objects of a derived class without affecting the correctness of the program.

Consider the following program:
\begin{codeblock}
struct Base {
  virtual int f(int i)
    pre (i >= 0)
    post (r: r <= i);
};

void test(Base& b) {
  std::print(b.f(42));
}
\end{codeblock}
This program calls \tcode{Base::f} correctly, i.e., it satisfies its precondition that the integer passed in must be nonnegative. This is verified by the fact that there is no precondition assertion violation. If the call to \tcode{Base::f} returns without a postcondition assertion violation, the program can rely on \tcode{Base::f} being implemented correctly as well and the printed value to never be greater than 42.

A function that overrides \tcode{Base::f} but has narrower precondition assertions would break the correctness of the call and thus violate the substitution principle. Consider:
\begin{codeblock}
struct Derived1 : Base {
  int f(int i) override
    pre (i % 2 == 0);
}
\end{codeblock}
In this example, \tcode{Derived1::f} specifies a precondition assertion that may fail on inputs that are considered correct for \tcode{Base::f} (odd nonnegative integers). This assertion should therefore either not compile, or it should not be evaluated, otherwise \tcode{Derived1} is not substitutable for \tcode{Base}.

Further, a function that overrides \tcode{Base::f} but has wider precondition assertions for inputs that are considered correct for \tcode{Base::f} would break the expectations of the calling code and thus also violate the substitution principle. Consider:

\begin{codeblock}
struct Derived2 : Base {
  int f(int i) override /* ... */ {
    return 42;
  }
}
\end{codeblock}

In this example, \tcode{Derived2::f} is not substitutable for \tcode{Base::f} as it is possible to pass a nonnegative number (thus satisfying the precondition assertions of \tcode{Base::f}) but get a number back that is larger than the number passed in (thus failing the postcondition assertions of \tcode{Base::f}). The design should therefore ensure that when passing an object of dynamic type \tcode{Derived2} to the function \tcode{test(Base\&)}, calling \tcode{Derived2::f} from there will result in a postcondition assertion violation. Such a design may or may not constrain which function contract assertions are allowed in \mbox{\emph{/* ... */}}.

Note that widening preconditions and narrowing postconditions in the overridden function do not violate the substitution principle. Note further that when an overriding function has wider preconditions than the overridden function, and is called \emph{outside} of the overridden function's preconditions (i.e., in a way that is a correct call of the overriding function but would not be a correct call of the overridden function), there is no need to satisfy the overridden function's postconditions. Consider:

\begin{codeblock}
struct Derived3 {
  int f(int i) override {
    return std::abs(i);
  }
};
\end{codeblock}
In this example, \tcode{Derived3::f} operates on a wider domain than \tcode{Base::f} as it is possible to pass a negative integer and get a value back. In this case,  \tcode{Derived3::f} does \emph{not} satisfy the postcondition of \tcode{Base::f} that the return value needs to be not greater than the value passed in. However, \tcode{Base} is still substitutable by \tcode{Derived3} because \tcode{Derived3::f} will always satisfy the postcondition of \tcode{Base::f} when given a nonnegative integer.

The substitution principle is a well-established paradigm in object-oriented programming. It ensures that derived classes remain true to the behaviour and expectations of their base classes, allowing the user to use them interchangeably without introducing bugs. Applying this principle to the design of \tcode{pre} and \tcode{post} on virtual functions seems appropriate in situations where external clients depend on contracts, such as when designing public APIs, libraries, and frameworks.

However, there are other situations where full substitutability between base and derived class is a non-goal. A design that requires \tcode{pre} and \tcode{post} to obey the substitution principle would make function contract assertions unusable in those situations. Such use cases are described in properties \propref{NarrowPre} and \propref{WidenPostIn}. This is one instance where different properties listed in this paper  cannot be satisfied simultaneously.

\prop{MeyerDbC}{Bertrand Meyer's ``Design by Contract'' paradigm}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should follow Bertrand Meyer's Design by Contract (DbC) paradigm, which stipulates that in an overriding function, preconditions can only be widened and postconditions can only be narrowed, but not vice versa.

Following the DbC paradigm when  specifying the semantics of \tcode{pre} and \tcode{post} on virtual functions is a well-known approach to enforcing the substitution principle, and is existing practice in the Eiffel and D programming languages with decades of usage experience.

However, the DbC paradigm imposes even stronger constraints than the substitution principle. Any design that satisfies \propref{MeyerDbC} also satisfies \propref{SubstPr}, but not vice versa. In particular, a function that has wider postconditions than the function it overrides if and only if is called \emph{outside} of the overridden function's preconditions satisfies \propref{SubstPr}, but does not satisfy \propref{MeyerDbC}. An example for such a function is \tcode{Derived3::f} in \propref{SubstPr} above.

Concrete use cases that are not compatible with \propref{MeyerDbC} --- beyond those that are already not compatible with \propref{SubstPr} --- are described in properties \propref{WidenPostOut} and \propref{WidenPostMult}. Therefore, this is another instance where different properties listed in this paper cannot be satisfied simultaneously.

\prop{FailFast}{Fail immediately on contract violation}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should continue to ensure, as C++26 Contracts do today, that the user can configure their program to fail immediately when any contract assertion fails. Consider a virtual function with a precondition assertion as follows:
\begin{codeblock}
struct Y : X {
  virtual void usePtr(void* ptr) 
    pre (ptr != nullptr);
}
\end{codeblock}
Whenever the assertion \mbox{\tcode{ptr != nullptr}} is evaluated with a checked semantic and the check fails, the contract-violation handler should be called and/or the program should be terminated (depending on the chosen evaluation semantic). The program should not attempt to evaluate other function contract assertions specified on functions overriding (or overridden by) \tcode{Y::usePtr} past the failed check. In particular, function contract assertions from different functions should not be OR-ed before determining whether a contract violation occurred.

The rationale for this property is as follows. Eiffel, which OR-s preconditions across the inheritance hierarchy, is a memory-safe language, while C++ is not. In C++, continuing past any failed assertion check, regardless of where in an inheritance hierarchy it occurs, may lead to undefined behaviour and security vulnerabilities. A design for supporting \tcode{pre} and \tcode{post} on virtual functions should not introduce new opportunities for such vulnerabilities.

Note that this property seems at odds with \propref{SubstPr} and \propref{MeyerDbC}, because as far as we are aware, OR-ing preconditions is the only specification strategy for enforcing that an overriding function cannot narrow the preconditions of the function it overrides.

\prop{BaseIndep}{\tcode{pre} and \tcode{post} should be usable independent of base}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow a client of a virtual function to override that function in a derived class, add function contract assertions to the overriding function, and have those assertions evaluated, even if the base class is written against an older C++ Standard and does not use contract assertions at all.

Consider a GUI framework with a \tcode{Widget} base class as follows:

\begin{codeblock}
class Widget {
public:
  // Preconditions:   
  // \phantom{xxx}\tcode{child} points to a \tcode{Widget};
  // \phantom{xxx}\tcode{child->isValid()} is \tcode{true}; 
  // \phantom{xxx}\tcode{zOrder} is between -32768 and +32767.
  virtual void addChildWidget (Widget* child, int zOrder);
  
// ...
};
\end{codeblock}
This GUI framework is third-party code that we do not control and cannot modify. The function \tcode{Widget::}\allowbreak\tcode{addChildWidget} has preconditions, but those are not checked with function contract assertions as the code predates the availability of the feature.

In our own codebase, we have a framework of custom widget types, all inheriting from the \tcode{Widget} class above. For our own custom widget types at least, we would like to introduce precondition assertions for checking the preconditions, in order to identify incorrect use and take advantage of the many benefits of precondition assertions over macro-based assertions:
\begin{codeblock}
class CustomWidget : public Widget {
public:
  void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767) 
  {
    // custom child/parent widget tracking logic here...
    Widget::addChildWidget(child, zOrder);
  }
}
\end{codeblock}
In order to be deployable in such codebases, a design for supporting \tcode{pre} and \tcode{post} on virtual functions needs to provide a way to have the function contract assertions of \tcode{CustomWidget::}\allowbreak\tcode{addChildWidget} evaluated whenever that function is called, without having to modify the \tcode{Widget}  base class.


\prop{NoRemoteBreak}{Avoid remote code breakage}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the author of a base class to add function contract assertions to a virtual function without breaking correct uses of derived classes in remote client code.

Consider again the GUI framework from property \propref{BaseIndep}. As the owners of the base class \tcode{Widget}, we might want to introduce precondition assertions for checking the preconditions of \tcode{Widget::}\allowbreak\tcode{addChildWidget}, and roll out these assertions to clients that have a recent enough compiler to take advantage of them: 

\begin{codeblock}
class Widget {
public:
  virtual void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767);
}
\end{codeblock}

At the same time, one of our clients may have a widget type in their code base that can handle a wider range of values for \tcode{zOrder} just fine, and may be using this type in production:

\begin{codeblock}
class SuperWidget : public Widget {
  // this version can handle any values for \tcode{zOrder}!
  void addChildWidget(Widget* child, int zOrder) override {
    // ....
  } 
}

class Window : public SuperWidget;
class Button : public SuperWidget;
// ...

void drawApp() {
  window.addChildWidget(button, 99999);
}
\end{codeblock}
As long as the client uses the \tcode{SuperWidget} interface instead of the base \tcode{Widget} interface for their widgets above, their program is correct --- there is no contract violation. In order to be deployable, adding the above function contract assertions to \tcode{Widget::}\allowbreak\tcode{addChildWidget} should not break their program by introducing a precondition assertion violation to it.

\subsubsection{Single inheritance}

The following properties describe the desirable default behaviour of \tcode{pre} and \tcode{post} for use cases where a virtual function overrides at most \emph{one} other virtual function.

\prop{WidenPre}{Enable widening preconditions}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{widen} preconditions in an overriding function, i.e., to specify precondition assertions that are less strict than those specified on the overridden function, or even specify that there are \emph{no} precondition assertions on the overriding function. Whenever the overriding function is called \emph{directly} (i.e., it is the statically called function), those less strict precondition assertions should be evaluated instead of the overridden ones.

Consider the following use case from \cite{P0247R0}:
\begin{codeblock}
class Display {
public:
  virtual void post_message(std::string_view s)
     pre (is_ascii(s)) = 0;
};

class XDisplay : public Display {
   // ...
public:
  void post_message(std::string_view s) override
    pre (is_utf8(s));
 };
\end{codeblock}
In this example, we have a base class facility that accepts ASCII strings to display. However, the derived implementation accepts UTF-8. A subsystem that takes an \tcode{XDisplay} reference may be passed an object of dynamic type \tcode{XDisplay} or a type deriving from it. Such a subsystem should be able to generate and post both ASCII and UTF-8 messages. In other words, the following program should not cause a contract violation when executed:
\begin{codeblock}
void test(XDisplay& xd) {
  xd.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}

\prop{ChkPreCaller}{Check caller-facing preconditions}

In a virtual function call, the precondition assertions specified on the statically called function should be evaluated by default, regardless of which function will be selected by dynamic dispatch and what  precondition assertions are specified on that function.

Consider again the \tcode{Display} --- \tcode{XDisplay} inheritance hierarchy from property \tcode{WidenPre}. Let us slightly alter the \tcode{test} function such that it takes a reference to the base class \tcode{Display}:
\begin{codeblock}
void test(Display& d) {
  d.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}
The above program should cause a contract violation when executed, because it violates the preconditions of the statically called function (\tcode{Display::post_message}), even though the preconditions of the function that will actually be executed (\tcode{XDisplay::post_message}) are satisfied.

The rationale for this property is that calling \tcode{Display::post_message} with a non-ASCII input string is an incorrect use of the \tcode{Display} interface and therefore constitutes a bug that should be detectable by contract checking. In the program above, the dynamic type of the object referenced by \tcode{d} happens to be \tcode{XDisplay}, and \tcode{XDisplay::post_message} can handle non-ASCII strings just fine; however, that dynamic type is not known at the call site and can change in the future. The call site must therefore work correctly for any type of \tcode{Display}, whether it happens to be an \tcode{XDisplay} or not.


\prop{NarrowPre}{Enable narrowing preconditions}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} preconditions in an overriding function, i.e., to specify precondition assertions 
 that are \emph{more strict} than those of the overridden function. Whenever the overriding function is executed (regardless of what the statically called function is), these more strict precondition assertions should be evaluated. Failure should cause a contract violation, even if all precondition assertions of the overridden function are satisfied.

Consider a base class for a facility that takes a name and retrieves the corresponding personal file. The retrieval function has a precondition assertion that the name is not an empty string:
\begin{codeblock} % TD: TODO: call with JMB on 2025-08-26: ideas for changing the examples here
class PersonRegister {
  // ...
public:
  virtual Person retrievePerson(std::string_view name)
    pre (!name.empty());
};
\end{codeblock}
Now we can have several implementations of such a facility that store and retrieve the personal data in different ways. One of these implementations may keep the data in a remote database. This implementation has an additional precondition that does not exist in the base class --- when we retrieve the personal file, the database connection needs to be open:
\begin{codeblock}
class DatabasePersonRegister {
  Database db;
  // ...
public:
  Person retrievePerson(std::string_view name) override
    pre (db.isOpen());
};
\end{codeblock}
In order to support this use case, a design needs to make code such as the above well-formed.Whenever the function selected by dynamic dispatch is \tcode{DatabasePersonRegister::}\allowbreak\tcode{retrievePerson}, the assertion \tcode{db.isOpen()} should be evaluated. Whenever checking this assertion fails, a contract violation should occur, even if the statically called function is \tcode{PersonRegister::}\allowbreak\tcode{retrievePerson} and all preconditions of that function are met.

Arguably, the class hierarchy above does not represent canonical object-oriented design because \tcode{PersonRegister} is not substitutable by \tcode{DatabasePersonRegister} in all cases. In order to make it substitutable, an additional initialisation step is required: the user needs to open the database connection for  \tcode{DatabasePersonRegister}, and substitutability will be satisfied from that point forward. In other words, in this case substitutability is a dynamic property of the system rather than a static one.

The rationale for supporting this use case is that such class hierarchies exist and are used in production systems today. As long as the author of the code ensures that the database connection is opened before \tcode{DatabasePersonRegister::}\allowbreak\tcode{retrievePerson} is called, the program is correct (it does not violate its contract). On the other hand, not opening the database connection before \tcode{DatabasePersonRegister::}\allowbreak\tcode{retrievePerson} is called constitutes a bug (a failure to ensure that \tcode{PersonRegister} is subsitutable by \tcode{DatabasePersonRegister} at the point of use). Such a substitutability bug  should be detectable by contract checking. If we do not allow precondition assertions to be used in this way, the owner of the above class hierarchy will not be able to add function contract assertions to it, leaving such bugs undetected.


\prop{WidenPostOut}{Enable widening postconditions outside of base contract}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function in cases where the overriding function is called outside of the overridden function's preconditions. This property builds on property \propref{WidenPre}.

Note that the derived class is substitutable for the base class as long as the overriding function satisfies the overridden function's postconditions whenever the caller satisfies the overridden function's preconditions. However, if the caller calls the overriding function directly and does \emph{not} satisfy the overridden function's preconditions (which is enabled by \propref{WidenPre}), the overriding function no longer has to satisfy the overridden function's postconditions either. Widening those postconditions in this case does not sacrifice substitutability.
% TD: TODO: There will be duplication between this and a description of the substitutability principle itself. Deduplicate; potentially move the constraints to the front?

The requirement to widen postconditions in this way arises whenever the overriding function operates on a larger domain than the function it overrides. As an example of this situation, let \tcode{Number} be a generic type that can represent real or complex numbers. Now, consider a type \tcode{Sqrt} that computes a real-number square root. The function \tcode{Sqrt::compute} requires a nonnegative real number as input, and returns another nonnegative real number as output. We can specify this contract using function contract assertions:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre(x.isReal() && x.realPart() >= 0)
    post(r : r.isReal() && r.realPart() >= 0);
};
\end{codeblock}
% TD: TODO: we can re-use this example and add a post inherit (r: approxEquals(r * r, x))
This implementation of square root might have a number of useful properties, such as being
implemented very quickly with hardware instructions. However, \tcode{Sqrt} is also a polymorphic type, so that the user can substitute other methods for computing the square root with different properties.

Later on, we might add an implementation of square root to our codebase that can handle the entire complex plane and therefore drops the precondition and postcondition assertions of \tcode{Sqrt::compute}:

\begin{codeblock}
struct ComplexSqrt : public Sqrt {
  Number compute(const Number& x) override;
};
\end{codeblock}
When the preconditions of the overridden function \tcode{Sqrt::compute} are satisfied, \tcode{ComplexSqrt::}\allowbreak\tcode{compute} gives clients the same guarantee: if the user passes a nonnegative real number, they will get back a nonnegative real number. Therefore, \tcode{Sqrt} is substitutable by \tcode{ComplexSqrt}. 

However, when the function \tcode{ComplexSqrt::compute} is used directly, the calling code is no longer required to satisfy the preconditions of \tcode{Sqrt::compute} and can pass any complex number. In this case, satisfying the postconditions of \tcode{Sqrt::compute} is no longer necessary either. In the following program, \tcode{ComplexSqrt::compute} should correctly return a value that is \emph{not} a nonnegative real number, without causing a contract violation:

\begin{codeblock}
int main() {
  Number complexUnit = ComplexSqrt().compute(-1);
}
\end{codeblock}

\prop{WidenPostIn}{Enable widening postconditions inside base contract}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function in the general case. This property extends property \propref{WidenPostOut} to cases where the overridden function is not fully substitutable for the overriding function. It can be interpreted as the mirror image of property \propref{NarrowPre}.

Consider again 

\prop{ChkPostCaller}{Check caller-facing \tcode{post}}

In a virtual function call, the postcondition assertions of the statically called function should be evaluated by default, regardless of which function will be selected by dynamic dispatch and what postcondition assertions are specified on that function.

TODO

% TD: TODO: can't find a good example for this!

\prop{NarrowPost}{Enable narrowing postconditions}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} postconditions in an overriding function, i.e. to specify postcondition assertions that are more strict than those of the overridden function. Whenever the overriding function is executed (regardless of what the statically called function is), these more strict postcondition assertions should be evaluated. Failure should cause a contract violation, even if all postcondition assertions of the overridden function are satisfied.

Consider an abstract class that is used to generate sequences of integers through a virtual function:

\begin{codeblock}
struct Generator {
  virtual int next() = 0;
};
\end{codeblock}
Many different derived classes might be implemented that produce different sequences. A particularly simple implementation may always produce the same constant value, which can be specified by the user:
\begin{codeblock}
struct ConstantGenerator : Generator {
  void setValue(int value);
  int getValue(); 
  int next() override
    post (r: r == getValue());
}
\end{codeblock}
The above postcondition assertion is specific to the implementation of \tcode{ConstantGenerator::}\allowbreak\tcode{next()}. A violation of that postcondition assertion indicates a bug in the implementation of \tcode{ConstantGenerator}. Such an implementation bug should be diagnosed by contract checking regardless of which the statically called function is and what its postcondition assertions are. Therefore, the following program should cause a contract violation when executed:
\begin{codeblock}
void test(Generator& gen) {
  std::print(gen.next());
}

int ConstantGenerator::next() override {
  return 0;  // dummy implementation  
} 

int main() {
  ConstantGenerator constGen;
  constGen.setValue(42);
  test(myGen);
}
\end{codeblock}


\prop{Inherit}{Inherit function contract assertions by default}

When a virtual function specifies function contract assertions, and is then overridden by another virtual function in a derived class, the overriding function should, by default, \emph{inherit} the function contract assertions of the overridden function. That is, if the overriding function does not specify its own precondition or postcondition assertions, those of the overridden function should apply, even if the overriding function is called directly.

Note that \tcode{Inherit} is a stronger property than the combination of properties \tcode{ChkPreCaller} and \tcode{ChkPostCaller}. With those properties, the function contract assertions of the overridden function are only evaluated when the overriding function is called through the overridden interface. However, with \tcode{Inherit}, the function contract assertions of the overridden function will be checked regardless of how the overriding function is called.

As a use case, consider \tcode{QIODevice}, the base interface class of all I/O devices in the Qt framework.\footnote{Documentation available here: \url{https://doc.qt.io/qt-6/qiodevice.html}} This class has a number of virtual functions such as \tcode{readData} which take a raw data pointer to read bytes from. In a future version of Qt, one might want to add a precondition assertion to check that this pointer is not null:
\begin{codeblock}
class QIODevice {
public:
  virtual qint64 readData(char* data, qint64 maxSize)
    pre (data != nullptr) = 0;
  // ...
};
\end{codeblock}
Now, if a user inherits from \tcode{QIODevice} and overrides \tcode{readData}, the intent is that the same null pointer check will apply to their function, without them having to specify any function contract assertions. Specifically, in the following program,
\begin{codeblock}
class MyIODevice : public QIODevice {
public:
  qint64 readData(char* data, qint64 maxSize) override {
    // my implementation...
  }
  // ...
};

int main() {
  char* data = nullptr;
  qint64 size = 0;
  
  MyIODevice device;
  device.readData(data, size);
}
\end{codeblock}
the last line of \tcode{main} should trigger a contract violation when checks are enabled, even though the derived class \tcode{MyIODevice} is used directly rather than through the base class interface \tcode{QIODevice}. 

The rationale for this property is that in any reasonable implementation of \tcode{QIODevice}, this precondition check is useful to detect bugs that would otherwise lead to program failure; at the same time, it would be far too easy for non-expert authors of derived classes to forget to consider that they want and need that precondition check on their own implementation.

The same argument can be extended to postcondition assertions as well. Consider a base class for different algorithms that choose one number out of a non-empty set of numbers:
\begin{codeblock}
struct NumberPicker {
  virtual int pick(const Array<int>& numbers)
    pre (!numbers.empty())
    post (r: numbers.contains(r)) = 0;
};
\end{codeblock}
Now consider different implementations of this base class:
\begin{codeblock}
struct FirstNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[0];
  }
};

struct RandomNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[rand() % numbers.size()];
  }
};
\end{codeblock}
We expect that any correct implementation of  \tcode{NumberPicker} will satisfy both the precondition and postcondition assertions of \tcode{NumberPicker::pick}. Therefore, those assertions should be checked even in cases in which the derived class interface is used directly, for example in a statically polymorphic context:
\begin{codeblock}
template <typename T>
int pickNumber(T& picker, const Array<int>& numbers) {
  return picker.pickNumber();
}

int rollDice() {
  return pickNumber(RandomNumberPicker(), {1, 2, 3, 4, 5, 6});
}
\end{codeblock}
In the above case, if the implementation of \tcode{RandomNumberPicker::pick} fails to satisfy the postcondition assertion of \tcode{NumberPicker::pick}, we should get a contract violation.

% TD: TODO: point out that this is at odds with WidenPre, WidenPostOut, and WidenPostIn (and BaseIndep and NoRemoteBreak?)



\subsubsection{Multiple inheritance}

The following properties describe the desirable default behaviour of \tcode{pre} and \tcode{post} for use cases where a virtual function overrides  more than one other virtual function.

\prop{WidenPreMult}{Override multiple functions with incompatible preconditions}

TODO

\prop{WidenPostMult}{Override multiple functions with incompatible postconditions}

TODO


\subsubsection{Optional behaviour}

The following properties describe use cases where multiple different behaviours for \tcode{pre} and \tcode{post} on virtual functions are possible and the user should have the option to explicitly choose between either.


%%%%% OLD WED 27 AUG %%%%%%%%%

\prop{InhOptBase}{Choose in the overridden function whether to inherit}
 
A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a base class the option to choose whether a particular function contract assertion should be inherited by any overriding functions or not.

If \tcode{InhDefault} is satisfied and inheriting function contract assertions is the default, this property can be realised by adding syntax to opt out of inheritance on the overridden function. Conversely, if inheriting is not the default, we could add syntax to opt into inheritance. Either direction satisfies the use case for this property.

Consider TODO
% TD: TODO: use case

\prop{InhOptDerived}{Choose in the overriding function whether to inherit}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a derived class the option to choose whether the overriding function should inherit the overridden function's function contract assertions or not.

If \tcode{InhDefault} is satisfied and inheriting function contract assertions is the default, this property can be realised by adding syntax to opt out of inheritance on the overriding function. Conversely, if inheriting is not the default, we could add syntax to opt into inheritance. Either direction satisfies the use case for this property.

Consider TODO
% TD: TODO: use case




\prop{CallerOnlyPre}{Allow \tcode{pre} to be checked only when caller-facing}

TODO

\prop{CallerOnlyPost}{Allow \tcode{post} to be checked only when caller-facing}

TODO

\prop{CalleeOnlyPre}{Allow \tcode{pre} to be checked only when callee-facing}

TODO

\prop{CalleeOnlyPost}{Allow \tcode{post} to be checked only when callee-facing}

TODO



\subsubsection{Non-design requirements}

\prop{Wording}{Fully specified in C++ wording}

The proposed design should be fully specified in C++ wording that has been reviewed by at least one Core expert, and should have no known specification holes. This is a standard requirement for language proposals before they can be forwarded from EWG to CWG for wording review and inclusion in the C++ working paper. 

The motivation for this requirement is that otherwise, we cannot claim that a proposed design has been fully specified and understood.

\prop{ImplExp}{Implementation experience}

The proposed design should be implemented \emph{completely} in at least one major C++ compiler front-end such as GCC, Clang, MSVC, or EDG. We do not require that the implementation has been upstreamed into the main branch of that compiler and shipped to users; an implementation on a dev branch is sufficient. However, we do require that the implementation is freely available to users in some form, for example by publishing the source code of the implementation or by making the branch in question available on Compiler Explorer.

The motivation for this requirement is that only actual implementation experience is acceptable proof of implementability. As long as a design only exists as a ``paper exercise'', even with wording, it is still possible that we overlooked some significant issues with that design.

% TD: TODO: we do not necessarily need this here, we can have it instead in the place where we discuss which designs fulfil which requirement
%If only an incomplete implementation of the design is available, or if the implementation is feature-complete but has significant unresolved issues, we consider the property having been met only partially. Similarly, if an implementation of an analogous design is available for a different programming language, we consider  the property having been met only partially, as programming languages such as Eiffel, D, and Ada are sufficiently different from C++ that proof of implementability in one language does not necessarily constitute proof of implementability in another.


% TD: specification existence?

\section{Design space}
\label{designs}

TODO

\section{Evolution graph}
\label{evolution}

TODO

\section{Conformance matrix}
\label{matrix}

TODO

\section{Decision tree}
\label{tree}

TODO

\section{Conclusion}
\label{conclusion}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
%Thanks to Oliver Rosten for his review of the paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}

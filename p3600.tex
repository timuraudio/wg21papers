\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}
\cftsetindents{paragraph}{1.02in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%PROPERTIES

% Macro to define custom subsubsubsections for properties
\newcommand{\prop}[2]{
  \paragraph*{\tcode{#1}: #2}
  \refstepcounter{paragraph}
  \label{#1}
  \addcontentsline{toc}{paragraph}{\tcode{#1}: #2}
  \mbox{}\vspace{0.5em} % hack to force the heading to not be run-in
  \nopagebreak[4]
}

% Macro to refer to properties
\newcommand{\propref}[1]{\hyperref[#1]{\tcode{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on virtual functions: \\ a principled design approach}
\author{
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\
John Lakos \small(\href{mailto:jlakos@bloomberg.net}{jlakos@bloomberg.net}) 
% TD: TODO: get Ville on board?
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3600R0 \\
Date: &2025-08-25 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we present a comprehensive analysis of the design space for supporting function contract assertions (\tcode{pre} and \tcode{post}) on virtual functions in C++. We begin by identifying a number of desirable properties that such a language feature should exhibit. We survey existing and proposed approaches and introduce a framework for classifying them according to a small number of key design decisions. For each decision, we examine its impact on the extent to which the desirable properties can be achieved. We find that no design achieving all desirable properties is possible. We identify three candidate designs that realise different, meaningful subsets of these properties. We distill the choice between these candidate designs down to two design decisions with different tradeoffs. We conclude with a recommendation for a concrete design that seems to offer the best set of tradeoffs overall.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\tableofcontents*
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\subsection{Motivation and context}

Contract assertions (\cite{P2900R14}) are a major new facility in C++26. A key feature of this facility are \emph{function contract assertions}: \tcode{pre} and \tcode{post}. This feature allows expressing
% TD: I omitted the "the" from this sentence here because they only allow expressing a subset of the full set of preconditions and postconditions, so saying "the preconditions and postconditions" would be technically incorrect, however explaining why that is the case (or even saying something like "a subset of" here) feels like a distraction.
preconditions and postconditions of a function directly in C++ code, and optionally checking those conditions at runtime to identify and mitigate program defects, in a configurable and scalable fashion. 

Unlike assertion statements (\tcode{contract_assert}) or pre-C++26 macro-based assertions, function contract assertions are a part of the function's \emph{declaration} and are thus readily found by humans, compilers, IDEs, and static analysis tools without having to inspect the function's definition. 

However, a major limitation of the initial feature set in C++26 is that \tcode{pre} and \tcode{post} cannot be placed on a \emph{virtual} function; doing so renders the program ill-formed. This limitation exists due to ongoing disagreements in WG21 regarding the desired behaviour of \tcode{pre} and \tcode{post} on virtual functions that could not be resolved in the C++26 timeframe.

At the same time, virtual functions are widely used in C++ today. Many codebases and popular libraries rely on runtime polymorphism as a key aspect of their design. Therefore, to ensure a successful adoption of contract assertions across the C++ ecosystem, we must add meaningful and user-friendly support for \tcode{pre} and \tcode{post} on virtual functions (as pointed out in \cite{P3173R0}).

In this paper, we consider everything we have learned since the adoption of \cite{P2900R14} and undertake a new attempt at resolving the existing disagreements. The goal of this paper is to find a design for this feature that suits the needs of the C++ community and can get consensus in WG21.

\subsection{Prior art}

\subsubsection{Other programming languages}

Other popular programming languages, such as C\#, Java, and Python, offer assertions only as a library feature,\footnote{For C\# and Java, there exist language extensions that implement function contract assertions: Microsoft Code Contracts and the Java Modeling Language (JML), respectively. Neither of these facilities enjoys significant use today. Microsoft Code Contracts is officially deprecated. JML had some influence in the 2000s but is nowadays restricted to academic contexts; the tooling for it is somewhat arcane and difficult to install and use.} and as such do not offer true function contract assertions\footnote{To aid understanding, throughout this paper we use the terminology of the C++ Standard (such as overriding function, overridden function, function contract assertion, etc.) for analogous concepts in other programming languages, even though in many cases the users of those languages would choose different terminology.} that could meaningfully integrate with the  dynamic dispatch mechanisms in those languages. However, there is a small number of less popular programming languages that offer both true function contract assertions and dynamic dispatch as a language feature: Eiffel, D, and Ada. In these languages, function contract assertions and virtual functions can be composed in a meaningful way.

Eiffel, released in 1986, was the first programming language that allowed placing precondition and postcondition assertions on function declarations. In Eiffel, such assertions are spelled with \tcode{requires} and \tcode{ensures}, respectively. Eiffel was developed in conjunction with the Design by Contract (DbC) paradigm by Bertrand Meyer. Its design closely follows that paradigm.

In particular, Eiffel by construction enforces the constraint that in an overriding function, preconditions can only be widened and postconditions can only be narrowed. This is achieved by using a conjunction (via OR) of the precondition assertions and a disjunction (via AND) of the postcondition assertions of the overriding function and all functions in the inheritance hierarchy overridden by it.

The D programming language, released in 2001, offers function contract assertions since its inception. Precondition and postcondition assertions are spelled with \tcode{in} and \tcode{out} blocks, respectively. For virtual functions, D's design follows the Eiffel paradigm of OR-ing precondition assertions and AND-ing postcondition assertions across an inheritance hierarchy. However, there are also some notable differences in the detail.

The Ada programming language added the feature in Ada 2012. Ada seems to be the only language with true function contract assertions that enjoys a significant degree of active use in production code today (albeit it is still a niche language, primarily used in safety-critical and mission-critical industries such as aerospace, defence, transportation, and medical systems).

Ada's design for function contract assertions on virtual functions is particularly complex. The default syntax, \tcode{Pre} and \tcode{Post} respectively, corresponds to so-called \emph{specific} precondition and postcondition assertions. However, adding the \tcode{Class} attribute turns them into so-called  \emph{class-wide} precondition and postcondition assertions, \tcode{Pre\textquotesingle Class} and \tcode{Post\textquotesingle Class} respectively, with entirely different and rather unique semantics. Any given function can have both flavours of function contract assertions applied to it simultaneously.

A more detailed description of these historic designs, and how they could be applied to C++, can be found in Section~\ref{designs} of this paper.

The ability to express the contract of a function in code also exists in a number of academic research languages; Dafny and Spec\# are notable examples. However, the contract facilities in these languages are designed primarily for static correctness proofs rather than runtime checking. As a consequence, they are of a very different nature than the contract facility in C++26. The same is true for the experimental contracts facility in Kotlin. There also exists an experimental contracts facility for Rust that is realised via procedural macros; however, it does not seem to be integrated with Rust's mechanism for dynamic dispatch (trait objects). In this paper, we therefore do not consider applying these designs to C++.

\subsubsection{C++ proposals}

The first proposal for adding a contracts facility to C++ \cite{N1613} was directly inspired by the D language and therefore proposed the same design as realised in D: precondition and postcondition blocks that are OR-ed and AND-ed, respectively, across an inheritance hierarchy. The next revision, \cite{N1669}, changed this to OR-ing preconditions but enforcing that postconditions are the same across the entire hierarchy.
%, with the motivation that weakening postconditions is “useless in practice since the user cannot take advantage of the weaker precondition by performing a downcast.”
% TD: TODO: This motivation does not need to be in this overview; mention it somewhere else.
This proposal was revised a few more times, but ultimately did not succeed in WG21; the last revision was \cite{N1962}.

The second proposal for a contracts facility \cite{N3604} proposed contract assertions as a library feature, in the form of macros inside the function body. Therefore, it did not have true function contract assertions that could interact with dynamic dispatch. This proposal, too, did not succeed in WG21; the last revision was \cite{N4378}).

Following the abandonment of the second proposal, many different design options were explored in various papers. \cite{N4110} and \cite{P0147R0} argued in favour of the established DbC principle that preconditions should not be strengthened and postconditions should not be weakened. On the other hand, \cite{P0247R0} argued that inheriting checks on virtual functions, or requiring that checks on base class virtual interfaces match overriders ``does not work'', and that allowing an overriding function to both widen and narrow the preconditions of the overridden function might make sense because not everyone will want to call a function through the same interface.

\cite{N4415} and \cite{P0287R0} proposed a more conservative design than in previous proposals or in Eiffel, D, and Ada: virtual functions are constrained to have the same sequence of function contract assertions across the entire inheritance hierarchy. In an overriding function, the function contract assertion sequence of the overridden function can be either repeated or omitted (i.e., inherited implicitly); if it is repeated, it must be ODR-identical. \cite{P0380R0} made this design even more restrictive by requiring that the sequence be repeated on every overriding function; however, this restriction was rolled back again in \cite{P0380R1}. This was retained throughout C++2a Contracts (\cite{P0542R5}), which were adopted for the C++20 Working Draft and then removed again (\cite{P1823R0}).

After the failure of C++2a Contracts and the establishment of SG21, proposals continued to flip-flop between these two designs: \cite{P2388R4} made repeating the sequence on an overriding function optional, and \cite{P2521R5} made it mandatory again. \cite{P2954R0} added yet another variation: repeating the function contract assertion sequence on an overriding function was neither optional nor required but actually ill-formed; the sequence was always inherited implicitly. This design was approved by SG21.

However, after more investigation, implicit inheritance of the contract was found to be problematic (see \cite{P2932R3} Section 3.4). SG21 decided that, given the many concerns and disagreements over how function contract assertions should work on virtual functions, consensus on a comprehensive
solution could be deferred to a future extension, and virtual function support was thus removed
entirely from the proposal. This design was forwarded to EWG and LEWG.

However, in \cite{P3173R0}, a major compiler vendor stated that, given the importance and pervasive use of virtual functions in C++, a contracts facility that fails to support efficient use with virtual functions is inadequate for standardisation. It seemed unlikely at that point that EWG would adopt a contracts facility without support for virtual functions.

This led to the development of a new design for virtual function support in \cite{P3097R0} that resolved the known issues of previous designs. This design removed contract inheritance and introduced the notion of caller-facing and callee-facing function contract assertions. A counterproposal with yet another new design based on contract inheritance was made in \cite{P3169R0}. SG21 carefully considered all design options known at the time and forwarded the design in \cite{P3097R0} to EWG. This design was approved by EWG and incorporated into the C++26 proposal.

However, following this decision, concerns were raised in \cite{P3506R0} and in \cite{P3573R0} that the caller/callee model from \cite{P3097R0} that had been approved by EWG was a departure from the established DbC model; that it had insufficient deployment and usage experience in the field; and that it was too complex. A rebuttal paper \cite{P3506R0} argued that the caller/callee model is the most appropriate design for C++ and should be retained. EWG did not manage to resolve this disagreement in the C++26 timeframe and instead decided to ship contract assertions in C++26 without support for virtual functions.

A more detailed history of function contract assertions on virtual functions in C++, including poll results and references to all relevant papers, can be found in \cite{P2899R1} Section 3.3.2.

\subsection{Methodology}

The goals of this paper are twofold: to identify the design for supporting \tcode{pre} and \tcode{post} on virtual functions that best satisfies the needs of the C++ community, and to facilitate establishing consensus in WG21 in favour of such a design. To achieve these goals, we analyse the available design space as exhaustively and objectively as possible. Our analysis follows the method for finding consensus on technical design questions developed in \cite{P3099R0}. This method is an evolution and adaptation of the Principled Design method developed in \cite{P3004R0} and \cite{P3005R0}.

We begin by identifying the desirable properties that a design for this language feature should exhibit (Section~\ref{properties}). We take into account all relevant properties that were articulated by members of WG21. We describe each property as precisely as possible, along with motivation for and against, use cases, and code examples. To minimise bias, we treat all properties equally and do not attempt to rank them by importance or other criteria.

We then identify all known design options for this feature (Section~\ref{designs}), including all variations that have been shipped in other programming languages or proposed for C++ at some point. As a tool for efficiently navigating this design space, we introduce a framework for classifying all possible designs according to a small set of key design decisions, as well as a scheme to refer to each possible design with an unambiguous identifier that encodes this set of decisions.

We proceed by constructing an \emph{evolution graph}, i.e., determining which design options can be obtained by future evolution of other, more conservative design options (Section~\ref{evolution}). Such an evolution graph is useful in case the committee fails to get consensus one way or another between two mutually exclusive design options. In this case, we can fall back to the maximal common ancestor of both options in the evolution graph.

With this thorough mapping of the available design space, we conduct an analysis of how well each available design option satisfies the identified desirable properties (Section~\ref{matrix}). We visualise this analysis with a so-called \emph{conformance matrix}. 

In the final part of our analysis, we use the conformance matrix to identify the most promising candidate designs (Section~\ref{tree}). We distill the choice between these candidate designs down to a small number of binary design decisions between concrete tradeoffs (``do we prefer satisfying property A or property B?'') that can be polled in EWG. We conclude with a recommendation for a concrete candidate design that seems to offer the best set of tradeoffs overall (Section~\ref{conclusion}).


\section{Desirable properties}
\label{properties}

% TD: TODO: add a property that indirect calls where static and dynamic type are equal should have the same set of function contract assertions as direct calls.

% TD: TODO: add a property that pre(true) and post(true) should mean the same thing as nothing

\subsection{General approach and selection criteria}

In this section, we identify the desirable properties that a design for supporting \tcode{pre} and \tcode{post} on virtual functions should exhibit. We take into account all relevant properties articulated by members of WG21 (whether formally in papers or informally during meetings or on the committee mailing lists)  during discussions about this feature so far.

Each property is given a short unique identifier to easily refer to it later in the paper, for example \propref{ImplExp} for implementation experience. The entry for each property is structured as follows:
\begin{itemize}
\item \emph{Description}: A section describing each property as precisely as possible.
\item \emph{Motivation}: Known arguments for satisfying this property.
\item \emph{Countermotivation} (where applicable): Known arguments against satisfying this property; known incompatibilities with other properties.
\item \emph{Example} (where applicable): Code example(s) illustrating use cases and motivation for the property. We strive to provide realistic examples rather than ``toy code'' whenever possible. 
\end{itemize}
We follow the consensus-building method developed in \cite{P3099R0}; thus, we focus on data and objectively verifiable information rather than opinions, and do our best to minimise cognitive bias and value judgments when describing the desirable properties. In particular, we do not attempt to rank the listed properties by priority, relevance, or otherwise. 

Some of the listed properties were originally articulated as ``design principles that must be adhered to'',  ``very important use cases'', ``necessary conditions for successfully deploying the feature'', etc. For the purpose of this analysis, we carefully avoid such characterisations and instead treat all properties equally. For properties that are describing a use case, we avoid any claims of how common (or contrived) it is due to lack of data from real-world code bases backing up such claims.

In a number of cases, it may be controversial whether the motivation is sound, the use case is plausible, and the property in question is actually desirable. In these cases, we strive to adopt a neutral position and limit ourselves to describing the property and the known arguments for and against supporting it.

We only include properties for which we can objectively and unambiguously answer the following question: does a given language design for supporting \tcode{pre} and \tcode{post} on virtual functions exhibit this property? We therefore deliberately exclude properties that are vague, subjective, and/or cannot be measured directly, such as teachability or intuitiveness of a particular design. We also do not include properties that could in principle be measured, but for which no concrete, measurable criterion is evident and no such criterion has been proposed by the proponents of that property.

For example, \cite{P3573R0} mentions the concern that \tcode{pre} and \tcode{post} on virtual functions ``have not been tried at scale''. However, the paper does not specify a measurable criterion for what would constitute sufficient ``scale''. We are happy to include this property in a future revision of this paper if the authors can provide a measurable criterion (e.g., a particular number of lines of deployed code that they consider sufficient deployment experience). Similarly, \cite{P3506R0} listed as a concern that the design proposed in \cite{P3097R0} was ``too complex''. However, since the author did not indicate how the complexity of any possible design could be measured, or what degree of complexity would be acceptable, we exclude this concern from our analysis.

Importantly, we are not suggesting that properties like teachability or complexity are not relevant for language design; quite the opposite. However, since they are inherently subjective, we do not consider them directly alongside other properties in our analysis. Instead, we consider more specific, objectively measurable properties that contribute to the teachability and complexity of a design.

\subsection{List of properties}


\subsubsection{Standardisation requirements}

The following properties describe general requirements that any proposal for supporting \tcode{pre} and \tcode{post} on virtual functions should meet in order to be considered for inclusion in the C++ Standard.

\prop{Wording}{Fully specified in C++ wording}

\emph{Description:}

The proposed design should be fully specified in C++ wording that has been reviewed by at least one Core expert, and should have no known, unresolved specification issues.

\emph{Motivation:}

 This is a standard requirement for language proposals before they can be forwarded to CWG for wording review and inclusion in the C++ working paper.  Without this requirement, we cannot plausibly claim that a proposed design has been fully specified and understood.

\prop{ImplExp}{Implementation experience}

\emph{Description:}

The proposed design should be implemented \emph{completely} in at least one major C++ compiler front-end (GCC, Clang, MSVC, or EDG). We do not require that the implementation has been upstreamed into the main branch of that compiler and shipped to users; an implementation on a development branch is sufficient. However, we do require that the implementation is freely available to users in some form, for example by making the source code of that development branch public or by making that compiler version available on Compiler Explorer.

\emph{Motivation:}

Only actual implementation experience is sufficient proof of implementability. As long as a design only exists as a ``paper exercise'', even with wording, it is still possible that we overlooked some significant issues with that design that would render it non-viable.

\subsubsection{Design constraints}

The following properties describe design constraints that may be placed on the behaviour of \tcode{pre} and \tcode{post} on virtual functions. Some of these constraints match existing practice in other programming languages; others are motivated by the desire to avoid complexity and non-locality; others yet others aim to facilitate the deployment of a design for \tcode{pre} and \tcode{post} on virtual functions to C++ code bases at scale.

%-------------------------------------------------------------------------------
\prop{SubstPr}{Substitution principle}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should follow the \emph{substitution principle}, which stipulates that objects of a base class should be replaceable with objects of a derived class without affecting the correctness of the program. 

% TD: TODO: this description is too vague. It isn't explaining how this principle should relate specifically to contract assertions (which represent only a subset of the actual contract). However, I am having a really hard time formulating that! Maybe the fact that they represent only a subset is actually a piece of countermotivation here? But I am having a hard time formulating that as well.

\emph{Motivation:}

The substitution principle is a well-established paradigm in object-oriented programming. It ensures that derived classes remain true to the behaviour and expectations of their base classes, allowing the user to use them interchangeably without introducing bugs. This is particularly important in situations where external clients will depend on contracts, such as for public APIs, libraries, and frameworks that follow object-oriented programming. Applying this paradigm to \tcode{pre} and \tcode{post} on virtual functions facilitates robust and reliable object-oriented designs.

\emph{Countermotivation:}

There are use cases for contract assertions (see properties \propref{NarrowPre}, \propref{WidenPostIn}) that are not compatible with the substitution principle. A language design that requires \tcode{pre} and \tcode{post} to obey the substitution principle would make the addition of function contract assertions to a codebase that relies on these use cases difficult or impossible.

Further, enforcing the substitution principle statically does not seem feasible for a language like C++ because it would require subsumption proofs on arbitrarily complex expressions (see \cite{P3165R0}). Thus, the only known  strategy for enforcing the substitution principle is to do so dynamically by OR-ing precondition assertions and AND-ing postcondition assertions across the inheritance hierarchy like in Eiffel or D. However, this strategy actually enforces an even stronger set of constraints, which has a number of implications (see \propref{MeyerDbC}).

\emph{Example:}

Consider the following correct program:
\begin{codeblock}
struct Base {
  virtual int f(int i)
    pre (i >= 0)
    post (r: r <= i);
};

void test(Base& b) {
  std::print(b.f(42));
}
\end{codeblock}
The call to \tcode{Base::f} in function \tcode{test} is correct, i.e., it satisfies its precondition that the integer passed in must be nonnegative. This is verified by the absence of a precondition assertion violation. If the call to \tcode{Base::f} returns without a postcondition assertion violation, then \tcode{Base::f} is also implemented correctly, i.e., it satisfies its postcondition. The program can therefore rely on  the printed value never being greater than 42.

A function that overrides \tcode{Base::f} but has narrower precondition assertions would break the correctness of the call and thus violate the substitution principle. Consider an override that can only handle even numbers as input:
\begin{codeblock}
struct Derived1 : Base {
  int f(int i) override
    pre (i % 2 == 0);
}
\end{codeblock}
In this example, \tcode{Derived1::f} specifies a precondition assertion that may fail on inputs that are considered correct for \tcode{Base::f} (odd nonnegative integers). This precondition assertion should therefore either not compile, or its semantics should be such that failing it is not considered a contract violation, otherwise \tcode{Derived1} is not substitutable for \tcode{Base}.

Further, a function that overrides \tcode{Base::f} but has wider precondition assertions for inputs that are considered correct for \tcode{Base::f} would break the expectations of the calling code and thus also violate the substitution principle. Consider:

\begin{codeblock}
struct Derived2 : Base {
  int f(int i) override /* ... */ {
    return 42;
  }
}
\end{codeblock}

In this example, \tcode{Derived2::f} is not substitutable for \tcode{Base::f} as it is possible to pass a nonnegative number (thus satisfying the precondition assertions of \tcode{Base::f}) but get a number back that is larger than the number passed in (thus failing the postcondition assertions of \tcode{Base::f}). The design should therefore ensure that when the dynamic type of the parameter passed into  \tcode{test(Base\&)} is \tcode{Derived2}, and \tcode{Derived2::f} is implemented as above, such an implementation will be treated as incorrect and result in a postcondition assertion violation. Such a design may or may not constrain which function contract assertions are allowed in \mbox{\emph{/* ... */}}.

% TD: TODO: Everything from here until the end of this property is duplicated either in MeyerDbC or in WidenPostOut; re-think where this belongs!

Note that widening preconditions and narrowing postconditions in the overridden function do not violate the substitution principle. Note further that when an overriding function has wider preconditions than the overridden function (assuming the chosen language design allows this), and is called \emph{outside} of the overridden function's preconditions (i.e., in a way that is a correct call of the overriding function but would not be a correct call of the overridden function), it is not necessary to satisfy the overridden function's postconditions. Consider:

\begin{codeblock}
struct Derived3 {
  int f(int i) override {
    return std::abs(i);
  }
};
\end{codeblock}
In this example, \tcode{Derived3::f} operates on a wider domain than \tcode{Base::f} as it is possible to pass a negative integer. In this case,  \tcode{Derived3::f} does \emph{not} satisfy the postcondition of \tcode{Base::f} as the return value will be greater than the value passed in. However, \tcode{Base} is still substitutable by \tcode{Derived3} because \tcode{Derived3::f} will always satisfy the postcondition of \tcode{Base::f} when given a nonnegative integer.

\prop{MeyerDbC}{Bertrand Meyer's ``Design by Contract'' paradigm}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should follow Bertrand Meyer's Design by Contract (DbC) paradigm, which stipulates that in an overriding function, preconditions can only be widened and postconditions can only be narrowed, but not vice versa.

\emph{Motivation:}

Following the DbC paradigm when  specifying the semantics of \tcode{pre} and \tcode{post} on virtual functions is a well-known approach to enforcing the substitution principle, and is existing practice in the Eiffel and D programming languages with decades of implementation and usage experience.

\emph{Countermotivation:} 

The DbC paradigm (``widen preconditions, narrow postconditions'') is \emph{not} just an application of the substitution principle to contract checking (even though that is a common misconception), but imposes additional constraints. In particular, a function that has wider postconditions than the function it overrides if and only if is called \emph{outside} of the overridden function's preconditions satisfies \propref{SubstPr}, but does not satisfy \propref{MeyerDbC}. 

Thus,  in addition to those use cases that are not compatible with any form of enforcing the substution principle (see properties \propref{NarrowPre}, \propref{WidenPostIn}), there are more use cases for contract assertions that are not compatible with the DbC paradigm (see properties  \propref{WidenPostOut} and \propref{WidenPostMult}).

Further, the established strategy for enforcing the DbC paradigm --- OR-ing precondition assertions and AND-ing postcondition assertions across the inheritance hierarchy like in Eiffel or D --- is not compatible with satisfying the \propref{FailFast} property.

% TD: TODO: check if there are any more properties unsatisfiable with DbC regardless of the exact design chosen!

\emph{Example:}

Consider again the example from \propref{SubstPr} above. Function \tcode{Derived3::f} in that example satisfies property \propref{SubstPr}, i.e., it is fully substitutable for \tcode{Base::f}. However, it does not satisfy property \propref{MeyerDbC}, because it widens the overridden function's postconditions. Following DbC, the function \tcode{Derived3::f} as written should therefore either not compile, or its semantics should be such that returning a number from this function that is larger than the number passed in will cause a postcondition assertion violation.

\prop{FailFast}{Fail immediately on contract violation}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should continue to ensure, as C++26 Contracts do today, that the user can configure their program to fail immediately when any individual contract assertion fails. When a function contract assertion on a virtual function is evaluated with a checked semantic and that check fails, the program should immediately proceed to handling the contract violation and/or terminate, and not attempt to first evaluate other function contract assertions. In particular, precondition assertions from different functions should not be OR-ed across the inheritance hierarchy before determining whether a contract violation occurred.

\emph{Motivation:}

Eiffel, which OR-s precondition assertions across the inheritance hierarchy, is a memory-safe language, while C++ is not. Unlike in Eiffel, in C++ continuing past any individual failed assertion check, regardless of where in an inheritance hierarchy it occurs, is potentially unsafe and may lead to undefined behaviour and security vulnerabilities. A design for supporting \tcode{pre} and \tcode{post} on virtual functions should not introduce new opportunities for such vulnerabilities.

\emph{Example:}

Consider a virtual function with a precondition assertion as follows:

\begin{codeblock}
struct Y : X {
  virtual void usePtr(void* ptr) 
    pre (ptr != nullptr);
}
\end{codeblock}

Whenever the assertion \mbox{\tcode{ptr != nullptr}} is evaluated with the \emph{enforce} or \emph{quick-enforce} semantic, the program should be terminated (with or without calling the contract-violation handler first, depending on the chosen semantic). The program should not attempt to evaluate other function contract assertions specified on functions overriding (or overridden by) \tcode{Y::usePtr} past the failed check as this may be unsafe:

\begin{codeblock}
struct Z : Y {
  virtual void usePtr(void* ptr) 
    pre (ptr->useIt());
}
\end{codeblock}

\prop{VacuousTrue}{Vacuousness of \tcode{pre(true)} and \tcode{post(true)}}

\emph{Description:} 

On the declaration of a virtual function, \tcode{pre(true)} and \tcode{pre(false)} should always be vacuous, i.e., they should be equivalent to not specifying any precondition or postcondition assertion at all on that declaration. Whether or not \tcode{pre(true)} and \tcode{pre(false)} are present should not change which function contract assertions will be evaluated. In particular, adding \tcode{pre(true)} or \tcode{pre(false)} to a function declaration should not cause other, non-vacuous contract assertions to no longer be evaluated.

\emph{Motivation:}

This design constraint is consistent with the vacuousness of \tcode{pre(true)} and \tcode{post(true)} on non-virtual functions, as well as the vacuousness of \tcode{assert(true)}, \mbox{\tcode{contract_assert(true)}}, \mbox{\tcode{static_assert(true)}}, \tcode{requires(true)}, etc. in C++ today. Further, if we could not rely on this constraint being satisfied, this could lead to surprising behaviour in cases where the presence of a function contract assertion is conditional.

\emph{Example:}

Consider a function that takes a file path as a parameter. On Windows, there is historically a strict limit on the length of such paths; however, this limit does not exist on other platforms. We could make the contract predicate platform-dependent:

\begin{codeblock}
#ifdef _WIN32
  #define PATH_OK(path) path.size() < MAX_PATH 
#else
  #define PATH_OK(path) true
#endif

Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
    pre(PATH_OK(path)) {
      // ...
};
\end{codeblock}

Alternatively, we could conditionally macro out the entire precondition assertion:

\begin{codeblock}
Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
#ifdef _WIN32
    pre(path.size() < MAX_PATH)
#endif
  {
    // ...
};
\end{codeblock}

Both programming styles seem reasonable in cross-platform code. It would arguably be surprising to users if a design for \tcode{pre} and \tcode{post} on virtual functions would introduce cases where they lead to different contract assertions being evaluated.

\prop{BaseIndep}{\tcode{pre} and \tcode{post} should be usable independent of base}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow a client of a virtual function to override that function in a derived class, add function contract assertions to the overriding function, and have those assertions evaluated, even if the base class is written against an older C++ Standard and does not use contract assertions at all.

\emph{Motivation:}

A base class and derived class may be located in different, independent components owned by different people or companies. A client of the base class may be deriving from it and overriding some virtual functions, yet unable to modify the base class.

In order to be deployable in such scenarios, a design for supporting \tcode{pre} and \tcode{post} on virtual functions should ensure that the client can add function contract assertions to overriding functions, and have those checked, even if the base class does not specify any function contracts at all (for example, because the component that owns the base class predates the addition of contract assertions to C++).

% TD: TODO: we may want to beef up this motivation

\emph{Example:}

Consider a GUI framework with a \tcode{Widget} base class as follows:

\begin{codeblock}
class Widget {
public:
  // Preconditions:   
  // \phantom{xxx}\tcode{child} points to a \tcode{Widget};
  // \phantom{xxx}\tcode{child->isValid()} is \tcode{true}; 
  // \phantom{xxx}\tcode{zOrder} is between -32768 and +32767.
  virtual void addChildWidget (Widget* child, int zOrder);
  
// ...
};
\end{codeblock}
This GUI framework is third-party code that we do not control and cannot modify. The function \tcode{Widget::}\allowbreak\tcode{addChildWidget} has preconditions, but those are not checked with function contract assertions as the code predates the availability of the feature.

In our own codebase, we have a framework of custom widget types, all inheriting from the \tcode{Widget} class above. For our own custom widget types at least, we would like to introduce precondition assertions for checking the preconditions:
\begin{codeblock}
class CustomWidget : public Widget {
public:
  void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767) 
  {
    // custom child/parent widget tracking logic here...
    Widget::addChildWidget(child, zOrder);
  }
}
\end{codeblock}

The precondition assertions of \tcode{CustomWidget::}\allowbreak\tcode{addChildWidget} should be evaluated whenever that function is called, without having to modify the \tcode{Widget} base class and despite the absence of precondition assertions in that base class.

\prop{NoRemoteBreak}{Avoid remote code breakage}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the author of a base class to add function contract assertions to a virtual function without breaking correct uses of derived classes in remote client code.

\emph{Motivation:}

A base class and derived class may be located in different, independent components owned by different people or companies. A base class does not in general know about or control clients deriving from it. A derived class in a different component may be overriding a function in the base class and have wider preconditions than the base class (see also \propref{WidenPre}), for example accept a wider range of input values than the overridden function does. Introducing function contract assertions to the overridden function that check the preconditions of \emph{that} function should not break correct uses of overriding functions with wider preconditions.

% TD: TODO: we may want to beef up this motivation

% TD: TODO: we may want to have a terminology section at the front where we clarify the difference between "preconditions" and "precondition assertions"

\emph{Example:}

Consider again the GUI framework from property \propref{BaseIndep}. As the owners of the base class \tcode{Widget}, we might want to introduce precondition assertions for checking the preconditions of \tcode{Widget::}\allowbreak\tcode{addChildWidget}, and roll out these assertions to clients that have a recent enough compiler to take advantage of them: 

\begin{codeblock}
class Widget {
public:
  virtual void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767);
}
\end{codeblock}

At the same time, one of our clients may have a widget type in their code base that can handle a wider range of values for \tcode{zOrder} just fine, and they may be using this type in production:

\begin{codeblock}
class SuperWidget : public Widget {
  // this version can handle any values for \tcode{zOrder}!
  void addChildWidget(Widget* child, int zOrder) override {
    // ....
  } 
}

class MyWindow : public SuperWidget;
class MyButton : public SuperWidget;
// ...

void drawMyApp() {
  myWindow.addChildWidget(myButton, 99999);
}
\end{codeblock}
As long as the client uses the \tcode{SuperWidget} interface instead of the base \tcode{Widget} interface for their widgets above, their program is correct --- there is no contract violation. Adding the above function contract assertions to \tcode{Widget::}\allowbreak\tcode{addChildWidget} should not break the client's correct program by introducing a precondition assertion violation to it.


\prop{NoRemoteAss}{Do not evaluate remote assertions}

\emph{Description:}

The set of function contract assertions evaluated during a virtual function call should be limited to the function contract assertions declared on the functions directly participating in that call: the statically called function and the function actually executed (i.e., chosen by dynamic dispatch). 

\emph{Motivation:}

When debugging a C++ program, being able to quickly identify the source of a problem is key to productivity. When a virtual function call causes a contract assertion to fail, it is important to be able to quickly identify the offending assertion.

If a virtual function call evaluates function contract assertions declared on functions other than those directly participating in the offending call (e.g., on overridden functions further down the inheritance hierarchy), those assertions may be very difficult to locate. This is particularly true for large codebases where inheritance hierarchies can be very complex, and base and derived classes can be spread across different components of the codebase (including third-party code).

\emph{Countermotivation:}

This property conflicts with inheriting function contract assertions, whether this happens by default (\propref{InhDefault}) or explicitly (\propref{InhBase}, \propref{InhDerived}). Further, the \emph{members} of a base class are already inherited automatically in every derived class; this does not seem to cause problems in practice. Finally, concerns regarding efficiently navigating a codebase could be addressed via tooling.

\emph{Example:}

Consider a contract-violation handler that triggers a breakpoint:

\begin{codeblock}
void handle_contract_violation(const contract_violation& cv) {
    std::breakpoint(); // or just a manual breakpoint set in the IDE
}
\end{codeblock}

Now, let us assume we trigger this breakpoint while debugging a C++ program. In order to understand which contract assertion failed, we use our debugger to walk up the stack.  One stackframe up, we see a function with a precondition assertion:

\begin{codeblock}
int GzipCompressionBuffer::writeChars(char* chars, size_t count)
pre (chars != nullptr) {   // <---
  // some code
}
\end{codeblock}

Another stackframe up, we see the callsite:

\begin{codeblock}
void readAppState(InputBuffer& ib) {
  // some code
  ib.writeChars(data, n);   // <---
}
\end{codeblock}

Now, we inspect the function contract assertions of \tcode{GzipCompressionBuffer::}\allowbreak\tcode{writeChars} and those of \tcode{InputBuffer::}\allowbreak\tcode{writeChars} to determine what went wrong. It would be unfortunate if we would also have to consult the function contract assertions of the corresponding functions in every single other class that forms part of that inheritance hiearachy, for example \tcode{Buffer::}\allowbreak\tcode{writeChars} in some base class further up the hierarchy, or \tcode{CompressionBuffer::}\allowbreak\tcode{writeChars} in some intermediate class.


\subsubsection{Single inheritance use cases}

The following properties describe the ability of a design  for \tcode{pre} and \tcode{post} on virtual functions to support concrete use cases where a virtual function overrides at most \emph{one} other virtual function.

\prop{WidenPre}{Widening preconditions}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{widen} preconditions in an overriding function, i.e., to specify precondition assertions that are less strict than those specified on the overridden function, or even specify that there are \emph{no} precondition assertions on the overriding function. Whenever the overriding function is called \emph{directly} (i.e., it is the statically called function), those less strict precondition assertions should be evaluated instead of the overridden ones.

\emph{Motivation:}

A derived class should be able to extend the functionality of the base class and accept arguments that are designed to work with that extended functionality. This ability to widen preconditions in an overriding function is established practice in languages like Eiffel, D, and Ada, and does not compromise substitutability of the base class by the derived class. Contract checking in C++ should support this practice.

\emph{Example:}

Consider the following motivating use case from \cite{P0247R0}:
\begin{codeblock}
class Display {
public:
  virtual void post_message(std::string_view s)
     pre (is_ascii(s)) = 0;
};

class XDisplay : public Display {
   // ...
public:
  void post_message(std::string_view s) override
    pre (is_utf8(s));
 };
\end{codeblock}
In this example, we have a base class facility that accepts ASCII strings to display. However, the derived implementation accepts UTF-8. A program that does not rely on the \tcode{Display} base class interface, but uses the \tcode{XDisplay} class directly should be able to generate and post both ASCII and UTF-8 messages. In other words, the following program should not cause a contract violation when executed:
\begin{codeblock}
void test(XDisplay& xd) {
  xd.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}
In this program, the statically called function is \tcode{XDisplay::post_message}, and the dynamic type is \tcode{XDisplay} (it could also be a type deriving from \tcode{XDisplay}). The overridden function \tcode{Display::post_message} is not called, therefore satisfying its narrower precondition that the input string must be ASCII is not relevant to the correctness of this program.

\prop{ChkPreCaller}{Checking caller-facing preconditions}

\emph{Description:}

In a virtual function call, the precondition assertions specified on the statically called function should be evaluated by default, regardless of which function will be selected by dynamic dispatch and what  precondition assertions are specified on that function.

\emph{Motivation:}

Calling a virtual function in a way that violates the statically called function's preconditions is an incorrect use of that interface, regardless of the dynamic type of the called object. This bug should be detectable by contract checking. Even if the dynamic type of the object has wider preconditions and would work correctly for such a call, that dynamic type is not known at the call site and can change in the future, therefore the call site cannot rely on it.

\emph{Example:}

Consider again the \tcode{Display} --- \tcode{XDisplay} inheritance hierarchy from property \tcode{WidenPre}. Let us slightly alter the \tcode{test} function such that it takes a reference to the base class \tcode{Display}:
\begin{codeblock}
void test(Display& d) {
  d.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}
The above program should cause a contract violation when executed, because it violates the preconditions of the statically called function (\tcode{Display::post_message}), even though  the dynamic type of the object referenced by \tcode{d} happens to be \tcode{XDisplay}, which means the function actually executed will be \tcode{XDisplay::post_message} and the preconditions of that function are satisfied (it can handle non-ASCII strings).

\prop{NarrowPost}{Narrowing postconditions}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} postconditions in an overriding function, i.e. to specify postcondition assertions that are more strict than those of the overridden function. Whenever the overriding function is executed, its stricter postcondition assertions should be evaluated (regardless of what the statically called function is or what its postcondition assertions are). Failure should cause a contract violation, even if all postcondition assertions of the overridden function are satisfied.

\emph{Motivation:}

Subclasses that have compatible contracts with their base class can often provide additional guarantees that the base class does not require of all potential subclasses. Being able to express these additional guarantees in the form of postcondition assertions on the overridden function benefits users, compilers, and tools. Failing to meet these additional guarantees is a bug in the subclass that should be detected by contract checking. Importantly, this is true even when the direct caller does not directly depend on that guarantee because it is using the base class interface.

The ability to narrow postconditions in an overriding function is established practice in languages like Eiffel, D, and Ada, and does not compromise substitutability of the base class by the derived class. Contract checking in C++ should support this practice.

\emph{Example:}

Consider an abstract class that is used to generate sequences of integers through a virtual function:

\begin{codeblock}
struct Generator {
  virtual int next() = 0;
};
\end{codeblock}
Many different derived classes might be implemented that produce different sequences. A particularly simple implementation may always produce the same constant value, which can be specified by the user:
\begin{codeblock}
struct ConstantGenerator : Generator {
  void setValue(int value);
  int getValue(); 
  int next() override
    post (r: r == getValue());
}
\end{codeblock}
The above postcondition assertion is specific to the implementation of \tcode{ConstantGenerator::}\allowbreak\tcode{next()}. A violation of that postcondition assertion indicates a bug in the implementation of \tcode{ConstantGenerator}. Therefore, the following program should cause a contract violation when executed:
\begin{codeblock}
void test(Generator& gen) {
  std::print(gen.next());
}

int ConstantGenerator::next() override {
  return 0;  // dummy implementation  
} 

int main() {
  ConstantGenerator constGen;
  constGen.setValue(42);
  test(myGen);
}
\end{codeblock}


\prop{NarrowPre}{Narrowing preconditions}

\emph{Description:}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} preconditions in an overriding function, i.e., to specify precondition assertions 
 that are \emph{more strict} than those of the overridden function. Whenever the overriding function is executed (regardless of what the statically called function is), these more strict precondition assertions should be evaluated. Failure should cause a contract violation, even if all precondition assertions of the overridden function are satisfied.
 
 \emph{Motivation:}
 
Narrowing preconditions becomes necessary when usage of the derived class depends on adhering to additional constraints or setting up additional state (database connections, threads, etc.) that the base class does not depend on.  Such designs can often have favourable tradeoffs such as simplicity and performance.

While narrowing preconditions violates the substitution principle (\propref{SubstPr}) and Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}), such \emph{non-canonical} designs are correct and useful when unconditional substitutability of the base class by the derived class is not required or expected. These designs exist and are used in practice, especially in performance-critical or domain-specific systems and in situations where the same team controls the entire codebase and is aware of the expected usage patterns.

Often, the narrower preconditions of the overriding function can be guaranteed non-locally by designing the program accordingly. Thus, the derived class is substitutable for the base class in \emph{that} program (even if not for all possible usages of that inheritance hierarchy). Failure to establish the substitutability criteria at runtime is a bug (an incorrect usage of the derived class). A design for supporting \tcode{pre} and \tcode{post} on virtual functions that accommodates this use case enables users to leverage contract checking to detect such bugs. 

On the other hand, users may not be able to afford refactoring their existing codebase to adhere to the substitution principle or Design by Contract paradigm; instead, if C++ contract checking does not support their current design, they will simply not add contract assertions to their code.
 
 \emph{Example:}
 
Consider a base class for rendering an image:

\begin{codeblock}
class Image {
public:
  virtual void render() const;
};
\end{codeblock}

Now consider a derived class that renders the image on a GPU. This implementation is more efficient and powerful, however it requires the user to perform an additional initialisation step before the image can be rendered:

\begin{codeblock}
class GPUImage : public Image {
public:
  bool prepare() { 
    // upload data to GPU, handle errors...
    return readyToRender;
  }
  
  void render() const override
    pre (readyToRender);
};
\end{codeblock}

A program that ensures a successful call to \tcode{prepare} always happens before a call to \tcode{render} is correct; failure to do so is a bug that should be detectable by contract checking. 

To support this use case and diagnose incorrect use, the precondition assertion \mbox{\tcode{pre(readyToRender)}} would need to be well-formed, evaluated whenever \tcode{GPUImage::render} is executed, and trigger a contract violation in case of failure, even if the statically called function is \tcode{Image::render} and all preconditions of that functions are met.


\prop{WidenPostOut}{Widening postconditions outside of base contract}

\emph{Description:}

In addition to allowing widening preconditions in overriding functions (see \propref{WidenPre}), a design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function in cases where the overriding function is called outside of the overridden function's preconditions (but within its own preconditions).

\emph{Motivation:}

The need to widen postconditions arises when an overriding function operates on a larger domain than the function it overrides (i.e., it has wider preconditions). When the overriding function is called outside of the overridden function's preconditions (but within its own preconditions), there is no need to satisfy the overridden function's postconditions as the call in question would not be a correct use of the overridden function anyway (even though it is a correct use of the overriding function). The overriding function therefore can have wider postconditions for such outside-of-base-contract calls. Contract checking in C++ should support this scenario.

When widening postconditions in this way, the overriding function is still fully substitutable for the overridden function. Supporting this use case is therefore compatible with the substitution principle (\propref{SubstPr}). However, it is not  compatible with Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}).

\emph{Example:}

Let \tcode{Number} be a generic type that can represent real or complex numbers. Now, consider a type \tcode{Sqrt} that computes a real-number square root. The function \tcode{Sqrt::compute} requires a nonnegative real number as input, and returns another nonnegative real number as output. We can specify this contract using function contract assertions:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre(x.isReal() && x.realPart() >= 0)
    post(r : r.isReal() && r.realPart() >= 0);
};
\end{codeblock}

This implementation of square root might have a number of useful properties, such as computing the result very efficiently with hardware instructions. However, \tcode{Sqrt} is also a polymorphic type, so that the user can substitute other implementations of square root that have different tradeoffs.

Later on, we might add an implementation of square root to our codebase that can handle the entire complex plane and therefore drops the precondition and postcondition assertions of \tcode{Sqrt::compute}:

\begin{codeblock}
struct ComplexSqrt : public Sqrt {
  Number compute(const Number& x) override;
};
\end{codeblock}

This implementation may or ma use the more optimised real-numbers only \tcode{Sqrt}

When used as a \tcode{Sqrt}, which requires satisfying the preconditions of the overridden function \tcode{Sqrt::compute}, \tcode{ComplexSqrt::}\allowbreak\tcode{compute} gives clients the same guarantee that clients  expect from any implementation of \tcode{Sqrt}: if the user passes a nonnegative real number, they will get back a nonnegative real number. It may even internally use the base class implementation \tcode{Sqrt::compute} for this case. \tcode{Sqrt} is therefore fully substitutable by \tcode{ComplexSqrt}. Consider, for example, the following function that uses an instance of \tcode{Sqrt} to compute the fourth root of a given \tcode{Number}:

\begin{codeblock}
Number quadroot(Number value, const Sqrt& sqrt) {
  if (!value.isReal() || value.realPart() < 0) {
    throw std::domain_error("Must pass a nonnegative real number");
  }
  Value v = sqrt.compute( {value} ); // v is a nonnegative real number
  return sqrt.compute( {v} ); // preconditions satisfied 
}
\end{codeblock}

Client code such as this last line of \tcode{quadroot}, which invokes a virtual function through a base class interface, invariably depends on the postconditions of that base class interface. Thus, the postconditions of that base class should be checked when calling an object of derived class through a base class interface.

However, the implementation \tcode{ComplexSqrt} does not --- and cannot --- guarantee that it will return a nonnegative real number in \emph{all} cases. Importantly, such a guarantee is not necessary or expected when the preconditions of the base class are not met. When the function \tcode{ComplexSqrt::compute} is used directly, the calling code is not required to satisfy the preconditions of \tcode{Sqrt::compute} and can pass any complex number:

\begin{codeblock}
int main() {
  Number complexUnit = ComplexSqrt().compute(-1);
}
\end{codeblock}

Here, \tcode{ComplexSqrt::compute} correctly returns a value that is \emph{not} a nonnegative real number. This code should not cause a contract violation; the fact that \tcode{ComplexSqrt::compute} does not satisfy the postconditions of \tcode{Sqrt::compute} in this particular case is irrelevant to the correctness of the program.

\prop{WidenPostIn}{Widening postconditions inside base contract}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function. Whenever that overriding function is the statically called function, its wider postcondition assertions should be evaluated instead of the overridden function's postcondition assertions. However, if the overridden function is the statically called function, its narrower postcondition assertions should be evaluated, even if the overriding function is selected by dynamic dispatch.

\emph{Motivation}:

Widening postconditions even if the preconditions of the overriding function are met becomes necessary when the overriding function is not substitutable for the overridden function for all inputs, but \emph{is} substitutable for the overridden function for the particular inputs used. Often, additional information is available about how the polymorphic object will be put to use in particular circumstances, and such limited-use overrides can therefore be used correctly. Situations where such designs are used in practice include testing and mocking. 

This use case is the dual to \propref{NarrowPre}; it is another \emph{non-canonical} design that violates the substitution principle (\propref{SubstPr}) and Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}). Nevertheless, it is not necessarily incorrect. A design for supporting \tcode{pre} and \tcode{post} on virtual functions that accommodates this use case enables users to leverage contract checking to verify correct usage of such a derived class and identify bugs.

\emph{Example}:

Consider again the base class \tcode{Sqrt} from property \propref{WidenPostOut}. We might want to add an implementation of square root \tcode{IntOnlySqrt} that is extremely efficient for perfect square integers (1, 4, 9, ...) but returns -1 for other integers, thus violating the postcondition of \tcode{Sqrt::compute} for some inputs.

As another example, consider how mock types are used in a test suite. Imagine an algorithm that depends on a \tcode{Sqrt} implementation:

% TD: TODO: you need to make compute() const in all implementations above
\begin{codeblock}
Value sumSqrts(const std::vector<Value>& values, const Sqrt& sqrtFunction) {
  Value sum = 0;
  for (auto&& value : values)
    sum += sqrtFunction(value);
    
  return sum;
}
\end{codeblock}

Now, we might want to write unit tests to verify the correctness of \tcode{sumSqrts}, but without pulling in a fully functional \tcode{Sqrt} implementation. Instead, we can use a mocking strategy. The following generic mock function template can be set to expect any specified value as an argument for and return any specified value from the next call to \tcode{compute}:

\begin{codeblock}
template <typename Base>
void MockFunction : public Base {
  void setInput(const std::vector<Value>& expectedArguments);
  const std::vector<Value>& getInput() const;
  
  void setOutput(const Value& value);
  Value getOutput() const;
  
  Value compute(const std::vector<Value>& arguments) override
    pre (arguments == getInput())
    post (r: r == getOutput());
};
\end{codeblock}

With this mock template, we can write a unit test for \tcode{sumSqrts} as follows:

\begin{codeblock}
void testSumSqrts() {
  // verify that \tcode{sumSqrts} works correctly to sum a vector of 4s:
  std::vector<Value> values = {4, 4, 4, 4};
  MockFunction<Sqrt> mockSqrt;
  mockSqrt.setInput({4});
  mockSqrt.setOutput({2});
  
  ASSERT(8 == sumSqrts(values, testSqrt));
}
\end{codeblock}

The function \tcode{MockFunction<Sqrt>::compute} does not \emph{always} establish the postconditions of \tcode{Sqrt::compute} (i.e., it has wider postconditions), but it does so for the inputs used in the above unit test. The unit test is therefore correct.

In order to support this use case, the precondition and postcondition assertions of the overriding function  (which may be narrower and/or wider than those of the overridden function) should be evaluated whenever it is selected by dynamic dispatch, to diagnose bugs in the implementation of that overriding function. Simultaneously, the precondition and postcondition assertions of the overridden function should also be evaluated whenever it is the statically called function, to diagnose erroneous use of the base class interface as well as failure of the derived class to establish the postconditions that the call site may rely on. 

\prop{InhDefault}{Inherit function contract assertions by default}

\emph{Description}:

When a virtual function specifies function contract assertions, and is then overridden by another virtual function in a derived class, the overriding function should, by default, \emph{inherit} the function contract assertions of the overridden function. That is, if the overriding function does not specify its own precondition or postcondition assertions, those of the overridden function should apply, even if the overriding function is called directly and not through the overridden interface.
% TD: TODO: here and everywhere else, replace "directly" with something like "...is the statically called function and the overridden function is not used".

\emph{Motivation}:

Function contract assertions introduced in a base class --- to detect incorrect use, incorrect implementations, or guard against program failure and security vulnerabilities --- can be equally useful for a derived class, even if that derived class is used directly, not through the base class interface.  At the same time, authors of derived classes may fail to consider that they want and need those assertions on their own implementation. Thus, having those derived classes inherit the function contract assertions from the base class automatically is a ``safe default''.

\emph{Countermotivation}:

This property is incompatible with property \propref{NoRemoteBreak}. If function contract assertions are inherited by default, then a pre-existing override with no function contract assertions may break when function contract assertions are introduced to the overridden function. This may break a correct program if the overriding function has wider preconditions (\propref{WidenPre}) or wider postconditions (\propref{WidenPostIn}, \propref{WidenPostOut}) and the existing program exploits this. While it might be possible to work around such remote code breakage by explicitly opting out of inheritance (see \propref{InhOptDerived}), that requires a modification of the derived class, at which point it may be too late because the program already broke in production.
% TD: TODO: double check you don't have duplication between here and NoRemoteBreak.

\emph{Example}:

As an example for inheriting \emph{precondition} assertions by default, consider \tcode{QIODevice}, the base interface class of all I/O devices in the Qt framework.\footnote{Documentation available here: \url{https://doc.qt.io/qt-6/qiodevice.html}} This class has a number of virtual functions such as \tcode{readData} which take a raw data pointer to read bytes from. In a future version of Qt, one might want to add a precondition assertion to check that this pointer is not null:
\begin{codeblock}
class QIODevice {
public:
  virtual qint64 readData(char* data, qint64 maxSize)
    pre (data != nullptr) = 0;
};
\end{codeblock}
Now, if a user inherits from \tcode{QIODevice} and overrides \tcode{readData}, it would be useful if the same null pointer check automatically applied to their override, without them having to specify any function contract assertions themselves. Specifically, in the following program,
\begin{codeblock}
class MyIODevice : public QIODevice {
public:
  qint64 readData(char* data, qint64 maxSize) override {
    // my implementation...
  }
};

int main() {
  char* data = nullptr;
  qint64 size = 0;
  
  MyIODevice device;
  device.readData(data, size);
}
\end{codeblock}
the last line of \tcode{main} should trigger a contract violation when checks are enabled, even though the derived class \tcode{MyIODevice} is used directly rather than through the base class interface \tcode{QIODevice}. 

As an example for inheriting \emph{postcondition} assertions by default, consider a base class for different algorithms that choose one number out of a non-empty set of numbers:
\begin{codeblock}
struct NumberPicker {
  virtual int pick(const Array<int>& numbers)
    pre (!numbers.empty())
    post (r: numbers.contains(r)) = 0;
};
\end{codeblock}
Now consider different implementations of this base class:
\begin{codeblock}
struct FirstNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[0];
  }
};

struct RandomNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[rand() % numbers.size()];
  }
};
\end{codeblock}
We expect that any correct implementation of  \tcode{NumberPicker} must satisfy both the precondition and postcondition assertions of \tcode{NumberPicker::pick}. Therefore, those assertions should be checked even in cases in which the derived class interface is used directly, for example in a statically polymorphic context:
\begin{codeblock}
template <typename T>
int pickNumber(T& picker, const Array<int>& numbers) {
  return picker.pickNumber();
}

int rollDice() {
  return pickNumber(RandomNumberPicker(), {1, 2, 3, 4, 5, 6});
}
\end{codeblock}
In the above case, if the implementation of \tcode{RandomNumberPicker::pick} fails to satisfy the postcondition assertion of \tcode{NumberPicker::pick}, we should get a contract violation.

There are also examples where inheriting function contract assertions can lead to the kind of remote code breakage that property \propref{NoRemoteBreak} seeks to avoid. Consider an override of \tcode{QIODevice::}\allowbreak\tcode{readData}  that can handle null pointers just fine, or an override of \tcode{NumberPicker::}\allowbreak\tcode{pick} that returns a dummy value for some inputs, and correct uses of such functions (see also \propref{WidenPre}, \propref{WidenPostOut}, and \propref{WidenPostIn}). 

\subsubsection{Multiple inheritance use cases}

The following properties describe the ability of a design  for \tcode{pre} and \tcode{post} on virtual functions to support concrete use cases where a virtual function overrides more than one other virtual function.

\prop{WidenPreMult}{Override multiple functions with incompatible preconditions}

\emph{Description}:

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should make it well-formed to override multiple functions with different --- and potentially mutually exclusive --- precondition assertions. Which of these precondition assertions are evaluated should depend on the statically called function. 

\emph{Motivation}:

This property is an extension of property \propref{WidenPre} to multiple inheritance. It seems reasonable to inherit from multiple base classes which have mutually exclusive preconditions on a function, and to provide an implementation with wider preconditions that satisfies both domains. Such designs are correct and do not violate the substitutability principle (\propref{SubstPr}) or Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}).  C++ contract checking should support such designs.

\emph{Example}:

Consider a function-type hierarchy that might be used, for example, when writing
a simple expression interpreter, where all types in the hierarchy extend a common abstract base
class:

\begin{codeblock}
struct Function {
  virtual Value compute(const std::vector<Value>& arguments);
};
\end{codeblock}

For certain situations, a unary or binary function might be required and we could choose to model
this as subclass of \tcode{Function}:

\begin{codeblock}
struct UnaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    pre(arguments.size() == 1);
};

struct BinaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    pre(arguments.size() == 2);
};
\end{codeblock}

Now, there are variadic functions that can be used as both unary and binary functions:

\begin{codeblock}
struct VariadicFunction : public UnaryFunction, public BinaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    /*no preconditions */;
};
\end{codeblock}

Any code that uses a \tcode{UnaryFunction} is obliged to pass a single-element list of arguments to that
code (see also \propref{ChkCallerPre}). Similarly, two arguments are necessary for anything that uses \tcode{BinaryFunction}. Functions that make use of a \tcode{UnaryFunction}, however, will work completely correctly when handed a \tcode{VariadicFunction} that could take additional arguments when used differently. C++ contract checking should support all of these cases.

\prop{WidenPostMult}{Override multiple functions with incompatible postconditions}

\emph{Description}:
A design for supporting \tcode{pre} and \tcode{post} on virtual functions should make it well-formed to override multiple functions with different --- and potentially mutually exclusive --- postcondition assertions. Which of these postcondition assertions are evaluated should depend on the statically called function. 

\emph{Motivation}:

This property is an extension of property \propref{WidenPostOut} to multiple inheritance. A virtual function might override two functions that have not only mutually exclusive preconditions, but also mutually exclusive postconditions, and yet be fully substitutable for either. Such a design is correct and should be supported by C++ contract checking. Like  \propref{WidenPostOut}, this use case is compatible with the substitution principle (\propref{SubstPr}), but not with Bertrand Meyer’s Design by Contract paradigm (\propref{MeyerDbC}). 

\emph{Example}:

Consider a function type that requires
an even number as input and guarantees an even number as output, and another that operates in
the same fashion on odd numbers:

\begin{codeblock}
struct EvenComputer {
  virtual int compute(int x)
    pre(isEven(x))
    post(r : isEven(r));
};

struct OddComputer {
  virtual int compute(int x)
    pre(isOdd(x))
    post(r : isOdd(r));
};
\end{codeblock}

Now consider the following function, which inherits from both and satisfies the contract of both:

\begin{codeblock}
struct Identity : EvenComputer, OddComputer {
  int compute(int x) override { 
    return x; 
  }
}
\end{codeblock}

The type \tcode{Identity} is substitutable for both \tcode{EvenComputer} and \tcode{OddComputer}. Therefore, the above definition of such a type, and correct usages of it, should be allowed and should not cause contract violations.

%TD: TODO: Do we need a property to say that virtual inheritance should work? I'm having a hard time coming up with a use case for virtual inheritance where we would have interesting things going on with pre/post

\subsubsection{Optional behaviour}

All properties presented so far relate to the possible \emph{default} behaviour of \tcode{pre} and \tcode{post} on virtual functions. However, during discussions of this feature a concern came up repeatedly that specifying the default behaviour, regardless of how this is done, cannot provide the flexibility needed to  satisfy all relevant use cases for \tcode{pre} and \tcode{post} on virtual functions.

Therefore, the following properties describe use cases where additional syntax can be used to optionally give \tcode{pre} and \tcode{post} on virtual functions different behaviour. Note that all such additional syntax shown in this paper is strawman syntax to illustrate the idea; we do not propose any concrete new syntax in this paper.

\prop{InhOptBase}{Choose in the overridden function whether to inherit}
 
A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a base class the option to choose whether a particular function contract assertion should be inherited by any overriding functions or not.

Consider again the \tcode{Sqrt} type from \propref{WidenPostOut}. We might want to add another postcondition assertion verifying that the numerical value returned from the \tcode{compute} member function actually \emph{is} the square root of the value passed in, or at least an acceptable approximation of it:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre(x.isReal() && x.realPart() >= 0)
    post(r : r.isReal() && r.realPart() >= 0)
    post(r: approxEquals(r * r, x);
};
\end{codeblock}

We might further want to specify that the first two function contract assertions are specific to this function and can be freely widened (or narrowed) in overrides, while the last function contract assertion is considered essential for any implementation of \tcode{Sqrt::compute} and should therefore be automatically inherited by all overrides:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre noinherit (x.isReal() && x.realPart() >= 0)
    post noinherit (r : r.isReal() && r.realPart() >= 0)
    post inherit (r: approxEquals(r * r, x));
};
\end{codeblock}

Any design that offers the user this choice would need to answer a number of additional questions, such as the meaning of the \emph{default} syntax (see also \propref{InhDefault}) and whether an opt-out of \tcode{noinherit} should still be possible on the overridden function for use cases such as \propref{WidenPostIn}.

\prop{InhOptDerived}{Choose in the overriding function whether to inherit}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a derived class the option to explicitly inherit the overridden function's function contract assertions.

%TD: TODO: add example and motivation

\prop{CalleeOnly}{Check \tcode{pre} and \tcode{post} only when callee-facing}

TODO TAKE FROM D3097R1

\prop{CallerOnly}{Check \tcode{pre} and \tcode{post} only when caller-facing}
% TD: TODO: it's actually not caller only, it's "fully qualified call only"! Fix this, think of different identifier & description

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give users the option to specify that a particular function contract assertion should only be evaluated if it applies to the statically called function in a virtual function call.

This can be useful for assertions that express contracts applying to the interface, but not the implementation of a function.

Consider a virtual function hierarchy where different implementations share a common interface
precondition:

% TD: TODO: can we come up with less "toy" examples?
\begin{codeblock}
struct Animal {
  virtual void eat(Food* foodPtr)
    pre (foodPtr && foodPtr->isEdible());
};

struct Cat : Animal {
  void eat(Food* foodPtr) override
    /* ... */;
}

struct Dog : Animal {
  void eat(Food* foodPtr) override
    /* ... */;
}
\end{codeblock}

Now, suppose we want to add a dummy implementation to the base class function \tcode{Animal::eat} --- perhaps for testing or prototyping purposes --- that does nothing and therefore works with any input value:

\begin{codeblock}
virtual void Animal::eat(Food* /* unused */) {
  // dummy implementation
}
\end{codeblock}

Complementary to property \propref{CalleeOnly}, we can add support for such \emph{interface contract assertions} (checked only if the function is the statically called function in a virtual function call) with an explicit syntactic marker, for example

\begin{codeblock}
struct Animal {
  virtual void eat(Food* foodPtr)
    pre interface (foodPtr && foodPtr->isEdible()) {
      // dummy implementation
    }
};
\end{codeblock}

The intention of the above code is that, in the case of invalid input, \tcode{Animal::eat} would raise a contract violation when called polymorphically but work fine when called directly via a fully qualified call:
\begin{codeblock}
int main {
  Animal testAnimal;
  testAnimal.eat(nullptr);  // contract violation
  testAnimal.Animal::eat(nullptr); // OK
};
\end{codeblock}

 and therefore is not subject to the same
preconditions as any of the overriding functions when called via a fully qualified call because such a
call can be made with any input value. The contract is therefore an interface contract, but not an
implementation contract.

\prop{NonVirtOnly}{Check \tcode{pre} and \tcode{post} only in a non-virtual call}

TODO 

\section{Design space}
\label{designs}

TODO

\section{Evolution graph}
\label{evolution}

TODO

\section{Conformance matrix}
\label{matrix}

TODO

\section{Decision tree}
\label{tree}

TODO

\section{Conclusion}
\label{conclusion}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
%Thanks to Oliver Rosten for his review of the paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}

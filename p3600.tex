\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}
\cftsetindents{paragraph}{1.02in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on virtual functions: \\ a principled design approach}
\author{
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\
John Lakos \small(\href{mailto:jlakos@bloomberg.net}{jlakos@bloomberg.net}) 
% TD: TODO: get Ville on board?
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3600R0 \\
Date: &2025-08-25 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we present a comprehensive analysis of the design space for supporting function contract assertions (\tcode{pre} and \tcode{post}) on virtual functions in C++. We begin by identifying a number of desirable properties that such a language feature should exhibit. We survey existing and proposed approaches and introduce a framework for classifying them according to a small number of key design decisions. For each decision, we examine its impact on the extent to which the desirable properties can be achieved. We find that no design achieving all desirable properties is possible. We identify three candidate designs that realise different, meaningful subsets of these properties. We distill the choice between these candidate designs down to two design decisions with different tradeoffs. We conclude with a recommendation for a concrete design that seems to offer the best set of tradeoffs overall.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\tableofcontents*
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\subsection{Motivation and context}

Contract assertions (\cite{P2900R14}) are a major new facility in C++26. A key feature of this facility are \emph{function contract assertions}: \tcode{pre} and \tcode{post}. This feature allows expressing
% TD: I omitted the "the" from this sentence here because they only allow expressing a subset of the full set of preconditions and postconditions, so saying "the preconditions and postconditions" would be technically incorrect, however explaining why that is the case (or even saying something like "a subset of" here) feels like a distraction.
preconditions and postconditions of a function directly in C++ code, and optionally checking those conditions at runtime to identify and mitigate program defects, in a configurable and scalable fashion. 

Unlike assertion statements (\tcode{contract_assert}) or pre-C++26 macro-based assertions, function contract assertions are a part of the function's \emph{declaration} and are thus readily found by humans, compilers, IDEs, and static analysis tools without having to inspect the function's definition. 

However, a major limitation of the initial feature set in C++26 is that \tcode{pre} and \tcode{post} cannot be placed on a \emph{virtual} function; doing so renders the program ill-formed. This limitation exists due to ongoing disagreements in WG21 regarding the desired behaviour of \tcode{pre} and \tcode{post} on virtual functions that could not be resolved in the C++26 timeframe.

At the same time, virtual functions are widely used in C++ today. Many codebases and popular libraries rely on runtime polymorphism as a key aspect of their design. Therefore, to ensure a successful adoption of contract assertions across the C++ ecosystem, we must add meaningful and user-friendly support for \tcode{pre} and \tcode{post} on virtual functions (as pointed out in \cite{P3173R0}).

In this paper, we consider everything we have learned since the adoption of \cite{P2900R14} and undertake a new attempt at resolving the existing disagreements. The goal of this paper is to find a design for this feature that suits the needs of the C++ community and can get consensus in WG21.

\subsection{Prior art}

\subsubsection{Other programming languages}

Other popular programming languages, such as C\#, Java, and Python, offer assertions only as a library feature,\footnote{For C\# and Java, there exist language extensions that implement function contract assertions: Microsoft Code Contracts and the Java Modeling Language (JML), respectively. Neither of these facilities enjoys significant use today. Microsoft Code Contracts is officially deprecated. JML had some influence in the 2000s but is nowadays restricted to academic contexts; the tooling for it is somewhat arcane and difficult to install and use.} and as such do not offer true function contract assertions\footnote{To aid understanding, throughout this paper we use the terminology of the C++ Standard (such as overriding function, overridden function, function contract assertion, etc.) for analogous concepts in other programming languages, even though in many cases the users of those languages would choose different terminology.} that could meaningfully integrate with the  dynamic dispatch mechanisms in those languages. However, there is a small number of less popular programming languages that offer both true function contract assertions and dynamic dispatch as a language feature: Eiffel, D, and Ada. In these languages, function contract assertions and virtual functions can be composed in a meaningful way.

Eiffel, released in 1986, was the first programming language that allowed placing precondition and postcondition assertions on function declarations. In Eiffel, such assertions are spelled with \tcode{requires} and \tcode{ensures}, respectively. Eiffel was developed in conjunction with the Design by Contract (DbC) paradigm by Bertrand Meyer. Its design closely follows that paradigm.

In particular, Eiffel by construction enforces the constraint that in an overriding function, preconditions can only be widened and postconditions can only be narrowed. This is achieved by using a conjunction (via OR) of the precondition assertions and a disjunction (via AND) of the postcondition assertions of the overriding function and all functions in the inheritance hierarchy overridden by it.

The D programming language, released in 2001, offers function contract assertions since its inception. Precondition and postcondition assertions are spelled with \tcode{in} and \tcode{out} blocks, respectively. For virtual functions, D's design follows the Eiffel paradigm of OR-ing precondition assertions and AND-ing postcondition assertions across an inheritance hierarchy. However, there are also some notable differences in the detail.

The Ada programming language added the feature in Ada 2012. Ada seems to be the only language with true function contract assertions that enjoys a significant degree of active use in production code today (albeit it is still a niche language, primarily used in safety-critical and mission-critical industries such as aerospace, defence, transportation, and medical systems).

Ada's design for function contract assertions on virtual functions is particularly complex. The default syntax, \tcode{Pre} and \tcode{Post} respectively, corresponds to so-called \emph{specific} precondition and postcondition assertions. However, adding the \tcode{Class} attribute turns them into so-called  \emph{class-wide} precondition and postcondition assertions, \tcode{Pre\textquotesingle Class} and \tcode{Post\textquotesingle Class} respectively, with entirely different and rather unique semantics. Any given function can have both flavours of function contract assertions applied to it simultaneously.

A more detailed description of these historic designs, and how they could be applied to C++, can be found in Section~\ref{designs} of this paper.

The ability to express the contract of a function in code also exists in a number of academic research languages; Dafny and Spec\# are notable examples. However, the contract facilities in these languages are designed primarily for static correctness proofs rather than runtime checking. As a consequence, they are of a very different nature than the contract facility in C++26. The same is true for the experimental contracts facility in Kotlin. There also exists an experimental contracts facility for Rust that is realised via procedural macros; however, it does not seem to be integrated with Rust's mechanism for dynamic dispatch (trait objects). In this paper, we therefore do not consider applying these designs to C++.

\subsubsection{C++ proposals}

The first proposal for adding a contracts facility to C++ \cite{N1613} was directly inspired by the D language and therefore proposed the same design as realised in D: precondition and postcondition blocks that are OR-ed and AND-ed, respectively, across an inheritance hierarchy. The next revision, \cite{N1669}, changed this to OR-ing preconditions but enforcing that postconditions are the same across the entire hierarchy.
%, with the motivation that weakening postconditions is “useless in practice since the user cannot take advantage of the weaker precondition by performing a downcast.”
% TD: TODO: This motivation does not need to be in this overview; mention it somewhere else.
This proposal was revised a few more times, but ultimately did not succeed in WG21; the last revision was \cite{N1962}.

The second proposal for a contracts facility \cite{N3604} proposed contract assertions as a library feature, in the form of macros inside the function body. Therefore, it did not have true function contract assertions that could interact with dynamic dispatch. This proposal, too, did not succeed in WG21; the last revision was \cite{N4378}).

Following the abandonment of the second proposal, many different design options were explored in various papers. \cite{N4110} and \cite{P0147R0} argued in favour of the established DbC principle that preconditions should not be strengthened and postconditions should not be weakened. On the other hand, \cite{P0247R0} argued that inheriting checks on virtual functions, or requiring that checks on base class virtual interfaces match overriders ``does not work'', and that allowing an overriding function to both widen and narrow the preconditions of the overridden function might make sense because not everyone will want to call a function through the same interface.

\cite{N4415} and \cite{P0287R0} proposed a more conservative design than in previous proposals or in Eiffel, D, and Ada: virtual functions are constrained to have the same sequence of function contract assertions across the entire inheritance hierarchy. In an overriding function, the function contract assertion sequence of the overridden function can be either repeated or omitted (i.e., inherited implicitly); if it is repeated, it must be ODR-identical. \cite{P0380R0} made this design even more restrictive by requiring that the sequence be repeated on every overriding function; however, this restriction was rolled back again in \cite{P0380R1}. This was retained throughout C++2a Contracts (\cite{P0542R5}), which were adopted for the C++20 Working Draft and then removed again (\cite{P1823R0}).

After the failure of C++2a Contracts and the establishment of SG21, proposals continued to flip-flop between these two designs: \cite{P2388R4} made repeating the sequence on an overriding function optional, and \cite{P2521R5} made it mandatory again. \cite{P2954R0} added yet another variation: repeating the function contract assertion sequence on an overriding function was neither optional nor required but actually ill-formed; the sequence was always inherited implicitly. This design was approved by SG21.

However, after more investigation, implicit inheritance of the contract was found to be problematic (see \cite{P2932R3} Section 3.4). SG21 decided that, given the many concerns and disagreements over how function contract assertions should work on virtual functions, consensus on a comprehensive
solution could be deferred to a future extension, and virtual function support was thus removed
entirely from the proposal. This design was forwarded to EWG and LEWG.

However, in \cite{P3173R0}, a major compiler vendor stated that, given the importance and pervasive use of virtual functions in C++, a contracts facility that fails to support efficient use with virtual functions is inadequate for standardisation. It seemed unlikely at that point that EWG would adopt a contracts facility without support for virtual functions.

This led to the development of a new design for virtual function support in \cite{P3097R0} that resolved the known issues of previous designs. This design removed contract inheritance and introduced the notion of caller-facing and callee-facing function contract assertions. A counterproposal with yet another new design based on contract inheritance was made in \cite{P3169R0}. SG21 carefully considered all design options known at the time and forwarded the design in \cite{P3097R0} to EWG. This design was approved by EWG and incorporated into the C++26 proposal.

However, following this decision, concerns were raised in \cite{P3506R0} and in \cite{P3573R0} that the caller/callee model from \cite{P3097R0} that had been approved by EWG was a departure from the established DbC model; that it had insufficient deployment and usage experience in the field; and that it was too complex. A rebuttal paper \cite{P3506R0} argued that the caller/callee model is the most appropriate design for C++ and should be retained. EWG did not manage to resolve this disagreement in the C++26 timeframe and instead decided to ship contract assertions in C++26 without support for virtual functions.

A more detailed history of function contract assertions on virtual functions in C++, including poll results and references to all relevant papers, can be found in \cite{P2899R1} Section 3.3.2.

\subsection{Methodology}

The goals of this paper are twofold: to identify the design for supporting \tcode{pre} and \tcode{post} on virtual functions that best satisfies the needs of the C++ community, and to facilitate establishing consensus in WG21 in favour of such a design. To achieve these goals, we analyse the available design space as exhaustively and objectively as possible. Our analysis follows the method for finding consensus on technical design questions developed in \cite{P3684R0}. This method is an evolution and adaptation of the Principled Design method developed in \cite{P3004R0} and \cite{P3005R0}.

We begin by identifying the desirable properties that a design for this language feature should exhibit (Section~\ref{properties}). We take into account all relevant properties that were articulated by members of WG21. We describe each property as precisely as possible, along with motivation, use cases, and code examples. To minimise bias, we treat all properties equally and do not attempt to rank them by importance or other criteria.

We then identify all known design options for this feature (Section~\ref{designs}), including all variations that have been shipped in other programming languages or proposed for C++ at some point. As a tool for efficiently navigating this design space, we introduce a framework for classifying all possible designs according to a small set of key design decisions, as well as a scheme to refer to each possible design with an unambiguous identifier that encodes this set of decisions.

We proceed by constructing an \emph{evolution graph}, i.e., determining which design options can be obtained by future evolution of other, more conservative design options (Section~\ref{evolution}). Such an evolution graph is useful in case the committee fails to get consensus one way or another between two mutually exclusive design options. In this case, we can fall back to the maximal common ancestor of both options in the evolution graph.

With this thorough mapping of the available design space, we conduct an analysis of how well each available design option satisfies the identified desirable properties (Section~\ref{matrix}). We visualise this analysis with a so-called \emph{conformance matrix}. 

In the final part of our analysis, we use the conformance matrix to identify the most promising candidate designs (Section~\ref{tree}). We distill the choice between these candidate designs down to a small number of binary design decisions between concrete tradeoffs (``do we prefer satisfying property A or property B?'') that can be polled in EWG. We conclude with a recommendation for a concrete candidate design that seems to offer the best set of tradeoffs overall (Section~\ref{conclusion}).


\section{Desirable properties}
\label{properties}

% TD: TODO: add a property that indirect calls where static and dynamic type are equal should have the same set of function contract assertions as direct calls.

% TD: TODO: add a property that pre(true) and post(true) should mean the same thing as nothing

\subsection{General approach and selection criteria}

In this section, we identify the desirable properties that a design for supporting \tcode{pre} and \tcode{post} on virtual functions should exhibit. We take into account all relevant properties that were articulated by members of WG21 (whether formally in papers or informally during meetings or on the committee mailing lists).

We describe each desirable property as precisely as possible and provide known motivation for supporting it. Where applicable, we include concrete code examples; we strive to provide realistic use cases rather than ``toy code'' whenever possible. Each property is given a short unique identifier to easily refer to it later in the paper, for example \tcode{ImplExp} for implementation experience.

We follow the consensus-building method developed in \cite{P3684R0}; thus, we focus on data and objectively verifiable information rather than opinions, and do our best to minimise cognitive bias and value judgments when describing the desirable properties. In particular, we do not attempt to rank the listed properties by priority, relevance, or otherwise. However, we do point out cases where two or more properties are at odds with each other.

Some of the listed properties were originally articulated as ``design principles that must be adhered to'',  ``very important use cases'', ``necessary conditions for successfully deploying the feature'', etc. For the purpose of this analysis, we carefully avoid such characterisations and instead treat all properties equally. For properties that are describing a use case, we avoid any claims of how common (or contrived) it is due to lack of data from real-world code bases backing up such claims.

In a number of cases, it may be controversial whether the motivation is sound, the use case is plausible, and the property in question is actually desirable. In these cases, we strive to adopt a neutral position and limit ourselves to describing the property and the motivation for supporting it, as far as it has been articulated to us by proponents of the given property.

We only include properties for which we can objectively and unambiguously answer the question ``does a given language design exhibit this property?''. We therefore deliberately exclude properties that are vague, subjective, and/or cannot be measured directly, such as teachability or intuitiveness of a particular design. We also do not include properties that could in principle be measured, but for which no concrete, measurable criterion has been proposed.

For example, \cite{P3573R0} mentions the concern that \tcode{pre} and \tcode{post} on virtual functions ``have not been tried at scale''. However, the paper does not specify a measurable criterion for what would constitute sufficient ``scale''. We are happy to include this property in a future revision of this paper if the authors can provide a measurable criterion (e.g., a particular number of lines of deployed code that they consider sufficient deployment experience). Similarly, \cite{P3506R0} listed as a concern that the design proposed in \cite{P3097R0} was ``too complex''; however, since the author did not provide an objective criterion for measuring the complexity of any possible design, we exclude this concern from our analysis.

Importantly, we are not suggesting that properties like teachability or complexity are not relevant for language design; quite the opposite. However, since we cannot objectively measure them, it will be up to each member of WG21 to decide how to weigh these more subjective properties against the objective ones presented in this paper when considering a concrete proposed design for inclusion in Standard C++.

\subsection{List of properties}

%::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

% Macro to define custom subsubsubsections for properties
\newcommand{\prop}[2]{
  \paragraph*{\tcode{#1}: #2}
  \refstepcounter{paragraph}
  \label{#1}
  \addcontentsline{toc}{paragraph}{\tcode{#1}: #2}
  \mbox{}\vspace{0.5em} % hack to force the heading to not be run-in
  \nopagebreak[4]
}

% Macro to refer to properties
\newcommand{\propref}[1]{\hyperref[#1]{\tcode{#1}}}

%::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


\subsubsection{Design constraints}

The following properties describe potentially desirable design constraints on the behaviour of \tcode{pre} and \tcode{post} on virtual functions.

\prop{FullQualEq}{Equivalence of virtual and fully qualified direct calls}

% TD: Josh, I included this property anyway because it's a nice easy way to start the list of properties: surely this is one that we can all agree on. Also, it's important to JL.

In a virtual function call, when the statically called function and the function chosen by dynamic dispatch are the same function, the effect of such a call should be equivalent to a fully qualified (i.e., non-virtual) call to that function. In particular, the same function contract assertions should be evaluated in both cases.

Consider the following simple inheritance hierarchy:

\begin{codeblock}
struct Base {
  virtual void f() /* ... */;
};

struct Derived : Base {
  void f() override /* ... */;
};
\end{codeblock}
No matter which (if any) function contract assertions are specified in \textit{/* ... */}, both of the following function calls should evaluate the same function contract assertions when executed:

\begin{codeblock}
int main() {
  Derived d;
  d.f();     // (1)
  d.D::f();  // (2)
}
\end{codeblock}
In C++ today, the observable behaviour of the two calls above is identical in all cases as long as \tcode{Derived} is the dynamic type of \tcode{d}. It would be arguably very surprising to users if a design for \tcode{pre} and \tcode{post} on virtual functions would break that equivalence.

% TD: TODO: Is there better motivation for this property? Asked JL

\prop{VacuousTrue}{Vacuousness of \tcode{pre(true)} and \tcode{post(true)}}

On the declaration of a virtual function, \tcode{pre(true)} and \tcode{pre(false)} should always be vacuous, i.e., they should be equivalent to not specifying any precondition or postcondition assertion at all on that declaration. Whether or not \tcode{pre(true)} and \tcode{pre(false)} are present should not change which function contract assertions will be evaluated; in particular, adding \tcode{pre(true)} or \tcode{pre(false)} to a function declaration should not cause other, non-vacuous contract assertions to no longer be evaluated.

This design constraint is consistent with the vacuousness of \tcode{pre(true)} and \tcode{post(true)} on non-virtual functions, as well as the vacuousness of \tcode{assert(true)}, \mbox{\tcode{contract_assert(true)}}, \mbox{\tcode{static_assert(true)}}, \tcode{requires(true)}, \tcode{if(true)}, etc. in C++ today. Further, if we could not rely on this constraint being satisfied, it could lead to surprising behaviour in cases where the presence of function contract assertions is conditional.

Consider, for example, a function that takes a file path as a parameter. On Windows, there is historically a strict limit on the length of such paths; however, this limit does not exist on other platforms. We could make the contract predicate platform-dependent:

\begin{codeblock}
#ifdef _WIN32
  #define PATH_OK(path) path.size() < MAX_PATH 
#else
  #define PATH_OK(path) true
#endif

Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
    pre(PATH_OK(path)) {
      // ...
};
\end{codeblock}

Alternatively, we could conditionally macro out the entire precondition assertion:

\begin{codeblock}
Class Configurator {
public:
  virtual void openConfigFile(const std::string& path)
#ifdef _WIN32
    pre(path.size() < MAX_PATH)
#endif
  {
    // ...
};
\end{codeblock}

Both programming styles seem reasonable in cross-platform code. It would arguably be surprising to users if a design for \tcode{pre} and \tcode{post} on virtual functions would introduce cases where they lead to different contract assertions being evaluated.

\prop{SubstPr}{Substitution principle}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should follow the \emph{substitution principle}, which stipulates that objects of a base class should be replaceable with objects of a derived class without affecting the correctness of the program.

Consider the following correct program:
\begin{codeblock}
struct Base {
  virtual int f(int i)
    pre (i >= 0)
    post (r: r <= i);
};

void test(Base& b) {
  std::print(b.f(42));
}
\end{codeblock}
The call to \tcode{Base::f} in function \tcode{test} is correct, i.e., it satisfies its precondition that the integer passed in must be nonnegative. This is verified by the absence of a precondition assertion violation. If the call to \tcode{Base::f} returns without a postcondition assertion violation, then \tcode{Base::f} is also implemented correctly, i.e., it satisfies its postcondition. The program can therefore rely on  the printed value never being greater than 42.

A function that overrides \tcode{Base::f} but has narrower precondition assertions would break the correctness of the call and thus violate the substitution principle. Consider an override that can only handle even numbers as input:
\begin{codeblock}
struct Derived1 : Base {
  int f(int i) override
    pre (i % 2 == 0);
}
\end{codeblock}
In this example, \tcode{Derived1::f} specifies a precondition assertion that may fail on inputs that are considered correct for \tcode{Base::f} (odd nonnegative integers). This precondition assertion should therefore either not compile, or its semantics should be such that failing it is not considered a contract violation, otherwise \tcode{Derived1} is not substitutable for \tcode{Base}.

Further, a function that overrides \tcode{Base::f} but has wider precondition assertions for inputs that are considered correct for \tcode{Base::f} would break the expectations of the calling code and thus also violate the substitution principle. Consider:

\begin{codeblock}
struct Derived2 : Base {
  int f(int i) override /* ... */ {
    return 42;
  }
}
\end{codeblock}

In this example, \tcode{Derived2::f} is not substitutable for \tcode{Base::f} as it is possible to pass a nonnegative number (thus satisfying the precondition assertions of \tcode{Base::f}) but get a number back that is larger than the number passed in (thus failing the postcondition assertions of \tcode{Base::f}). The design should therefore ensure that when the dynamic type of the parameter passed into  \tcode{test(Base\&)} is \tcode{Derived2}, and \tcode{Derived2::f} is implemented as above, such an implementation will be treated as incorrect and result in a postcondition assertion violation. Such a design may or may not constrain which function contract assertions are allowed in \mbox{\emph{/* ... */}}.

Note that widening preconditions and narrowing postconditions in the overridden function do not violate the substitution principle. Note further that when an overriding function has wider preconditions than the overridden function (assuming the chosen language design allows this), and is called \emph{outside} of the overridden function's preconditions (i.e., in a way that is a correct call of the overriding function but would not be a correct call of the overridden function), it is not necessary to satisfy the overridden function's postconditions. Consider:

\begin{codeblock}
struct Derived3 {
  int f(int i) override {
    return std::abs(i);
  }
};
\end{codeblock}
In this example, \tcode{Derived3::f} operates on a wider domain than \tcode{Base::f} as it is possible to pass a negative integer. In this case,  \tcode{Derived3::f} does \emph{not} satisfy the postcondition of \tcode{Base::f} as the return value will be greater than the value passed in. However, \tcode{Base} is still substitutable by \tcode{Derived3} because \tcode{Derived3::f} will always satisfy the postcondition of \tcode{Base::f} when given a nonnegative integer.

The substitution principle is a well-established paradigm in object-oriented programming. It ensures that derived classes remain true to the behaviour and expectations of their base classes, allowing the user to use them interchangeably without introducing bugs. Applying this principle to the design of \tcode{pre} and \tcode{post} on virtual functions seems appropriate in situations where external clients will depend on contracts, such as when designing public APIs, libraries, and frameworks.

However, there are also use cases where unconditional substitutability between base and derived class is a non-goal. A design that requires \tcode{pre} and \tcode{post} to obey the substitution principle would make the addition of function contract assertions to a codebase difficult or impossible in such situations. Such use cases are described in properties \propref{NarrowPre} and \propref{WidenPostIn}. This is one instance where different properties listed in this paper  cannot be satisfied simultaneously.

\prop{MeyerDbC}{Bertrand Meyer's ``Design by Contract'' paradigm}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should follow Bertrand Meyer's Design by Contract (DbC) paradigm, which stipulates that in an overriding function, preconditions can only be widened and postconditions can only be narrowed, but not vice versa.

Following the DbC paradigm when  specifying the semantics of \tcode{pre} and \tcode{post} on virtual functions is a well-known approach to enforcing the substitution principle, and is existing practice in the Eiffel and D programming languages with decades of implementation and usage experience.

However, the DbC paradigm is not isomorphic with the substitution principle. Any design that satisfies \propref{MeyerDbC} also satisfies \propref{SubstPr}, but not vice versa, because \propref{MeyerDbC} imposes additional constraints. In particular, a function that has wider postconditions than the function it overrides if and only if is called \emph{outside} of the overridden function's preconditions satisfies \propref{SubstPr}, but does not satisfy \propref{MeyerDbC}. An example for such a function is \tcode{Derived3::f} in \propref{SubstPr} above.

Concrete use cases that are not compatible with \propref{MeyerDbC} --- beyond those that are already not compatible with \propref{SubstPr} --- are described in properties \propref{WidenPostOut} and \propref{WidenPostMult}. Therefore, this is another instance where different properties listed in this paper cannot be satisfied simultaneously.

\subsubsection{Single inheritance use cases}

The following properties describe the desirable default behaviour of \tcode{pre} and \tcode{post} for concrete use cases where a virtual function overrides at most \emph{one} other virtual function.

\prop{WidenPre}{Enable widening preconditions}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{widen} preconditions in an overriding function, i.e., to specify precondition assertions that are less strict than those specified on the overridden function, or even specify that there are \emph{no} precondition assertions on the overriding function. Whenever the overriding function is called \emph{directly} (i.e., it is the statically called function), those less strict precondition assertions should be evaluated instead of the overridden ones.

A derived class should be able to extend the functionality of the base class and accept arguments that are designed to work with that extended functionality; doing so does not compromise substitutability of the base class by the derived class. Contract checking should support this practice.

Consider the following motivating use case from \cite{P0247R0}:
\begin{codeblock}
class Display {
public:
  virtual void post_message(std::string_view s)
     pre (is_ascii(s)) = 0;
};

class XDisplay : public Display {
   // ...
public:
  void post_message(std::string_view s) override
    pre (is_utf8(s));
 };
\end{codeblock}
In this example, we have a base class facility that accepts ASCII strings to display. However, the derived implementation accepts UTF-8. A program that uses the \tcode{XDisplay} class directly should be able to generate and post both ASCII and UTF-8 messages. In other words, the following program should not cause a contract violation when executed:
\begin{codeblock}
void test(XDisplay& xd) {
  xd.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}
In this program, the statically called function is \tcode{XDisplay::post_message}, and the dynamic type is \tcode{XDisplay} (it could also be a type deriving from \tcode{XDisplay}). The base class interface \tcode{Display::post_message} is not used, therefore satisfying its narrower precondition is not relevant to the correctness of this program.

\prop{ChkPreCaller}{Check caller-facing preconditions}

In a virtual function call, the precondition assertions specified on the statically called function should be evaluated by default, regardless of which function will be selected by dynamic dispatch and what  precondition assertions are specified on that function.

Consider again the \tcode{Display} --- \tcode{XDisplay} inheritance hierarchy from property \tcode{WidenPre}. Let us slightly alter the \tcode{test} function such that it takes a reference to the base class \tcode{Display}:
\begin{codeblock}
void test(Display& d) {
  d.post_message(/* some non-ASCII UTF-8 string */);
}

int main() {
  XDisplay xd;
  test(xd);
}
\end{codeblock}
The above program should cause a contract violation when executed, because it violates the preconditions of the statically called function (\tcode{Display::post_message}), even though the preconditions of the function that will actually be executed (\tcode{XDisplay::post_message}) are satisfied.

The rationale for this property is that calling \tcode{Display::post_message} with a non-ASCII input string is an incorrect use of the \tcode{Display} interface and therefore constitutes a bug that should be detectable by contract checking. In the program above, the dynamic type of the object referenced by \tcode{d} happens to be \tcode{XDisplay}, and \tcode{XDisplay::post_message} can handle non-ASCII strings just fine; however, that dynamic type is not known at the call site and can change in the future. The call site must therefore work correctly for any type that inherits from \tcode{Display}, whether it happens to be an \tcode{XDisplay} or not.

\prop{NarrowPost}{Enable narrowing postconditions}
% OK

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} postconditions in an overriding function, i.e. to specify postcondition assertions that are more strict than those of the overridden function. Whenever the overriding function is executed, its stricter postcondition assertions should be evaluated (regardless of what the statically called function is or what its postcondition assertions are). Failure should cause a contract violation, even if all postcondition assertions of the overridden function are satisfied.

Subclasses that have compatible contracts with their base class can often provide additional guarantees that the base class does not require of all potential subclasses. Failing to meet these additional guarantees is a bug in the subclass that should be detected by contract checking, even when the direct caller does not directly depend on that guarantee because it is using the base class interface.

Consider an abstract class that is used to generate sequences of integers through a virtual function:

\begin{codeblock}
struct Generator {
  virtual int next() = 0;
};
\end{codeblock}
Many different derived classes might be implemented that produce different sequences. A particularly simple implementation may always produce the same constant value, which can be specified by the user:
\begin{codeblock}
struct ConstantGenerator : Generator {
  void setValue(int value);
  int getValue(); 
  int next() override
    post (r: r == getValue());
}
\end{codeblock}
The above postcondition assertion is specific to the implementation of \tcode{ConstantGenerator::}\allowbreak\tcode{next()}. A violation of that postcondition assertion indicates a bug in the implementation of \tcode{ConstantGenerator}. Therefore, the following program should cause a contract violation when executed:
\begin{codeblock}
void test(Generator& gen) {
  std::print(gen.next());
}

int ConstantGenerator::next() override {
  return 0;  // dummy implementation  
} 

int main() {
  ConstantGenerator constGen;
  constGen.setValue(42);
  test(myGen);
}
\end{codeblock}


\prop{NarrowPre}{Enable narrowing preconditions}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to \emph{narrow} preconditions in an overriding function, i.e., to specify precondition assertions 
 that are \emph{more strict} than those of the overridden function. Whenever the overriding function is executed (regardless of what the statically called function is), these more strict precondition assertions should be evaluated. Failure should cause a contract violation, even if all precondition assertions of the overridden function are satisfied.
 
Consider a base class for rendering an image:

\begin{codeblock}
class Image {
public:
  virtual void render() const;
};
\end{codeblock}

Now consider a derived class that renders the image on a GPU. This implementation is more efficient and powerful, however it requires the user to perform an additional initialisation step before the image can be rendered:

\begin{codeblock}
class GPUImage : public Image {
public:
  bool prepare() { 
    // upload data to GPU, handle errors...
    return readyToRender;
  }
  
  void render() const override
    pre (readyToRender);
};
\end{codeblock}

In order to support this use case, the precondition assertion \tcode{pre(readyToRender)} would need to be well-formed, evaluated whenever \tcode{GPUImage::render} is executed, and trigger a contract violation in case of failure, even if the statically called function is \tcode{Image::render} and all preconditions of that functions are met.

Note that \tcode{GPUImage} is not substitutable for \tcode{Image} in the general case, because its implementation for \tcode{render} introduces an additional precondition. Supporting this use case is therefore incompatible with the substitution principle (\propref{SubstPr}) and with Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}).

However, \tcode{GPUImage} \emph{becomes} substitutable for \tcode{Image} after successfully calling \tcode{prepare}. Substitutability therefore becomes a runtime property rather than a static one, but will still hold in a correct program. On the other hand, failure to establish the substitutability criteria at runtime (i.e., to successfully call \tcode{prepare} before calling \tcode{render}) is a bug that should be detectable by contract checking.

The rationale for allowing such class hierarchies is that they exist, can be used correctly, and are used in production systems today. It may not be a good choice to include the above \tcode{GPUImage} class in a public-facing, general-purpose graphics library, but it seems perfectly acceptable to do so e.g. in an internal rendering engine where the team controls the entire codebase and knows how to use it correctly, in particular if there are positive tradeoffs such as greater performance. 

If we allow \tcode{pre} and \tcode{post} on virtual functions to be used in such cases, it enables users to leverage them to detect bugs such as failure to  successfully call \tcode{prepare} before calling \tcode{render} when using \tcode{GPUImage}. On the other hand, if we do not allow such use cases, users may not be able to afford to refactor their code to adhere to the substitution principle or Design by Contract; instead, they will simply not add function contract assertions to their code.


\prop{WidenPostOut}{Enable widening postconditions outside of base contract}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function in cases where the overriding function is called outside of the overridden function's preconditions.

This use case arises whenever an overriding function operates on a larger domain than the function it overrides. As an example of this situation, let \tcode{Number} be a generic type that can represent real or complex numbers. Now, consider a type \tcode{Sqrt} that computes a real-number square root. The function \tcode{Sqrt::compute} requires a nonnegative real number as input, and returns another nonnegative real number as output. We can specify this contract using function contract assertions:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre(x.isReal() && x.realPart() >= 0)
    post(r : r.isReal() && r.realPart() >= 0);
};
\end{codeblock}

This implementation of square root might have a number of useful properties, such as computing the result very efficiently with hardware instructions. However, \tcode{Sqrt} is also a polymorphic type, so that the user can substitute other implementations of square root that have different tradeoffs.

Later on, we might add an implementation of square root to our codebase that can handle the entire complex plane and therefore drops the precondition and postcondition assertions of \tcode{Sqrt::compute}:

\begin{codeblock}
struct ComplexSqrt : public Sqrt {
  Number compute(const Number& x) override;
};
\end{codeblock}
When the preconditions of the overridden function \tcode{Sqrt::compute} are satisfied, \tcode{ComplexSqrt::}\allowbreak\tcode{compute} gives clients the same guarantee: if the user passes a nonnegative real number, they will get back a nonnegative real number. Therefore, \tcode{Sqrt} is substitutable by \tcode{ComplexSqrt}. 

However, when the function \tcode{ComplexSqrt::compute} is used directly, the calling code is no longer required to satisfy the preconditions of \tcode{Sqrt::compute} and can pass any complex number. In this case, satisfying the postconditions of \tcode{Sqrt::compute} is no longer necessary either. In the following program, \tcode{ComplexSqrt::compute} should return a value that is \emph{not} a nonnegative real number without causing a contract violation:

\begin{codeblock}
int main() {
  Number complexUnit = ComplexSqrt().compute(-1);
}
\end{codeblock}

Since the overriding function is substitutable for the overridden function, supporting this use case is compatible with the substitution principle (\propref{SubstPr}), but not with Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}).

\prop{WidenPostIn}{Enable widening postconditions inside base contract}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the user to widen postconditions in an overriding function in the general case. This property extends property \propref{WidenPostOut} to cases where the overridden function is not fully substitutable for the overriding function. 

Consider again the base class \tcode{Sqrt} from property \propref{WidenPostOut}. We might want to add an implementation of square root \tcode{IntOnlySqrt} that is extremely efficient for perfect square integers (1, 4, 9, ...) but returns -1 for other integers, thus violating the postcondition of \tcode{Sqrt::compute} for some inputs.

As another example, consider how mock types are used in a test suite. Imagine an algorithm that depends on a \tcode{Sqrt} implementation:

% TD: TODO: you need to make compute() const in all implementations above
\begin{codeblock}
Value sumSqrts(const std::vector<Value>& values, const Sqrt& sqrtFunction) {
  Value sum = 0;
  for (auto&& value : values)
    sum += sqrtFunction(value);
    
  return sum;
}
\end{codeblock}

Now, we would like to write unit tests to verify the correctness of \tcode{sumSqrts}, but without pulling in a fully functional \tcode{Sqrt} implementation. Instead, we might use a mocking strategy. The following generic mock function template can be set to expect any specified value as an argument for and return any specified value from the next call to \tcode{compute}:

\begin{codeblock}
template <typename Base>
void MockFunction : public Base {
  void setInput(const std::vector<Value>& expectedArguments);
  const std::vector<Value>& getInput() const;
  
  void setOutput(const Value& value);
  Value getOutput() const;
  
  Value compute(const std::vector<Value>& arguments) override
    pre (arguments == getInput())
    post (r: r == getOutput());
};
\end{codeblock}

With this mock template, we can write a unit test for \tcode{sumSqrts} as follows:

\begin{codeblock}
void testSumSqrts() {
  // verify that \tcode{sumSqrts} works correctly to sum a vector of 4s:
  std::vector<Value> values = {4, 4, 4, 4};
  MockFunction<Sqrt> mockSqrt;
  mockSqrt.setInput({4});
  mockSqrt.setOutput({2});
  
  ASSERT(8 == sumSqrts(values, testSqrt));
}
\end{codeblock}

Similarly to use case \propref{NarrowPre}, implementations such as \tcode{IntOnlySqrt} or \tcode{MockFunction<Sqrt>} are not substitutable for \tcode{Sqrt} in the general case, and therefore supporting this use case is incompatible with properties \propref{SubstPr} and \propref{MeyerDbC}.

However, they \emph{are} substitutable for certain inputs; a program that ensures only these inputs are being used is still correct and useful. Allowing \tcode{pre} and \tcode{post} on virtual functions to be used in such cases provides the benefits of improved detection and mitigation of bugs in codebases where such class hierarchies are used today.

In order to support these use cases, a design should ensure that, whenever the overriding function is executed, \emph{its own} postconditions (which may be narrower and/or wider than those of the overridden function) are evaluated, diagnosing bugs in the implementation of that overriding function; at the same time, the postconditions of the statically called function also need to be evaluated, diagnosing substitutability bugs where the overriding function fails to establish the postconditions of the overridden functions for concrete inputs.

\prop{InhDefault}{Inherit function contract assertions by default}

When a virtual function specifies function contract assertions, and is then overridden by another virtual function in a derived class, the overriding function should, by default, \emph{inherit} the function contract assertions of the overridden function. That is, if the overriding function does not specify its own precondition or postcondition assertions, those of the overridden function should apply, even if the overriding function is called directly and not through the overridden interface.

As a use case, consider \tcode{QIODevice}, the base interface class of all I/O devices in the Qt framework.\footnote{Documentation available here: \url{https://doc.qt.io/qt-6/qiodevice.html}} This class has a number of virtual functions such as \tcode{readData} which take a raw data pointer to read bytes from. In a future version of Qt, one might want to add a precondition assertion to check that this pointer is not null:
\begin{codeblock}
class QIODevice {
public:
  virtual qint64 readData(char* data, qint64 maxSize)
    pre (data != nullptr) = 0;
};
\end{codeblock}
Now, if a user inherits from \tcode{QIODevice} and overrides \tcode{readData}, the intent is that the same null pointer check will apply to their function, without them having to specify any function contract assertions. Specifically, in the following program,
\begin{codeblock}
class MyIODevice : public QIODevice {
public:
  qint64 readData(char* data, qint64 maxSize) override {
    // my implementation...
  }
};

int main() {
  char* data = nullptr;
  qint64 size = 0;
  
  MyIODevice device;
  device.readData(data, size);
}
\end{codeblock}
the last line of \tcode{main} should trigger a contract violation when checks are enabled, even though the derived class \tcode{MyIODevice} is used directly rather than through the base class interface \tcode{QIODevice}. 

The rationale for this property is that in any reasonable implementation of \tcode{QIODevice}, this precondition check is useful to detect bugs that would otherwise lead to program failure; at the same time, it would be far too easy for non-expert authors of derived classes to forget to consider that they want and need that precondition check on their own implementation.

The same argument can be extended to postcondition assertions as well. Consider a base class for different algorithms that choose one number out of a non-empty set of numbers:
\begin{codeblock}
struct NumberPicker {
  virtual int pick(const Array<int>& numbers)
    pre (!numbers.empty())
    post (r: numbers.contains(r)) = 0;
};
\end{codeblock}
Now consider different implementations of this base class:
\begin{codeblock}
struct FirstNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[0];
  }
};

struct RandomNumberPicker : NumberPicker {
  int pick(const Array<int>& numbers) override {
    return numbers[rand() % numbers.size()];
  }
};
\end{codeblock}
We expect that any correct implementation of  \tcode{NumberPicker} will satisfy both the precondition and postcondition assertions of \tcode{NumberPicker::pick}. Therefore, those assertions should be checked even in cases in which the derived class interface is used directly, for example in a statically polymorphic context:
\begin{codeblock}
template <typename T>
int pickNumber(T& picker, const Array<int>& numbers) {
  return picker.pickNumber();
}

int rollDice() {
  return pickNumber(RandomNumberPicker(), {1, 2, 3, 4, 5, 6});
}
\end{codeblock}
In the above case, if the implementation of \tcode{RandomNumberPicker::pick} fails to satisfy the postcondition assertion of \tcode{NumberPicker::pick}, we should get a contract violation.

Note that this property is incompatible with property \propref{NoRemoteBreak}. If function contract assertions are inherited by default, then pre-existing overrides with no function contract assertions may break when function contract assertions are introduced to the overridden function. Consider for example an override of \tcode{QIODevice::}\allowbreak\tcode{readData}  that can handle null pointers just fine, or an override of \tcode{NumberPicker::}\allowbreak\tcode{pick} that returns a dummy value for some inputs, and correct uses of such functions (see also \propref{WidenPre}, \propref{WidenPostOut}, and \propref{WidenPostIn}). 
\subsubsection{Multiple inheritance use cases}

The following properties describe the desirable default behaviour of \tcode{pre} and \tcode{post} for concrete use cases where a virtual function overrides  more than one other virtual function.

\prop{WidenPreMult}{Override multiple functions with incompatible preconditions}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should make it well-formed to override multiple functions with different --- and potentially mutually exclusive --- precondition assertions. Which of these precondition assertions are evaluated should depend on the statically called function. This property is an extension of property \propref{WidenPre} to multiple inheritance.

Consider a function-type hierarchy that might be used, for example, when writing
a simple expression interpreter, where all types in the hierarchy extend a common abstract base
class:

\begin{codeblock}
struct Function {
  virtual Value compute(const std::vector<Value>& arguments);
};
\end{codeblock}

For certain situations, a unary or binary function might be required and we could choose to model
this as subclass of \tcode{Function}:

\begin{codeblock}
struct UnaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    pre(arguments.size() == 1);
};

struct BinaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    pre(arguments.size() == 2);
};
\end{codeblock}

Now, there are variadic functions that can be used as both unary and binary functions:

\begin{codeblock}
struct VariadicFunction : public UnaryFunction, public BinaryFunction {
  Value compute(const std::vector<Value>& arguments) override
    /*no preconditions */;
};
\end{codeblock}

Any code that uses a \tcode{UnaryFunction} is obliged to pass a single-element list of arguments to that
code (see also \propref{ChkCallerPre}). Similarly, two arguments are necessary for anything that uses \tcode{BinaryFunction}. Functions that make use of a \tcode{UnaryFunction}, however, will work completely correctly when handed a \tcode{VariadicFunction} that could take additional arguments when used differently. Such correct uses should be allowed.

\prop{WidenPostMult}{Override multiple functions with incompatible postconditions}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should make it well-formed to override multiple functions with different --- and potentially mutually exclusive --- postcondition assertions. Which of these postcondition assertions are evaluated should depend on the statically called function. This property is an extension of property \propref{WidenPostOut} to multiple inheritance.

Consider a function type that requires
an even number as input and guarantees an even number as output, and another that operates in
the same fashion on odd numbers:

\begin{codeblock}
struct EvenComputer {
  virtual int compute(int x)
    pre(isEven(x))
    post(r : isEven(r));
};

struct OddComputer {
  virtual int compute(int x)
    pre(isOdd(x))
    post(r : isOdd(r));
};
\end{codeblock}

Now consider the following function, which inherits from both and satisfies the contract of both:

\begin{codeblock}
struct Identity : EvenComputer, OddComputer {
  int compute(int x) override { 
    return x; 
  }
}
\end{codeblock}

The type \tcode{Identity} is substitutable for both \tcode{EvenComputer} and \tcode{OddComputer}. Therefore, the above definition of such a type, and correct usages of it, should be allowed and should not cause contract violations. Supporting this use case is compatible with the substitution principle (\propref{SubstPr}), but not with Bertrand Meyer's Design by Contract paradigm (\propref{MeyerDbC}).

%TD: TODO: Do we need a property to say that virtual inheritance should work? I'm having a hard time coming up with a use case for virtual inheritance where we would have interesting things going on with pre/post

\subsubsection{Optional behaviour}

The following properties describe use cases where multiple different behaviours for \tcode{pre} and \tcode{post} on virtual functions are possible and there may be value in offering users the option to explicitly choose between either using additional syntax.

\prop{InhOptBase}{Choose in the overridden function whether to inherit}
 
A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a base class the option to choose whether a particular function contract assertion should be inherited by any overriding functions or not.

Consider again the \tcode{Sqrt} type from \propref{WidenPostOut}. We might want to add another postcondition assertion verifying that the numerical value returned from the \tcode{compute} member function actually \emph{is} the square root of the value passed in, or at least an acceptable approximation of it:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre(x.isReal() && x.realPart() >= 0)
    post(r : r.isReal() && r.realPart() >= 0)
    post(r: approxEquals(r * r, x);
};
\end{codeblock}

We might further want to specify that the first two function contract assertions are specific to this function and can be freely widened (or narrowed) in overrides, while the last function contract assertion is considered essential for any implementation of \tcode{Sqrt::compute} and should therefore be automatically inherited by all overrides:

\begin{codeblock}
struct Sqrt {
  virtual Number compute(const Number& x)
    pre noinherit (x.isReal() && x.realPart() >= 0)
    post noinherit (r : r.isReal() && r.realPart() >= 0)
    post inherit (r: approxEquals(r * r, x));
};
\end{codeblock}

Any design that offers the user this choice would need to answer a number of additional questions, such as the meaning of the \emph{default} syntax (see also \propref{InhDefault}) and whether an opt-out of \tcode{noinherit} should still be possible on the overridden function for use cases such as \propref{WidenPostIn}.

\prop{InhOptDerived}{Choose in the overriding function whether to inherit}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give the author of a derived class the option to explicitly inherit the overridden function's function contract assertions.

%TD: TODO: add example and motivation

\prop{CalleeOnly}{Check \tcode{pre} and \tcode{post} only when callee-facing}

TODO TAKE FROM D3097R1

\prop{CallerOnly}{Check \tcode{pre} and \tcode{post} only when caller-facing}
% TD: TODO: it's actually not caller only, it's "fully qualified call only"! Fix this, think of different identifier & description

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should give users the option to specify that a particular function contract assertion should only be evaluated if it applies to the statically called function in a virtual function call.

This can be useful for assertions that express contracts applying to the interface, but not the implementation of a function.

Consider a virtual function hierarchy where different implementations share a common interface
precondition:

% TD: TODO: can we come up with less "toy" examples?
\begin{codeblock}
struct Animal {
  virtual void eat(Food* foodPtr)
    pre (foodPtr && foodPtr->isEdible());
};

struct Cat : Animal {
  void eat(Food* foodPtr) override
    /* ... */;
}

struct Dog : Animal {
  void eat(Food* foodPtr) override
    /* ... */;
}
\end{codeblock}

Now, suppose we want to add a dummy implementation to the base class function \tcode{Animal::eat} --- perhaps for testing or prototyping purposes --- that does nothing and therefore works with any input value:

\begin{codeblock}
virtual void Animal::eat(Food* /* unused */) {
  // dummy implementation
}
\end{codeblock}

Complementary to property \propref{CalleeOnly}, we can add support for such \emph{interface contract assertions} (checked only if the function is the statically called function in a virtual function call) with an explicit syntactic marker, for example

\begin{codeblock}
struct Animal {
  virtual void eat(Food* foodPtr)
    pre interface (foodPtr && foodPtr->isEdible()) {
      // dummy implementation
    }
};
\end{codeblock}

The intention of the above code is that, in the case of invalid input, \tcode{Animal::eat} would raise a contract violation when called polymorphically but work fine when called directly via a fully qualified call:
\begin{codeblock}
int main {
  Animal testAnimal;
  testAnimal.eat(nullptr);  // contract violation
  testAnimal.Animal::eat(nullptr); // OK
};
\end{codeblock}

Note that this behaviour is incompatible with property \propref{FullQualEq}.

 and therefore is not subject to the same
preconditions as any of the overriding functions when called via a fully qualified call because such a
call can be made with any input value. The contract is therefore an interface contract, but not an
implementation contract.

% TD: TODO: Continue here

\subsubsection{Deployment requirements}

The following properties are relevant for the ability to deploy a design for \tcode{pre} and \tcode{post} on virtual functions to C++ code bases at scale.

\prop{FailFast}{Fail immediately on contract violation}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should continue to ensure, as C++26 Contracts do today, that the user can configure their program to fail immediately when any contract assertion fails. Consider a virtual function with a precondition assertion as follows:
\begin{codeblock}
struct Y : X {
  virtual void usePtr(void* ptr) 
    pre (ptr != nullptr);
}
\end{codeblock}
Whenever the assertion \mbox{\tcode{ptr != nullptr}} is evaluated with a checked semantic and the check fails, the contract-violation handler should be called and/or the program should be terminated (depending on the chosen evaluation semantic). The program should not attempt to evaluate other function contract assertions specified on functions overriding (or overridden by) \tcode{Y::usePtr} past the failed check. In particular, precondition assertions from different functions should not be OR-ed before determining whether a contract violation occurred.

The rationale for this property is as follows. Eiffel, which OR-s precondition assertions across the inheritance hierarchy, is a memory-safe language, while C++ is not. Unlike in Eiffel, in C++ continuing past any individual failed assertion check, regardless of where in an inheritance hierarchy it occurs, is potentially unsafe and may lead to undefined behaviour and security vulnerabilities. A design for supporting \tcode{pre} and \tcode{post} on virtual functions should not introduce new opportunities for such vulnerabilities.

% TD: TODO: this paragraph might be better positioned in the section talking about designs
%Note that this property seems at odds with \propref{SubstPr} and \propref{MeyerDbC}, because as far as we are aware, OR-ing preconditions is the only practically feasible design that allows an overriding function to widen the preconditions of the function it overrides, but prevents it from narrowing them.

\prop{BaseIndep}{\tcode{pre} and \tcode{post} should be usable independent of base}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow a client of a virtual function to override that function in a derived class, add function contract assertions to the overriding function, and have those assertions evaluated, even if the base class is written against an older C++ Standard and does not use contract assertions at all.

Consider a GUI framework with a \tcode{Widget} base class as follows:

\begin{codeblock}
class Widget {
public:
  // Preconditions:   
  // \phantom{xxx}\tcode{child} points to a \tcode{Widget};
  // \phantom{xxx}\tcode{child->isValid()} is \tcode{true}; 
  // \phantom{xxx}\tcode{zOrder} is between -32768 and +32767.
  virtual void addChildWidget (Widget* child, int zOrder);
  
// ...
};
\end{codeblock}
This GUI framework is third-party code that we do not control and cannot modify. The function \tcode{Widget::}\allowbreak\tcode{addChildWidget} has preconditions, but those are not checked with function contract assertions as the code predates the availability of the feature.

In our own codebase, we have a framework of custom widget types, all inheriting from the \tcode{Widget} class above. For our own custom widget types at least, we would like to introduce precondition assertions for checking the preconditions, in order to identify incorrect use and take advantage of the many benefits of precondition assertions over macro-based assertions:
\begin{codeblock}
class CustomWidget : public Widget {
public:
  void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767) 
  {
    // custom child/parent widget tracking logic here...
    Widget::addChildWidget(child, zOrder);
  }
}
\end{codeblock}
In order to be deployable in such codebases, a design for supporting \tcode{pre} and \tcode{post} on virtual functions needs to provide a way to have the function contract assertions of \tcode{CustomWidget::}\allowbreak\tcode{addChildWidget} evaluated whenever that function is called, without having to modify the \tcode{Widget}  base class.


\prop{NoRemoteBreak}{Avoid remote code breakage}

A design for supporting \tcode{pre} and \tcode{post} on virtual functions should allow the author of a base class to add function contract assertions to a virtual function without breaking correct uses of derived classes in remote client code.

Consider again the GUI framework from property \propref{BaseIndep}. As the owners of the base class \tcode{Widget}, we might want to introduce precondition assertions for checking the preconditions of \tcode{Widget::}\allowbreak\tcode{addChildWidget}, and roll out these assertions to clients that have a recent enough compiler to take advantage of them: 

\begin{codeblock}
class Widget {
public:
  virtual void addChildWidget(Widget* child, int zOrder) override
    pre (child && child->isValid())
    pre (zOrder >= -32768 && zOrder <= 32767);
}
\end{codeblock}

At the same time, one of our clients may have a widget type in their code base that can handle a wider range of values for \tcode{zOrder} just fine, and they may be using this type in production:

\begin{codeblock}
class SuperWidget : public Widget {
  // this version can handle any values for \tcode{zOrder}!
  void addChildWidget(Widget* child, int zOrder) override {
    // ....
  } 
}

class MyWindow : public SuperWidget;
class MyButton : public SuperWidget;
// ...

void drawMyApp() {
  myWindow.addChildWidget(myButton, 99999);
}
\end{codeblock}
As long as the client uses the \tcode{SuperWidget} interface instead of the base \tcode{Widget} interface for their widgets above, their program is correct --- there is no contract violation. In order to be deployable, adding the above function contract assertions to \tcode{Widget::}\allowbreak\tcode{addChildWidget} should not break the client's correct program by introducing a precondition assertion violation to it.


\subsubsection{Standardisation requirements}

The following properties describe general requirements that any proposal for supporting \tcode{pre} and \tcode{post} on virtual functions should meet in order to be considered for inclusion in the C++ Standard.

\prop{Wording}{Fully specified in C++ wording}

The proposed design should be fully specified in C++ wording that has been reviewed by at least one Core expert, and should have no known, unresolved specification issues. This is a standard requirement for language proposals before they can be forwarded to CWG for wording review and inclusion in the C++ working paper. 

The motivation is that without this property, we cannot claim that a proposed design has been fully specified and understood.

\prop{ImplExp}{Implementation experience}

The proposed design should be implemented \emph{completely} in at least one major C++ compiler front-end such as GCC, Clang, MSVC, or EDG. We do not require that the implementation has been upstreamed into the main branch of that compiler and shipped to users; an implementation on a dev branch is sufficient. However, we do require that the implementation is freely available to users in some form, for example by publishing the source code of the implementation or by making the branch in question available on Compiler Explorer.

The motivation for this requirement is that only actual implementation experience is acceptable proof of implementability. As long as a design only exists as a ``paper exercise'', even with wording, it is still possible that we overlooked some significant issues with that design.

% TD: TODO: we do not necessarily need this here, we can have it instead in the place where we discuss which designs fulfil which requirement
%If only an incomplete implementation of the design is available, or if the implementation is feature-complete but has significant unresolved issues, we consider the property having been met only partially. Similarly, if an implementation of an analogous design is available for a different programming language, we consider  the property having been met only partially, as programming languages such as Eiffel, D, and Ada are sufficiently different from C++ that proof of implementability in one language does not necessarily constitute proof of implementability in another.


% TD: specification existence?

\section{Design space}
\label{designs}

TODO

\section{Evolution graph}
\label{evolution}

TODO

\section{Conformance matrix}
\label{matrix}

TODO

\section{Decision tree}
\label{tree}

TODO

\section{Conclusion}
\label{conclusion}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
%Thanks to Oliver Rosten for his review of the paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}

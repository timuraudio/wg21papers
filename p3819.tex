\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Remove \tcode{evaluation_exception} from \\ contract-violation handling for C++26}
\author{
  Peter Bindels \small(\href{mailto:dascandy@gmail.com}{dascandy@gmail.com}) \\
  Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
  Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\ 
  Eric Fiselier \small(\href{mailto:eric@efcs.ca}{eric@efcs.ca}) \\
  Iain Sandoe \small(\href{mailto:iain@sandoe.co.uk}{iain@sandoe.co.uk})
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & P3819R0 \\
Date: &2025-09-01 \\
Project: & Programming Language C++ \\
Audience: & LEWG, LWG
\end{tabular}

\begin{abstract}
For C++26, we propose to remove the member function \tcode{evaluation_exception} from the type \tcode{std::contracts::contract_violation}. On some platforms, an implementation of this function may require user code execution after a contract violation but before the contract-violation handler, which may pose a security risk. We can add this function back in future versions of C++ if it can be shown that the security risk is fully avoidable. In the meantime, the functionality it offers is available through other means.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The status quo}

In the current C++26 working draft \cite{N5014}, the standard library API for contract-violation handling contains the type \tcode{std::contracts::contract_violation}. When the program has a user-defined contract-violation handler, and a contract violation occurs, the implementation constructs an object of this type and passes a reference to it into the contract-violation handler.

The  \tcode{std::contracts::contract_violation} type  provides access  to information about the violation, such as the source location of the violated assertion and the failure mode (did the contract predicate evaluate to \tcode{false}, or did evaluation of the predicate exit via an exception?) via a set of \tcode{const} member functions.

One of these member functions is \tcode{evaluation_exception}. It is specified as follows:

\begin{codeblock}
exception_ptr evaluation_exception() const noexcept;
\end{codeblock}

If the contract violation occurred because evaluation of the predicate exited via an exception, this function returns an \tcode{exception_ptr} to that exception; otherwise, it returns a null pointer.

The functionality offered by \tcode{evaluation_exception} is also available through other means. To determine whether evaluation of the predicate exited via an exception, we can check whether a call to the member function \mbox{\tcode{detection_mode}} returns the enum value \tcode{evaluation_exception}. If it does, we can call \tcode{std::current_exception} to obtain  an \mbox{\tcode{exception_ptr}} to that exception:
\begin{codeblock}
void handle_contract_violation (const contract_violation& cv) {
  if (cv.detection_mode() == detection_mode::evaluation_exception) {
    auto evaluation_exception_ptr = std::current_exception();
    // handle
}
\end{codeblock}
Further, to handle exceptions of a particular type, we can re-throw the current exception in the contract-violation handler and immediately catch it (this technique is called a Lippincott function):

\begin{codeblock}
void handle_contract_violation (const contract_violation& cv) {
  if (cv.detection_mode() == detection_mode::evaluation_exception) {
    try {
      throw;
    } catch (std::exception& e) {
      // handle 
    }
}
\end{codeblock}

However, these techniques are more verbose and require more care to use. If no exception was thrown during the contract check, but the user forgets to query \tcode{detection_mode()}, they will either fail (if no exception is currently being handled), or worse get an exception that is currently being handled but that was not the cause of the contract violation (this is possible if the contract violation occurred within a \tcode{catch} clause handling some other exception). 
The member function \mbox{\tcode{evaluation_exception}} was intended to give the user a simple and direct way to access the exception thrown during the contract check without having to worry about such cases.

\section{The problem}

When originally proposed in \cite{P3227R1}, there was an assumption that \tcode{evaluation_exception} would  essentially be syntactic sugar for the simple logic above --- check \tcode{detection_mode()} and invoke \tcode{std::current_exception} if that mode is \tcode{evaluation_exception}. However, a problem arises when an exception is thrown within a contract-violation handler and \tcode{evaluation_exception} is then invoked within the \tcode{catch} clause handling that internal exception:

\begin{codeblock}
void handle_contract_violation (const contract_violation& cv) {
  // ...
  try {
    // ...
    throw X;
  } catch (...) {
      if (cv.detection_mode() == detection_mode::evaluation_exception) {
      auto evaluation_exception_ptr = std::current_exception();
      // \tcode{evaluation_exception_ptr} is now \tcode{X},
      // not whatever was thrown by the contract check!
  }
}
\end{codeblock}

In order to always return the exception associated with the contract violation, even inside such a \tcode{catch} clause within the contract-violation handler, the implementation must do extra work to preserve access to that exception before invoking the contract-violation handler. In particular, since the adoption of \cite{P2900R14} for C++26 we have learned that on some platforms, this requires \emph{copying} the exception object before invoking the contract-violation handler. 

Requiring implementations to perform such a copy is problematic as it can lead to \emph{user code} being executed after a contract violation has been detected but before the associated contract-violation handler is called. This, in turn, may pose a security risk (see also \cite{P3417R1}).

When a contract violation has been detected, the program may be in an invalid state, for example a corrupted stack. The contract-violation handler is user code, but it is user code that is expected to be run in such circumstances, and can be written to be robust against them. On the other hand, the copy constructor of an arbitrary exception type will typically not be written with such robustness in mind. For example, it could walk the stack (one might want to save the stack trace at the time when the exception object was created or copied). This opens up a security vulnerability: an attacker could corrupt the stack and then use the exception copy constructor to jump to an arbitrary place and execute arbitrary code.

On platforms implementing the Itanium ABI (GCC, Clang), there is a known implementation strategy for   \tcode{evaluation_exception} that avoids such a copy of the exception object. However, for the Microsoft ABI, we were unfortunately so far unable to confirm the existence of such an implementation strategy. In the general case, the C++ exception API does not yet expose a way to implement this feature without potentially making a copy. Thus, implementing this function would put a new requirement on all future exception-handling implementations.

\section{Proposal}

The contract-violation handling mechanism in the C++26 working draft (originally proposed in \cite{P2811R7}) was carefully designed to avoid potential security risks. To this end, we consciously avoided executing user-defined code or mandating any operations that might be overly non-trivial after a contract violation has occurred but before the call to the contract-violation handler.

Unless and until we can be sure that \tcode{evaluation_exception} is implementable on all platforms without violating this design principle, we should not ship it in a C++ Standard. We therefore propose to remove the member function \tcode{evaluation_exception} entirely before shipping C++26. This function can easily be added back in future versions of C++ when we have a better understanding of the potential security risks.

In the meantime, users can access an exception thrown from a contract check through other means, such as by using \tcode{std::current_exception()} and Lippincott functions. As discussed above, these techniques have known gotchas, but they can be used correctly and efficiently and do not come with security concerns. On some platforms, accessing the exception may still incur a copy, but that copy happens inside the user-defined contract-violation handler, where the user has full control over it.

\section{Wording}

% TODO: LaTeX issues:
% I don't know how to \remove{...} within a codeblock environment so instead I use tcode and horrible hacks with \phantom to create the indentations
% Also, when you have a \tcode inside a \removed, having an underscore inside the \tcode leads to the underscore and everything past it to no longer be rendered in codefont, so I am using more horrible hacks to at least have all the non-underscore characters still in codefont...

The proposed wording is relative to \cite{N5014}. 

Modify the header \tcode{<contracts>} synopsis ([contracts.syn]) as follows:

\begin{adjustwidth}{0.5cm}{0.5cm}
\tcode{class contract_violation \{} \\
\phantom{\tcode{xx}} \emph{// no user-accessible constructor} \\
\tcode{public:} \\
\phantom{\tcode{xx}} \tcode{contract_violation(const contract_violation\&) = delete;} \\
\phantom{\tcode{xx}} \tcode{contract_violation\& operator=(const contract_violation\&) = delete;}  \\
\\
\phantom{\tcode{xx}} \emph{/* see below */} \tcode{\~contract_violation();} \\
\\
\phantom{\tcode{xx}} \tcode{const char* comment() const noexcept}; \\
\phantom{\tcode{xx}} \tcode{detection}_\tcode{mode detection}_\tcode{mode() const noexcept;} \\
\phantom{\tcode{xx}} \removed{\tcode{exception}_\tcode{ptr evaluation}_\tcode{exception() const noexcept;}} \\
\phantom{\tcode{xx}} \tcode{bool is_terminating() const noexcept;} \\
\phantom{\tcode{xx}} \tcode{assertion_kind kind() const noexcept;} \\
\phantom{\tcode{xx}} \tcode{source_location location() const noexcept;} \\
\phantom{\tcode{xx}} \tcode{evaluation_semantic semantic() const noexcept;} \\
\tcode{\};}
\end{adjustwidth}

Remove the following paragraph from [support.contract.violation]:

\begin{adjustwidth}{0.5cm}{0.5cm}
\removed{\tcode{exception_}}\removed{\tcode{ptr evaluation_}}\removed{\tcode{exception() const noexcept;}}

\removed{\emph{Returns}:  If the contract violation occurred because the evaluation of the predicate
exited via an exception, an \tcode{exception}_\tcode{ptr} object that refers to that exception or a
copy of that exception; otherwise, a null \tcode{exception}_\tcode{ptr} object.}
\end{adjustwidth}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}

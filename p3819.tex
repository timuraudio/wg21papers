\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Remove \tcode{evaluation_exception} from \\ contract-violation handling for C++26}
\author{
  Peter Bindels \small(\href{mailto:dascandy@gmail.com}{dascandy@gmail.com}) \\
  Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
  Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\ 
  Eric Fiselier \small(\href{mailto:eric@efcs.ca}{eric@efcs.ca}) \\
  Iain Sandoe \small(\href{mailto:iain@sandoe.co.uk}{iain@sandoe.co.uk})
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & P3819R0 \\
Date: &2025-09-01 \\
Project: & Programming Language C++ \\
Audience: & EWG
\end{tabular}

\begin{abstract}
For C++26, we propose to remove the member function \tcode{evaluation_exception} from the type \tcode{std::contracts::contract_violation}. On some platforms, an implementation of this function may require user code execution after a contract violation but before the contract-violation handler, which may pose a security risk. We can add this function back in future versions of C++ if it can be shown that the security risk is fully avoidable. In the meantime, the functionality it offers is available through other means.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The status quo}

In the current C++26 working draft \cite{N5014}, the standard library API for contract-violation handling contains the type \tcode{std::contracts::contract_violation}. When the program has a user-defined contract-violation handler, and a contract violation occurs, the implementation constructs an object of this type and passes a reference to it into the contract-violation handler.

The  \tcode{std::contracts::contract_violation} type  provides access  to information about the violation, such as the source location of the violated assertion and the failure mode (did the contract predicate evaluate to \tcode{false}, or did evaluation of the predicate exit via an exception?) via a set of \tcode{const} member functions.

One of these member functions is \tcode{evaluation_exception}, introduced in \cite{P3227R1}. It is specified as follows:

\begin{codeblock}
exception_ptr evaluation_exception() const noexcept;
\end{codeblock}

If the contract violation occurred because evaluation of the predicate exited via an exception, this function returns an \tcode{exception_ptr} to that exception; otherwise, it returns a null pointer.

The functionality offered by \tcode{evaluation_exception} is also available through other means. To determine whether evaluation of the predicate exited via an exception, we can query \mbox{\tcode{detection_mode()}}. If it did, we can then call \tcode{std::current_exception()} to obtain  an \mbox{\tcode{exception_ptr}} to that exception:
\begin{codeblock}
void handle_contract_violation (const contract_violation& cv) {
  if (cv.detection_mode() == detection_mode::evaluation_exception) {
    auto evaluation_exception_ptr = std::current_exception();
    // handle
}
\end{codeblock}
Further, if the type of the exception is known, we can re-throw the current exception in the contract-violation handler and immediately catch it (this technique is called a Lippincott function):

\begin{codeblock}
void handle_contract_violation (const contract_violation& cv) {
  if (cv.detection_mode() == detection_mode::evaluation_exception) {
    try {
      throw;
    } catch (std::exception& e) {
      // handle 
    }
}
\end{codeblock}

However, these techniques are more verbose and require more care to use. For example, it is possible that no exception was thrown during the contract check, but the contract violation occurred within the \tcode{catch} clause for some other exception. In this case, if the user accesses the current exception in the contract-violation handler but forgets to query \tcode{detection_mode()}, they will instead get that  other exception. Further, if an exception was thrown during the contract check, but then inside the contract-violation handler another exception is being thrown and handled, the current exception will be that other exception:

\begin{codeblock}
void handle_contract_violation (const contract_violation& cv) {
  // ...
  try {
    // ...
    throw X;
  } catch (...) {
      if (cv.detection_mode() == detection_mode::evaluation_exception) {
      auto evaluation_exception_ptr = std::current_exception();
      // \tcode{evaluation_exception_ptr} is now \tcode{X},
      // not whatever was thrown by the contract check!
  }
}
\end{codeblock}

The member function \tcode{evaluation_exception} was intended to give the user a simple and reliable way to access the exception thrown during the contract check without having to worry about cases such as the above.

\section{The problem}

For the member function \tcode{evaluation_exception} to work correctly in all cases (including when another exception is being thrown and caught in the contract-violation handler), the implementation effectively needs to ``capture'' the exception object thrown during a contract check. Since the adoption of \cite{P2900R14} for C++26, we have learned that on some platforms, implementing this behaviour requires copying the exception object at the point when the \tcode{contract_violation} object is being created, i.e., before the contract-violation handler is called.

However, requiring implementations to perform such a copy is problematic as it can lead to user code being executed after a contract violation has been detected but before the associated contract-violation handler is called. This, in turn, may pose a security risk (see also \cite{P3417R1}).

When a contract violation has been detected, the program may be in an invalid state, for example a corrupted stack. The contract-violation handler is user code, but it is user code that is expected to be run in such circumstances, and can be written to be robust against them. On the other hand, the copy constructor of an arbitrary exception type will typically not be written with such robustness in mind. For example, it could walk the stack (one might want to save the stack trace at the time when the exception object was created or copied). This opens up a security vulnerability: an attacker could corrupt the stack and then use the exception copy constructor to jump to an arbitrary place and execute arbitrary code.

On platforms implementing the Itanium ABI (GCC, Clang), there is a known implementation strategy for   \tcode{evaluation_exception} that avoids such a copy of the exception object. However, for the Microsoft ABI, we were unfortunately so far unable to confirm the existence of such an implementation strategy. We also do not currently understand the implications for platforms beyond the major three.

\section{Proposal}

The contract-violation handling mechanism in the C++26 working draft (originally proposed in \cite{P2811R7}) was carefully designed to avoid potential security risks. To this end, we consciously avoided executing user-defined code or mandating any operations that might be overly non-trivial after a contract violation has occurred but before the call to the contract-violation handler.

Unless and until we can be sure that \tcode{evaluation_exception} is implementable on all relevant platforms without violating this design principle, we should not ship it in a C++ Standard. We therefore propose to remove the member function \tcode{evaluation_exception} entirely before shipping C++26. This function can easily be added back in future versions of C++ when we have a better understanding of the potential security risks.

In the meantime, users can access an exception thrown from a contract check through other means, such as by using \tcode{std::current_exception()} and Lippincott functions. As discussed above, these techniques have known gotchas, but they can be used correctly and efficiently and do not come with security concerns. On some platforms, accessing the exception may still incur a copy, but that copy happens inside the user-defined contract-violation handler, where the user has full control over it.

\section{Wording}

% TODO: LaTeX issues:
% I don't know how to \remove{...} within a codeblock environment so instead I use tcode and horrible hacks with \phantom to create the indentations
% Also, when you have a \tcode inside a \removed, having an underscore inside the \tcode leads to the underscore and everything past it to no longer be rendered in codefont, so I am using more horrible hacks to at least have all the non-underscore characters still in codefont...

The proposed wording is relative to \cite{N5014}. 

Modify the header \tcode{<contracts>} synopsis ([contracts.syn]) as follows:

\begin{adjustwidth}{0.5cm}{0.5cm}
\tcode{class contract_violation \{} \\
\phantom{\tcode{xx}} \emph{// no user-accessible constructor} \\
\tcode{public:} \\
\phantom{\tcode{xx}} \tcode{contract_violation(const contract_violation\&) = delete;} \\
\phantom{\tcode{xx}} \tcode{contract_violation\& operator=(const contract_violation\&) = delete;}  \\
\\
\phantom{\tcode{xx}} \emph{/* see below */} \tcode{\~contract_violation();} \\
\\
\phantom{\tcode{xx}} \tcode{const char* comment() const noexcept}; \\
\phantom{\tcode{xx}} \tcode{detection}_\tcode{mode detection}_\tcode{mode() const noexcept;} \\
\phantom{\tcode{xx}} \removed{\tcode{exception}_\tcode{ptr evaluation}_\tcode{exception() const noexcept;}} \\
\phantom{\tcode{xx}} \tcode{bool is_terminating() const noexcept;} \\
\phantom{\tcode{xx}} \tcode{assertion_kind kind() const noexcept;} \\
\phantom{\tcode{xx}} \tcode{source_location location() const noexcept;} \\
\phantom{\tcode{xx}} \tcode{evaluation_semantic semantic() const noexcept;} \\
\tcode{\};}
\end{adjustwidth}

\pagebreak % MANUAL, TO AVOID HANGING PARAGRAPH

Remove the following paragraph from [support.contract.violation]:

\begin{adjustwidth}{0.5cm}{0.5cm}
\removed{\tcode{exception_}}\removed{\tcode{ptr evaluation_}}\removed{\tcode{exception() const noexcept;}}

\removed{\emph{Returns}:  If the contract violation occurred because the evaluation of the predicate
exited via an exception, an \tcode{exception}_\tcode{ptr} object that refers to that exception or a
copy of that exception; otherwise, a null \tcode{exception}_\tcode{ptr} object.}
\end{adjustwidth}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}

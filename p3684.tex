\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Fix erroneous behaviour termination semantics for C++26}
\author{
  Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
  Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) 
  % TODO: try to get Thomas Koppe
  % TODO: try to get sanitiser person
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3684R0 \\
Date: &2025-09-18 \\
Project: & Programming Language C++ \\
Audience: & EWG
\end{tabular}

\begin{abstract}
We propose a small adjustment to the specification of erroneous behaviour in C++26. The current specification gives the implementation  freedom to terminate the program at any arbitrary point after erroneous behaviour has occurred. This specification is an impediment to applying the concept of erroneous behaviour more broadly across the C++ language, and prevents consistency in semantics between erroneous values and other types of implicit contract violations. We introduce an improved specification for program termination following erroneous behaviour that removes these impediments while retaining full compatibility with existing implementations.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Motivation and context}

C++26 introduces the concept of \emph{erroneous behaviour}: behaviour that is known to be incorrect yet is not undefined. It also introduces one concrete instance of erroneous behaviour: in C++26, reading a default-initialised variable of automatic storage duration and scalar type now produces an erroneous value instead of an indeterminate value; where using an indeterminate value has undefined behavior, use of an erroneous values instead has erroneous behaviour. This removal of undefined behaviour is designed to mitigate existing (and actively exploited) security vulnerabilities.

Beyond that one instance of erroneous behaviour, \cite{P2795R5} contains a section with a tentative list of other cases of undefined behaviour that could be replaced with erroneous behaviour in the future. \cite{P2973R0} proposes to do so concretely for the case of missing return from assignment. \cite{P3100R4} goes further and proposes to replace undefined behaviour with erroneous behaviour systematically across the entire C++ Standard for all cases in which plausible replacement behaviour exists; the paper identifies 16 such cases.

The core language UB white paper \cite{P3656R1} currently pursued by EWG recognises erroneous behaviour as one of three key tools to address the issues caused by undefined behaviour in C++ (Contracts and Profiles being the other two). \cite{P3229R0} points out the isomorphism between the semantics of erroneous behaviour and those of well-defined code following a failed contract assertion. That paper proposes a path towards making erroneous behaviour and implicit contract assertions fully consistent and synergetic with each other.

Given the important role of erroneous behaviour for the future evolution of C++, we should ensure that the specification we ship in C++26 is forward-compatible with a broader application of this concept, beyond the immediate benefit of some uninitialised reads no longer being undefined.

\section{The problem}

In the current C++26 working draft \cite{N5014}, the evaluation semantics of erroneous behaviour are specified as follows (\href{https://eel.is/c++draft/intro.abstract#6.sentence-5}{[intro.abstract]}):
\begin{adjustwidth}{0.5cm}{0.5cm}
If the execution contains an operation specified as having erroneous behaviour, the implementation is permitted to issue a diagnostic and is permitted to terminate the execution at an unspecified time after that operation.
\end{adjustwidth} 
With this specification, a program effectively enters an ``erroneous state'' once any erroneous behaviour happens, and may be unceremoniously terminated at any arbitrary point after that.  The expectation is that it will be either reasonably soon or never, but the specification gives significantly more implementation freedom, making it much harder to reason about the behaviour of the program.

At the time of writing, two flavours of \cite{P2795R5} implementations exist. Clang and GCC offer the flag \mbox{\tcode{-ftrivial-auto-var-init}}, which initialises default-initialised variables of automatic storage duration and scalar type to a fixed repeating pattern or to zero. This strategy removes the undefined behaviour but with the caveat that it never exhibits the encouraged behaviour of diagnosing an error.

On the other hand, MemorySanitizer implements the detection of such erroneous reads, terminating with a diagnostic message some time after an erroneous read happens.
As the mapping of code in C++ to  post-optimisation machine instructions can often be unintuitive, the implementation  of such checks is typically done as instrumentation of compiled code.  In particular, the exact place where an erroneous read occurs can be rolled into many subsequent operations, and it is those subsequent operations where a diagnostic could potentially be emitted, not the initial read.  The case that can actually be caught is often a branch that occurs whose condition is dependent on an uninitialised value, and that branch might be very far removed from where the first read of the uninitialised value occurs in the abstract machine. This implementation strategy is the original motivation for the ``delayed termination'' that currently features in the specification for erroneous behaviour.

Memory sanitizer itself does not, however, delay identification of erronenous behaviour indefinitely.  Instead, because it is detecting branches that are dependent on erronneous bits it will terminate a program only during some evaluations that make use of values that were read from uninitialized storage.   Therefore, to leave the behaviour of memory santizer as a conforming implementation we do not need a blanket permission to terminate a program at any time after an erroneous operation has taken place.  Memory santiziers actually tracks this dependence on uninitialized values at the bit level, focusing on trapping in only those evaluations that have behaved differently based on erroneous values.

In our expectation, no real-world implementation will detect any form of erroneous behavior, set a timer, wait an arbitrary time, and then terminate the program while it is doing something completely unrelated.  Such an approach to notifying users of a bug would lead to undiagnosable problems in a scenario where we are activelys striving to increase the predictability and reliability of our software even in the face of incorrect behavior.   The current specification of erroneous behaviour allows this choice unnecessarily. It also does not fit the other cases of undefined behaviour which we may replace with erroneous behaviour in future versions of C++ (see \cite{P3100R4}), and actively prevents establishing consistency in semantics between erroneous values and other types of implicit contract violations (see \cite{P3229R0}).

Overall our goal is to update the specification of erroneous behavior and erroneous values to achieve certain key properties:
\begin{itemize}
\item Existing implementations that trap on the use of uninitialized values, such as msan, will remain conforming implementations and retain the ability to trap when they do with no need for modifications.
\item When a program terminates because of erroneous behavior we will have the ability to reason locally about why it terminated, without needing to identfiy all possible previous executions that might have been erroneous.
\item When a program is in a running state and \emph{not} performing any erroneous operations we can reliably count on it not terminating due to earlier misbehaviors.
\end{itemize}

\section{Proposal}

To fix the issue while retaining compatibility between the specification and existing implementations such as MemorySanitizer, we propose to remove the ``delayed termination'' aspect from the specification and instead to make erroneous values ``sticky''.  The current specification takes the approach that once you read an erroneous value, the value itself is ``cleaned'' and no longer toxic, but that comes at the cost of putting your entire program in what is essentially a toxic state. By having erroneous values instead propagate with the data, we can extend the scope of the problematic data sufficiently to cover all realistic implementations while avoiding the more toxic threat of eventual and surprising termination at a later time.

In practice, we do not expect the erroneous-ness of a value to transport beyond a single function or translation unit, but we should still allow for that possibility if a platform chooses to do so.   Therefore, we make any operation whose result is dependent on an erroneous value produce an erroneous value. Since any such operation is erroneous behaviour, the implementation is free to either issue a diagnostic and/or terminate the program at that point, or to just move on (as neither the diagnostic nor the termination are normatively required). Such a program is now no longer under threat of unexpected termination, while leaving maximal flexibility for detecting the bug when it is most convenient to do so.

For built-in operations that use an erroneous value but whose result does not actually depend on that value --- multiplying by $0$, mod-ing by $1$, and similar cases --- we can produce a ``clean'' non-erroneous value.  This would, however, only be sound when the result of an operation is guaranteed to not be dependent on the particular erroneous value being used.  For floating-point values there are almost no operations that have this property, as the erroneous value could always be a NaN (binary operations with a non-erroneous NaN will always result in a NaN, but this does not seem like a useful case to give special treatment).   For integral values on most platforms we can state results more definitively, but the standard allows for integers that have trapping values or similar unexpected behavior, so even then we cannot definitively say that any operations have a result that is completely independent of the value of one of its operands.

On the other hand, any platform can choose to treat erroneous values as non-erroneous under any condition --- our specification does not put any strict requirements the  erroneousness of a value can be detected within the abstract machine.   Therefore implementations will always be free to improve their quality by identifying values that are truly independent of erroneous inputs and not terminating when those values are used.

In the future, the Standard can also further narrow the set of values that are treated as erroneous by identifying cases where the resulting value is completely independent of an erroneous operand.  For example, if we have an expression that meets all of the following conditions, we could consider making the resulting zero value non-erroneous (and msan effectively does):
\begin{itemize}
\item The operator is multiplication (\tcode{*}).
\item The result type is an integer type.
\item One operand is an erroneous operand of a type that has no NaN or trapping values.
\item The other operand is a non-errroneous .
\end{itemize}
Similar rules could be written when using the mod (\tcode{\%}) operator with a $1$ value as the righthand argument, using bitwise operators with $0$ and all-$1$ operands, or various bit-shift operations.   On the other hand, these rules are complicated, not universally portable, and do nothing but make questionable code slightly less questionable.   Therefore we recommend, at least initially, having all expressions that make use of an erroneous value result in an erroneous value.

One subtlety to note is how this interacts with the short-circuiting logical operators.  These do not even evaluate their second operand if the first operand determines their result.  For these operators we will never actually evaluate a short-circuited subexpression to even know if its values is erroneous, and thus we need to restrict our propagation of erronneous values to come only from those operands that are themselves actually evaluated.



\section{Wording}

The proposed wording is relative to \cite{N5014}. 

Modify [intro.abstract] paragraph 6 as follows:

\begin{adjustwidth}{0.5cm}{0.5cm}
A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this document places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation). If the execution contains an operation specified as having erroneous behavior, the implementation is permitted to issue a diagnostic and is permitted to terminate the execution\removed{ at an unspecified time after that operation}.
\end{adjustwidth}


Modify [basic.indet], paragraph 2 as follows:

\begin{adjustwidth}{0.5cm}{0.5cm}
\begin{addedblock}
If an erroneous value is produced by the evaluation of any builtin operation, the behavior is erroneous.
If any operand of a built-in operator is evaluated and produces an erroneous value then the value
produced by that operator is erroneous.
\end{addedblock}

Except in the following cases, if an indeterminate value is produced by an evaluation,
the behavior is undefined  and if an erroneous value is produced by an evaluation, the behavior is erroneous and
the result of the evaluation is the value so produced \removed{but is not erroneous}
\added{and it is erroneous}:
\begin{itemize}
\item If an indeterminate or erroneous value of unsigned ordinary character type ([basic.\allowbreak{}fundamental]) or \tcode{std::byte} type ([cstddef.syn]) is produced by the evaluation of:  \\ ...
\end{itemize}
% TD: I actually don't understand this second bullet list (as written), does all this still apply?
\end{adjustwidth}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Acknowledgements}
Thanks to  Richard Smith, Thurston Dang, Thomas K\"{o}ppe, and Iain Sandoe for providing valuable feedback on this paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}

\input{wg21common}

\begin{document}
\title{A natural syntax for Contracts}
\author{ Jens Maurer \small(\href{mailto:jens.maurer@gmx.net}{jens.maurer@gmx.net}) \\
 Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio})}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & P2961R0 \\
Date: &2023-09-14 \\
Project: & Programming Language C++ \\
Audience: & SG21
\end{tabular}

\begin{abstract}
We propose a syntax for Contracts that naturally fits into existing C++, does not overlap with the design space of other C++ features such as attributes or lambdas, is intuitive, lightweight and elegant, and designed to aid readability by emphasising the primary information. The proposed syntax removes the weaknesses of attribute-like and closure-based syntax while maintaining full compatibility and extensibility in line with the SG21 requirements for a Contracts syntax.
\end{abstract}

\section{Motivation}
\label{sec:motivation}

SG21 is currently working on standardising a first version of a Contracts facility --- the so-called \emph{Contracts MVP}. According to our roadmap \cite{P2695R1}, the last remaining major design decision is the choice of syntax. The syntax proposal currently under consideration is the so-called attribute-like syntax (\cite{P2935R0}). While attribute-like syntax has its strengths --- existing implementation experience in GCC (see \cite{P1680R0}) and the possibility to lean on existing standard attribute grammar rather than inventing new grammar --- it also has considerable weaknesses.

Attribute-like syntax uses \tcode{[[ ... ]]} delimiter tokens around every contract-checking annotation. This has been called a ``heavy'' syntax and is  perceived as ``ugly'' by some users. It also makes contract-checking annotations look like standard attributes, even though they are not attributes and do not behave as such (see \cite{P2487R1}), creating confusion. Further, such use of delimiter tokens makes it difficult to distinguish the primary information (the predicate, contract kind, and name for the return value) from secondary information (such as labels that could be added post-MVP) as it crams all these parts into a flat sequence in the same syntactic space and leads to potential parsing ambiguities that need to be resolved if we wish to add post-MVP features like labels, closures, or the ability to destructure the return value. The latter two also lead to awkward-looking syntax involving square brackets inside double square brackets.

The syntactic position of a contract-checking annotation using attribute-like syntax is also problematic. If we wish to re-use the existing standard attribute grammar, then preconditions and postconditions need to go before any trailing return type, virtual specifiers, and a \tcode{requires} clause, which is awkward and requires delayed parsing of postconditions; and assertions need to appertain to a null statement, which means they cannot be used freely as an expression and cannot serve as a full drop-in replacement for C \tcode{assert}.

On the other hand, if we place attribute-like preconditions and postconditions at the end of a function declaration, and/or allow attribute-like assertions to be expressions rather than statements, we need to place attribute-like entities at a novel syntactic position that is not currently supported for standard attributes, and that we do not have implementation experience with, throwing away the main advantage of attribute-like syntax. Finally, we cannot have standard attributes appertaining to an attribute-like contract-checking annotation or specify certain other post-MVP extensions such as procedural interfaces without introducing novel grammar for attributes nested inside attributes.

In this paper, we propose a new natural, lightweight, and intuitive syntax for Contracts that solves all of the above problems.
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Prior work}

The first proposed alternative to attribute-like syntax was closure-based syntax \cite{P2461R1}. Closure-based syntax remedies many of the issues with attribute-like syntax, but creates other issues of its own. It places the predicate between curly braces, which is awkward: normally, in C++ we place statements between braces but expressions between parentheses, and the predicate is an expression. Furthermore, it makes a contract-checking annotation look very much like a lambda, even though the two features have almost nothing in common.

The second proposed alternative was condition-centric syntax \cite{P2737R0}. It was not a complete proposal, as it did not consider any post-MVP features such as captures, \tcode{requires} clauses, and labels on contract-checking annotations. But it was the first proposal to use the basic syntax structure that we use here as well:

\phantom{~~~}\tcode{\emph{contract-kind} ( \emph{predicate} ) }

Along with this basic syntax structure, \cite{P2737R0} proposed a series of other design choices orthogonal to the choice of syntax, in particular:

\begin{itemize}
\item to rename ``assertion'' to the newly coined term ``incondition'',
\item to use \tcode{precond}, \tcode{postcond}, and \tcode{incond}, instead of \tcode{pre}, \tcode{post}, and \tcode{assert}, respectively,
\item to make all three of the above \emph{full} keywords rather than contextual keywords,
\item to use a predefined identifier \tcode{result} for the return value of a function instead of letting the user introduce their own name.
\end{itemize}

The above design choices have been poorly received in SG21. Instead of abandoning these additional design choices and instead focusing on the basic syntax structure, which was received with interest, the author chose to abandon the whole proposal.

In this paper, we improve upon both closure-based and condition-centric syntax. We adopt many of the ideas of closure-based syntax, in particular the lack of delimiter tokens around the contract-checking annotation and the syntax for captures. However, instead of using the problematic curly braces, we use parentheses around the predicate, following the basic syntax structure of the condition-centric syntax \cite{P2737R0} but without adopting any of the other design choices from that paper.

Building on these ideas, we developed a complete syntax proposal that is fit for purpose in the Contracts MVP and accommodates all relevant post-MVP extensions such as captures, \tcode{requires} clauses, and labels on contract-checking annotations.

The author of the closure-based syntax has reviewed our proposal and decided to discontinue the closure-based syntax in favour of our proposal as it subsumes the ideas of the closure-based syntax and improves upon it. We are therefore left with attribute-like syntax and our proposal as the only two still active proposals for a Contracts syntax.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Design goals}
\label{sec:design}

We focus on the following design goals, which we believe are not sufficiently met by attribute-like or closure-based syntax:

\begin{itemize}
\item The syntax should fit naturally into existing C++. The intent should be intuitively understandable by users unfamiliar with contract-checking annotations without creating any confusion.
\item A contract-checking annotation should not resemble an attribute, a lambda, or any other pre-existing C++ construct. It should sit in its own, instantly recognisable design space.
\item The syntax should feel elegant and lightweight. It should not use more tokens and characters than necessary.
\item To aid readability, the syntax should visually emphasise the primary information, that is, the contract predicate and the parts of a contract-checking annotation that may affect how the predicate is parsed: the contract kind, the name for the return value, and (post MVP) the captures. These should be syntactically separated from secondary information about the contract, such as (post MVP) labels to control the contract semantic.
\end{itemize}

 At the same time, we maintain all the other desirable properties that attribute-like and closure-based syntax offer, such as compatibility (no parsing ambiguities, no breakage or change in meaning of existing C++ code) and extensibility (a natural path for evolution in the post-MVP directions that SG21 considers relevant).
 
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The proposal}

\subsection{Grammar}

We propose the following additions to the C++ grammar for the Contracts MVP:

\begin{adjustwidth}{0.5cm}{0.5cm}

\emph{init-declarator:} \\
\phantom{~~~}\emph{declarator} \emph{initializer}$_{opt}$ \\
\phantom{~~~}\emph{declarator} \emph{requires-clause} \\
\phantom{~~~}\added{\emph{declarator} \emph{requires-clause}$_{opt}$ \emph{pre-or-post-condition-seq}}

\emph{member-declarator:} \\
\phantom{~~~}\emph{declarator} \emph{virt-specifier}$_{opt}$ \emph{pure-specifier}$_{opt}$ \added{\emph{pre-or-post-condition-seq}$_{opt}$} \\
\phantom{~~~}\emph{declarator} \emph{requires-clause} \\
\phantom{~~~}\added{\emph{declarator} \emph{requires-clause}$_{opt}$ \emph{pre-or-post-condition-seq}} \\
\phantom{~~~}\emph{declarator} \emph{brace-or-equal-initializer}$_{opt}$ \\
\phantom{~~~}\emph{identifier}$_{opt}$ \emph{attribute-specifier-seq}$_{opt}$ \tcode{:} \emph{brace-or-equal-initializer}$_{opt}$

\emph{function-definition:} \\
\phantom{~~~}\emph{attribute-specifier-seq}$_{opt}$ \emph{decl-specifier-seq}$_{opt}$ \emph{declarator} \emph{virt-specifier-seq}$_{opt}$  \\
\phantom{~~~~~~}\added{\emph{pre-or-post-condition-seq}$_{opt}$} \emph{function-body}\\
\phantom{~~~}\emph{attribute-specifier-seq}$_{opt}$ \emph{decl-specifier-seq}$_{opt}$ \emph{declarator} \emph{requires-clause} \\ 
\phantom{~~~~~~}\added{\emph{pre-or-post-condition-seq}$_{opt}$} \emph{function-body}

\pagebreak %% MANUAL %%%%%%%%%%%%%

\emph{lambda-declarator:} \\
\phantom{~~~}\emph{lambda-specifier-seq} \emph{noexcept-specifier}$_{opt}$ \emph{attribute-specifier-seq}$_{opt}$ \\
\phantom{~~~~~~}\emph{trailing-return-type}$_{opt}$ \added{\emph{pre-or-post-condition-seq}$_{opt}$}\\
\phantom{~~~}\emph{noexcept-specifier} \emph{attribute-specifier-seq}$_{opt}$ \emph{trailing-return-type}$_{opt}$ \added{\emph{pre-or-post-condition-seq}$_{opt}$} \\
\phantom{~~~}\emph{trailing-return-type}$_{opt}$ \added{\emph{pre-or-post-condition-seq}$_{opt}$}\\
\phantom{~~~}\tcode{(} \emph{parameter-declaration-clause} \tcode{)} \emph{lambda-specifier-seq}$_{opt}$ \emph{noexcept-specifier}$_{opt}$ \\ \phantom{~~~~~~}\emph{attribute-specifier-seq}$_{opt}$ \emph{trailing-return-type}$_{opt}$ \emph{requires-clause}$_{opt}$ \added{\emph{pre-or-post-condition-seq}$_{opt}$}

\emph{unary-expression:} \\
\phantom{~~~}\emph{postfix-expression} \\
\phantom{~~~}\emph{unary-operator cast-expression} \\
\phantom{~~~}\tcode{++} \emph{cast-expression} \\
\phantom{~~~}\tcode{--} \emph{cast-expression} \\
\phantom{~~~}\emph{await-expression} \\
\phantom{~~~}\tcode{sizeof} \emph{unary-expression} \\
\phantom{~~~}\tcode{sizeof (} \emph{type-id} \tcode{)} \\
\phantom{~~~}\tcode{sizeof ... (} \emph{identifier} \tcode{)} \\
\phantom{~~~}\tcode{alignof (} \emph{type-id} \tcode{)} \\
\phantom{~~~}\emph{noexcept-expression} \\
\phantom{~~~}\emph{new-expression} \\
\phantom{~~~}\emph{delete-expression} \\
\phantom{~~~}\added{\emph{assert-expression}}

\added{\emph{pre-or-post-condition:}} \\
\phantom{~~~}\added{\tcode{pre} \emph{contract}} \\
\phantom{~~~}\added{\tcode{post} \emph{contract}}

\added{\emph{pre-or-post-condition-seq:}} \\
\phantom{~~~}\added{\emph{pre-or-post-condition} \emph{pre-or-post-condition-seq}$_{opt}$}

\added{\emph{assert-expression:}} \\
\phantom{~~~}\added{\tcode{assrt} \emph{contract}}

\added{\emph{contract:}} \\
\phantom{~~~}\added{\emph{contract-condition}} \phantom{~~~}\emph{// can be expanded post-MVP, see section 5}

\added{\emph{contract-condition:}} \\
\phantom{~~~}\added{\tcode{(} \emph{return-name}$_{opt}$ \emph{conditional-expression} \tcode{)}}

\added{\emph{return-name:}} \\
\phantom{~~~}\added{\emph{identifier} \tcode{:}}

\end{adjustwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Natural syntax for preconditions and postconditions}

To add a precondition (or postcondition) to a function declaration, we simply write \tcode{pre} (or \tcode{post}), followed by the predicate in parentheses:

\vspace{2mm}
\begin{codeblock}
float sqrt(float x)
  pre (x >= 0);
\end{codeblock}
\vspace{2mm}

This is a very natural syntax, as it is using parentheses in the same way as other language constructs that have a predicate: \tcode{if (\emph{expr})}, \tcode{while (\emph{expr})}, etc.

To introduce a name for the return value of a function, you write it immediately before the predicate, followed by a colon:

\vspace{2mm}
\begin{codeblock}
int f(int x)
  post (r: r > x);
\end{codeblock}
\vspace{2mm}

Here, \tcode{pre} and \tcode{post} are contextual keywords. As we will see in section \ref{subsec:noambig} below, it is fine to use them as an identifier in all other parts of the function declaration, therefore not breaking any existing code. Preconditions and postconditions are the last part of a function declaration, immediately before the semicolon (or the opening brace if the declaration is a definition):

\vspace{2mm}
\begin{codeblock}
template <typename T>
auto f(T x) -> bool
  requires std::integral<T>
  post (x > 0);
\end{codeblock}
\vspace{2mm}

This order is consistent with the natural order of reading a function declaration: typically, the reader will first want to see the function signature and whether it is virtual, then any compile-time constraints (the \tcode{requires} clause), and finally any runtime constraints (the contract-checking annotations).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{No parsing ambiguities}
\label{subsec:noambig}

It has been suggested that the syntax proposed here might create parsing ambiguities with the other parts of a function declaration, such as a trailing return type or \tcode{requires} clause, if \tcode{pre} or \tcode{post} are used as identifiers for variables, functions, or types; but this is not actually the case. The grammar for a trailing return type is \tcode{->} \emph{type-id}, and we can unambiguously tell when that \emph{type-id} ends and a \emph{pre-or-postcondition} begins:

\vspace{2mm}
\begin{codeblock}
auto f() -> pre pre(a);   // OK, \tcode{pre} is the return type, \tcode{pre(a)} the precondition
auto g() -> pre<post> pre(a);  // OK, \tcode{pre<post>} is the return type, \tcode{pre(a)} the precondition
\end{codeblock}
\vspace{2mm}

Further, note that \tcode{requires} clauses use a restricted grammar where the expression following the \tcode{requires} keyword must be a \emph{primary-expression} or a sequence of \emph{primary-expression}s combined with the \tcode{\&\&} or \tcode{||} operators. Any other type of expression, such as a mathematical expression, a cast, or a function call, must be surrounded by parentheses, otherwise the program is ill-formed:

\vspace{2mm}
\begin{codeblock}
template <typename T>
void g() requires pre(a);   // ill-formed today

template <typename T>
void h() requires (pre(a));   // OK

template <typename T>
void j() requires (b)pre(a);   // ill-formed today

template <typename T>
void k() requires ((b)pre(a));   // OK

template <typename T>
void l() requires a < b > pre(a);   // ill-formed today

template <typename T>
void m() requires (a < b > pre(a));   // OK

\end{codeblock}
\vspace{2mm}

Therefore, just like with the trailing return type, we can unambiguously tell when the expression ends and a \emph{pre-or-postcondition} begins:

\vspace{2mm}
\begin{codeblock}
template <typename T>
void f() requires (b) pre(a);   // OK, \tcode{pre(a)} is the precondition

template <typename T>
void g() requires a < b > pre(a);   // OK, \tcode{pre(a)} is the precondition
\end{codeblock}
\vspace{2mm}

There are further no parsing ambiguities when any given precondition (or postcondition) ends and the next one begins, as the predicate must always be surrounded by parentheses. Therefore, it is also OK to use \tcode{pre} and \tcode{post} as identifiers inside the predicate. They are parsed as keywords only in the syntactic place where they act as such, everywhere else the usual grammar rules apply:

\vspace{2mm}
\begin{codeblock}
void f(bool pre, bool post)
  pre(pre) pre(post);   // OK
\end{codeblock}
\vspace{2mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Assertions and the \tcode{assert} name clash}
\label{subsec:assrt}

We propose to use the same natural syntax, \tcode{\emph{contract-kind} ( \emph{predicate} )}, also for assertions. This syntax will look instantly familiar to C++ developers as it is the same basic syntax that one would use today to write a macro-based assertion, but without any of the limitations of a macro-based solution\footnote{One such limitation is that because the preprocessor grammar works differently from regular C++ expression grammar, certain constructs such as \tcode{assert(X\{1, 2\})} or \tcode{assert(Y<int, int>)} are ill-formed today if \tcode{assert} is a macro (see also \cite{P2884R0}).}.

However, since assertions appear at block scope, unlike \tcode{pre} and \tcode{post}, we need to claim a full keyword for the contract kind. We therefore need to solve the issue that the most natural keyword, \tcode{assert}, would create a name clash with the existing \tcode{assert} macro from header \tcode{cassert}:

\vspace{2mm}
\begin{codeblock}
void f() {
  int i = get_i();
  assert(i >= 0);  // identical syntax for contract assert and macro assert
}
\end{codeblock}
\vspace{2mm}

There are in principle three ways to resolve this name clash while keeping the natural syntax:

\begin{enumerate}
\item Remove support for header \tcode{cassert} from C++ entirely: make it ill-formed to include the header;
\item Do not make including header \tcode{cassert} ill-formed, but make \tcode{assert} a keyword as proposed in \cite{P2884R0} and silently change the behaviour of macro \tcode{assert} to be a contract assertion instead;
\item Use a keyword other than \tcode{assert} for contract assertions to avoid the name clash.
\end{enumerate}

Option 1 seems too draconian as it would break too much existing code, including code shared between C and C++.

Option 2 seems worth exploring, as the default behaviour of macro \tcode{assert} is actually identical to the default behaviour of a contract assertion: print a diagnostic, then terminate the program. Contract-specific extensions like a user-defined violation handler will not affect pre-existing code. However, there are two problems.

The first problem is that the behaviour of macro \tcode{assert} is tied to whether \tcode{NDEBUG} is defined. To maintain compatibility and avoid checking predicates (potentially terminating the program) that were not checked before in an existing program, a compiler would have to apply the \emph{enforce} semantic when \tcode{NDEBUG} is not defined, and the \emph{ignore} semantic when \tcode{NDEBUG} is defined, to all contract assertions in the program by default. The status quo in the Contracts MVP is that the contract semantic of any contract-checking annotation is implementation-defined; the recommended default contract semantic is \emph{enforce} regardless of whether \tcode{NDEBUG} is defined, and this recommendation is not normative (see \cite{P2877R0}).

The second problem is that even if we tie the default contract semantic to \tcode{NDEBUG} in this way, contract assertions would still not be a backwards-compatible replacement for the \tcode{assert} macro. The \emph{ignore} contract semantic is different from \tcode{assert} with \tcode{NDEBUG} defined because an ignored contract ODR-uses the entities in its predicate, while an ignored \tcode{assert} macro does not. ODR-use can trigger template instantiations and lambda captures\footnote{We might want to make it ill-formed for a contract-predicate to trigger a lambda capture (this is discussed in \cite{P2834R1} and \cite{P2890R0}), but this would not fix the issue here because the other ways in which ODR-use can lead to different behaviour would still be allowed.} and it is further possible to SFINAE on whether an entity in a contract predicate is being ODR-used. This would mean that silently changing an \tcode{assert} macro usage to be a contract assertion instead could make a program ill-formed or silently change the behaviour of existing code. On the other hand, changing ignored contracts to \emph{not} ODR-use the predicate (mimicking the behaviour of the \tcode{assert} macro with \tcode{NDEBUG} defined) would go against an important design principle for contracts: whether a contract is checked or ignored should never lead to different code paths being taken, as this could lead to non-portable code and bugs disappearing or appearing when you turn contract checking on and off (see \cite{P2834R1}). This is an important difference between a contract check and the \tcode{assert} macro.

Furthermore, both Option 1 and Option 2 require us to claim \tcode{assert} as a full keyword (see also \cite{P2884R0}), which would also break any existing C++ code that does not use \tcode{cassert} but uses the identifier \tcode{assert} for a user-defined entity such as a macro or function.

We therefore propose Option 3. Possible alternative keywords include:

\begin{codeblock}
ass                         
asrt                        
assrt                       
assertion                   
co_assert
contract_assert
\end{codeblock}

We have picked \tcode{assrt} for now, but we are happy with any other choice if this increases consensus. Such a keyword may look weird initially, but just like with \tcode{co_yield} and friends, users will get used to it quickly.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Assertions are expressions}
\label{subsec:assrtxpr}

With the natural syntax, it is straightforward to specify assertions as expressions, not statements. Consequently, with our syntax, assertions can be used not only as statements inside a function body, but actually anywhere one could use an expression, and in particular, anywhere one could use an \tcode{assert} macro today:

\vspace{2mm}
\begin{codeblock}
class X {
  int* _p;
public:
  X(int* p) : _p((assrt(p), p)) {}  // works
};
\end{codeblock} 
\vspace{2mm}

Therefore, contract assertions as proposed here can act as full drop-in replacements for \tcode{assert} macros, and that replacement is easily toolable (search and replace the keyword).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Post-MVP extensions}

Our proposed syntax provides a natural path for evolution into all of the post-MVP directions that have been suggested so far. In this section, we discuss several possible post-MVP extensions that are of interest to SG21 according to the electronic poll results in \cite{P2885R2} or that have been brought up in discussion since the poll results were published.

\subsection{Captures}
\label{subsec:captures}

The contracts grammar proposed here can be extended as follows to allow captures on contract-checking annotations:

\begin{adjustwidth}{0.5cm}{0.5cm}

\emph{pre-or-post-condition:} \\
\phantom{~~~}\tcode{pre} \emph{contract} \\
\phantom{~~~}\tcode{post} \emph{contract}

\emph{assert-expression:} \\
\phantom{~~~}\tcode{assrt} \emph{contract}

\emph{contract:} \\
\phantom{~~~}\added{\emph{contract-capture}$_{opt}$} \emph{contract-condition}

\added{\emph{contract-capture:}} \\
\phantom{~~~}\added{\tcode{[} \emph{capture-list} \tcode{]}}

\end{adjustwidth}

Here is a code example:

\vspace{2mm}
\begin{codeblock}
void vector::push_back(const T& v)
  post [old_size = size()] ( size() == old_size + 1 );  // init-capture
\end{codeblock}
\vspace{2mm}

Note that with our syntax, a contract-checking annotation with a capture looks very similar to closure-based syntax, except that the predicate is in parentheses instead of braces. This is the natural choice and avoids making the contract-checking annotation look like a lambda (an entirely different construct). Instead, the syntax looks exactly like the thing that it is: a capture followed by a predicate using that capture. It is a new syntax for a new type of construct, yet it immediately looks familiar and intuitive.

Note further that with our syntax, we have the same design freedom as closure-based syntax \cite{P2461R1} to allow the full capture syntax from lambdas, including default-captures:

\vspace{2mm}
\begin{codeblock}
int min(int x, int y)
  post [x, y] (r: r <= x && r <= y );   // possible with our proposal
\end{codeblock}
\vspace{2mm}

But we could also choose to restrict ourselves to init-captures as \cite{P2935R0} does. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\tcode{requires}-clauses on contracts}
\label{subsec:requires}

The contracts grammar proposed here can be extended to allow a \tcode{requires} clause that appertains to an individual contract-checking annotation. There are at least two possible syntactic positions for such a \tcode{requires} clause. We could place it at the end, after the predicate:

\begin{adjustwidth}{0.5cm}{0.5cm}
\emph{contract:} \\
\phantom{~~~}\emph{contract-capture}$_{opt}$ \emph{contract-condition} \added{\emph{requires-clause}$_{opt}$}

\end{adjustwidth}

In code:

\vspace{2mm}
\begin{codeblock}
template <typename T>
void f(T x)
  pre (x > 0) requires std::integral<T>;
\end{codeblock}
\vspace{2mm}

Alternatively, if we want to make the \tcode{requires} clause more visually prominent, we could place it at the beginning of the contract-checking annotation, right after the \tcode{pre} or \tcode{post} contextual keyword:

\begin{adjustwidth}{0.5cm}{0.5cm}

\emph{contract:} \\
\phantom{~~~}\added{\emph{requires-clause}$_{opt}$} \emph{contract-capture}$_{opt}$ \emph{contract-condition}

\end{adjustwidth}

In code:

\vspace{2mm}
\begin{codeblock}
template <typename T>
void f(T x)
  pre requires std::integral<T> (x > 0);
\end{codeblock}
\vspace{2mm}

Note that neither option creates any parsing ambiguities, for the same reasons as discussed in section \ref{subsec:noambig}. Note further that both options allow for \tcode{requires} clauses appertaining to individual contract-checking annotations to coexist with a \tcode{requires} clause appertaining to the function itself:

\vspace{2mm}
\begin{codeblock}
template <typename T>
void f(T x)
  requires std::copyable<T>
  pre (x > 0) requires std::integral<T>;
\end{codeblock}
\vspace{2mm}

or, alternatively,

\vspace{2mm}
\begin{codeblock}
template <typename T>
void f(T x)
  requires std::copyable<T>
  pre requires std::integral<T> (x > 0);
\end{codeblock}
\vspace{2mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Attributes appertaining to contracts}
\label{subsec:attr}

Although not covered in \cite{P2885R2}, it has been argued that any new syntactic construct in C++, including contract-checking annotations, should allow for the possibility of standard attributes appertaining to it. Some meta-annotations that might be added to contracts post MVP could potentially be expressed as attributes appertaining to a contract-checking annotation.

Support for attributes appertaining to a contract-checking annotation is easy to accommodate with our proposed syntax. Since attributes are optional, ignorable information and are thus not part of a contract's primary information, we believe that it makes most sense to place them at the end of the contract-checking annotation:

\begin{adjustwidth}{0.5cm}{0.5cm}

\emph{contract:} \\
\phantom{~~~}\emph{contract-capture}$_{opt}$ \emph{contract-condition} \added{\emph{attribute-specifier-seq}$_{opt}$}

\end{adjustwidth}

In code:

\vspace{2mm}
\begin{codeblock}
template <typename T>
void f(T x)
  pre (x > 0) [[deprecated]];
\end{codeblock}
\vspace{2mm}

However, just like with \tcode{requires} clauses, it is also possible to place the \emph{attribute-specifier-seq} at the beginning, right after the \tcode{pre} or \tcode{post} contextual keyword in case a more prominent syntactic position is desired.

Note that in either case, there is no grammar ambiguity with the \emph{attribute-specifier-seq} appertaining to any other part of the function declaration, such as the function itself, the function type, or the trailing return type, because all other possible positions for the \emph{attribute-specifier-seq} precede the \emph{pre-or-postcondition}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Labels}
\label{subsec:labels}

It has been suggested that post-MVP, we will need meta-annotations on a contract, so-called \emph{labels}, that should not be spelled as attributes because they are not ignorable. The only currently known use case for this is to specify or constrain the possible contract semantic (observe, ignore, enforce) for a given contract; other use cases might be discovered in the future. There are many ways in which our proposed syntax could be extended to accommodate such labels.

If we want to consider such labels secondary information, we can place them at the end of the contract-checking annotation. In order to keep the grammar unambiguous, we need to surround the sequence of labels with delimiter tokens. We cannot use \tcode{[[ ... ]]} because these are reserved for attributes (see section \ref{subsec:attr}), but we can use pretty much any other set of delimiter tokens, such as \mbox{\tcode{[ ...]}}, \mbox{\tcode{<...>}}, \mbox{\tcode{\{...\}}}, and so forth, depending on SG21's preference:

\vspace{2mm}
\begin{codeblock}
void f(int x)
  pre (x > 0) [audit];   // or \tcode{<audit>}, or \tcode{\{audit\}}, or \tcode{[\{audit\}]} ...
\end{codeblock}
\vspace{2mm}

On the other hand, if we want to consider such labels primary information, we can place them at the beginning of the contract-checking annotation, right after the \tcode{pre} or \tcode{post} contextual keyword. In this case, we cannot use \mbox{\tcode{[...]}} as the delimiters anymore, as it would be ambiguous with the \emph{contract-capture} (see section \ref{subsec:captures}), but we can use \mbox{\tcode{<...>}} or \mbox{\tcode{\{...\}}}:

\vspace{2mm}
\begin{codeblock}
void f(int x)
  pre <audit> (x > 0);    // or \tcode{\{audit\}}, or \tcode{[\{audit\}]} ...
\end{codeblock}
\vspace{2mm}

We could also allow both the leading and the trailing position. Our syntax places no restrictions on the internal grammar for these labels. They can be specified to be any kind of token sequence, depending on the design direction we choose post MVP.

One interesting possibility is to specify that the label, or set of labels, shall be a constant expression that evaluates to a compile-time value defining the desired per-contract configuration, perhaps to a value of some new type \tcode{std::contract_traits} similar to \tcode{std::coroutine_traits}. Such a grammar opens up the power of constant expressions (i.e. almost the full language) for abstracting the computation of the per-contract configuration. The syntax with labels in leading position, right after \tcode{pre} or \tcode{post} and delimited by \mbox{\tcode{<...>}}, seems appealing for this design direction, as the contract-checking annotation will resemble a template that is ``templated'' on its configuration (which acts as a non-type template parameter), and the constant expression acts as a template argument that ``instantiates'' (configures) the contract check. The grammar for this could look as follows:

\begin{adjustwidth}{0.5cm}{0.5cm}

\emph{contract:} \\
\phantom{~~~}\added{\emph{contract-eval-specifier}$_{opt}$} \emph{contract-capture}$_{opt}$ \emph{contract-condition}

\added{\emph{contract-eval-specifier:}} \\
\phantom{~~~}\added{\tcode{<} \emph{constant-expression} \tcode{>}}

\end{adjustwidth}

However, this is only one possible direction. With our proposal, we are not cutting off any other directions. The main difference to labels in attribute-like syntax is that in our syntax, the label sequence goes between delimiter tokens, whereas in attribute-like syntax it goes between the \tcode{pre} or \tcode{post} keyword and the colon. Arguably, our proposal actually leaves more syntactic freedom for labels than attribute-like syntax does. In attribute-like syntax, the label sequence can syntactically clash with anything else that goes between the \tcode{pre} or \tcode{post} keyword and the colon, such as the name for the return value. On the other hand, in our syntax, labels are guaranteed to not clash with anything else because they are separated from all other parts of the contract-checking annotation by their own delimiter tokens.

Note also that with our proposal, we can support both standard attributes and non-attribute labels appertaining to the same contract-checking annotation simultaneously, for example:

\vspace{2mm}
\begin{codeblock}
void f(int x)
  pre <audit> (x > 0) [[ deprecated ]];
\end{codeblock}
\vspace{2mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Destructuring the return value}
\label{subsec:struct}

We can easily and naturally extend the syntax proposed here to add support for destructing the return value of a function with a structured binding when specifying a name for that value:

\emph{contract-condition:} \\
\phantom{~~~}\tcode{(} \emph{return-name}$_{opt}$ \emph{conditional-expression} \tcode{)}

\emph{return-name:}\\
\phantom{~~~}\emph{identifier} \tcode{:} \\
\phantom{~~~}\added{\tcode{[} \emph{identifier-list} \tcode{] :}}

This can be very useful in the postcondition of a function that returns a value of a tuple-like type:

\vspace{2mm}
\begin{codeblock}
std::tuple<int, int, int> f()
  post ([x, y, z] : x != y && y != z);
\end{codeblock}
\vspace{2mm}

\subsection{Procedural interfaces}
\label{subsec:interfaces}

With procedural interfaces, we can express a much richer set of contracts than with preconditions and postconditions alone. The idea was first published by Lisa Lippincott in her paper \cite{P0465R0}. More recently, \cite{P2885R2} and \cite{P2935R0} mentioned the idea of integrating such procedural interfaces into a Contracts facility post-MVP.

With our proposal, we can support procedural interfaces with an interface block delimited by curly braces. This is the natural syntax in C++ for a block containing a list of statements, and very close to Lisa Lippincott's original notation in \cite{P0465R0}. Here is a code example in this syntax --- a procedural interface expressing the contract that a function should not throw an exception:

\vspace{2mm}
\begin{codeblock}
void f(int x)
interface {
  try {
    implementation;
  } 
  catch (...) {
    assrt(false);
  }
};
\end{codeblock}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Comparison with attribute-like syntax}

In this section we compare different Contracts MVP and post-MVP code examples written in attribute-like syntax as proposed in \cite{P2935R0}, side-by-side with the syntax proposed in this paper, and discuss the different tradeoffs.

\subsection{MVP functionality}

\subsubsection{Basic preconditions and postconditions}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

int f(int x) 
  [[ pre: x > 0 ]]
  [[ post r: r > x ]];
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

int f(int x) 
  pre (x > 0)
  post (r: r > x);
\end{codeblock}
\end{minipage}

\subsubsection{Assertion as a statement}

Assertions make it rather obvious that contracts are in fact not attribute-like at all. A contract assertion creates an entirely new code path out of a function body (for example, via a throwing violation handler), which is something standard attributes were never designed to do. 

In attribute-like syntax, an assertion at block scope takes the shape of an attribute appertaining to a null statement; in our proposal, it looks like a regular statement, resembling a function call or the invocation of an assert macro:
\vspace{5mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

void f() {
  int i = get_i();
  [[ assert: i > 0 ]]
  use(i);
}
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

void f() {
  int i = get_i();
  assrt(i > 0);
  use(i);
}
\end{codeblock}
\end{minipage}

\subsubsection{Assertion as an expression}

The left-hand side of this code example is taken directly from \cite{P2935R0}. Note that in attribute-like syntax, this would require a novel grammar that does not exist for attributes today and that we do not have implementation experience with. Attributes today need to appertain to another entity such as a declaration or a statement, and cannot be used on their own as an expression. At the same time, if an assertion is not an expression, it cannot be a full drop-in replacement for C \tcode{assert} as there would be places where a C \tcode{assert} is legal but a contract assert is not. With our proposal, using an assertion as an expression just works:
\vspace{5mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

struct S2 {
  int d_x;
  S2(int x)
    : d_x( [[ assert : x > 0 ]], x )
  {}
};
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

struct S2 {
  int d_x;
  S2(int x)
    : d_x( assrt(x > 0), x )
  {}
};
\end{codeblock}
\end{minipage}

\subsubsection{Position inside more complex function declarations}

The left-hand side of this code example is taken directly from \cite{P2935R0}. In attribute-like syntax, preconditions and postconditions are placed in the same location where attributes that would appertain to the function’s type would be located, i.e. before any trailing return type, virtual specifiers such as \tcode{override} and \tcode{final}, and a \tcode{requires} clause (see \cite{P2935R0}). This has the benefit that we can re-use the existing standard attribute grammar. However, the resulting position is awkward and goes against the natural reading order of a function declaration; it also requires delayed parsing of postconditions (as the predicate may depend on the trailing return type).

By contrast, in our proposal, preconditions and postconditions are placed at the very end of a declaration, avoiding all of the above problems:
\vspace{3mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

struct S1
{
  auto f() const & noexcept
    [[ pre : true ]] -> int;
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

struct S1
{
  auto f() const & noexcept -> int
    pre(true);
\end{codeblock}
\end{minipage}

\begin{minipage}{8cm}
\begin{codeblock}
  virtual void g()
    [[ pre : true ]] final = 0;
  
  template <typename T>
  void h()
    [[ pre : true ]] requires true;
};
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
  virtual void g() final = 0
    pre(true);

  template <typename T>
  void h() requires true
    pre(true);
};
\end{codeblock}
\end{minipage}
\vspace{3mm}

Placing preconditions and postconditions at the very end of a declaration is in principle also possible with attribute-like syntax, and this is discussed in \cite{P2935R0}. But this is not covered by existing standard attribute-grammar, thus requiring a novel grammar that we do not have implementation experience with, throwing away the main advantage of attribute-like syntax.

\subsubsection{Lambda with trailing return type}
The same issue with the syntactic order also exists for lambdas, aggravated by the fact that a trailing return type is even more common here:
\vspace{3mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

auto x = [] (int x)
  [[pre: x > 0]] -> int
{ 
  return x * x; 
};
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

auto x = [] (int x) -> int 
  pre(x > 0)
{ 
  return x * x; 
};
\end{codeblock}
\end{minipage}

\subsection{Post-MVP functionality}

\subsubsection{Captures}
\label{subsubsec:comp_captures}

In attribute-like syntax, captures look awkward as they involve square brackets inside double square brackets. Additionally, in attribute-like syntax they are ambiguous with square brackets for a structured binding (see \ref{subsubsec:struct}). \cite{P2935R0} suggests to only allow init-captures (but not default captures) and to surround structured bindings with an additional pair of parentheses for disambiguation. In our syntax, neither is necessary as the two features have different syntactic positions that arise naturally from our proposed grammar:
%\vspace{5mm}

\begin{minipage}[t]{8cm}
\begin{codeblock}
// P2935R0:

// no support for default captures


void vector::push_back(const T& v)
  [[ post [old_size = size()]
    : size() == old_size + 1 ]];
    
\end{codeblock}
\end{minipage}
\begin{minipage}[t]{8cm}
\begin{codeblock}
// This paper:
    
int min(int x, int y)
  post [x, y] (r: r <= x && r <= y);
  
void vector::push_back(const T& v)
  post [old_size = size()] 
    (size() == old_size + 1);
\end{codeblock}
\end{minipage}

\subsubsection{Destructuring the return value}
\label{subsubsec:struct}

\begin{minipage}[t]{8cm}
\begin{codeblock}
// P2935R0:

std::tuple<int, int, int> f()
  [[ post [x, y, z] : x != y && y != z ]];
  
// or, if needed to disambiguate from capture:

std::tuple<int, int, int> f()
  [[ post ([x, y, z]) : x != y && y != z ]];
\end{codeblock}
\end{minipage}
\begin{minipage}[t]{8cm}
\begin{codeblock}
// This paper:

std::tuple<int, int, int> f()
  post ([x, y, z] : x != y && y != z);
\end{codeblock}
\end{minipage}

\subsubsection{\tcode{requires} clause on the contract-checking annotation}

In \cite{P2935R0}, the \tcode{requires} clause appertaining to the function itself comes after the contract-checking annotation, whereas in our syntax it comes before. Note further that in \cite{P2935R0}, the \tcode{requires} clause appertaining to the contract-checking annotation comes before the predicate, whereas in our syntax we can choose to place it either before or after, depending on what SG21 prefers.

\textbf{Possible option: \tcode{requires} clause at the end}

\begin{minipage}[t]{8cm}
\begin{codeblock}
// P2935R0:

  template <typename T>
  void f(T x)
    [[pre requires(std::integral<T>): x > 0]]
    requires std::copyable<T>;
\end{codeblock}
\end{minipage}
\begin{minipage}[t]{8cm}
\begin{codeblock}
// This paper:

  template <typename T>
  void f(T x)
    requires std::copyable<T>
    pre (x > 0) requires std::integral<T>;
\end{codeblock}
\end{minipage}
\\

\textbf{Possible option: \tcode{requires} clause at the beginning}

\begin{minipage}[t]{8cm}
\begin{codeblock}
// P2935R0:

  template <typename T>
  void f(T x)
    [[pre requires(std::integral<T>): x > 0]]
    requires std::copyable<T>;
\end{codeblock}
\end{minipage}
\begin{minipage}[t]{8cm}
\begin{codeblock}
// This paper:

  template <typename T>
  void f(T x)
    requires std::copyable<T>
    pre requires std::integral<T> (x > 0);
\end{codeblock}
\end{minipage}

\subsubsection{Attributes}

In \cite{P2935R0}, a standard attribute appertaining to a contract-checking annotation (which is itself attribute-like) inevitably leads to nested double square brackets, which looks awkward, is hard to read, and requires a novel attribute grammar that we do not have implementation experience with (the existing grammar does not allow attributes appertaining to other attributes). On the other hand, in our proposal, a standard attribute appertaining to a contract-checking annotation looks as natural as a standard attribute appertaining to any other declaration:

\begin{minipage}[t]{8cm}
\begin{codeblock}
// P2935R0:

int f(int x) 
  [[ pre: x > 0 [[deprecated]] ]];
\end{codeblock}
\end{minipage}
\begin{minipage}[t]{8cm}
\begin{codeblock}
// This paper:

int f(int x) 
  pre (x > 0) [[deprecated]];
\end{codeblock}
\end{minipage}
\vspace{5mm}

Note that with our proposal, a standard attribute appertaining to a contract-checking annotation is never ambiguous with a standard attribute appertaining to the function itself, the function type, or the trailing return type (see section \ref{subsec:attr}).

\subsubsection{Labels}

As discussed in section \ref{subsec:labels}, with the syntax proposed here we can choose to place labels either at the beginning or at the end of a contract-checking annotation; the choice will depend on whether we consider these labels primary or secondary information. We can also choose between different delimiter tokens to separate them from the rest of the contract-checking annotation. In any case, the different parts of a contract-checking annotation are much more clearly visually distinguishable in our syntax than in attribute-like syntax, which places all the information including labels into a flat sequence of tokens between delimiter tokens around the whole contract-checking annotation.

\pagebreak %% MANUAL %%%%%%%%%%%%%

\textbf{Possible option: labels at the end, using \tcode{[...]} delimiters}
\vspace{3mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

void search(range rg)
  [[ pre audit: is_sorted(rg) ]];
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

void search(range rg)
  pre (is_sorted(rg)) [audit];
\end{codeblock}
\end{minipage}

\vspace{3mm}
\textbf{Possible option: labels at the beginning, using \tcode{<...>} delimiters}
\vspace{3mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

void search(range rg)
  [[ pre audit: is_sorted(rg) ]];
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

void search(range rg)
  pre <audit> (is_sorted(rg));
\end{codeblock}
\end{minipage}

\subsubsection{Labels and named return value}

In \cite{P2935R0}, the label (or sequence of labels) competes for the same syntactic place as the return value name, making the contract harder to read and disallowing the use of a label name for the return value (potentially breaking existing code when adding new standard labels to C++). On the other hand, in our proposal, the label is syntactically separated from the return value name (and all other parts of the contract specification) and no interference between them is possible:

\vspace{3mm}
\textbf{Possible option: labels at the end, using \tcode{[...]} delimiters}
\vspace{3mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:
  
range sort(range rg)
  [[ post audit res: is_sorted(res) ]];
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:
  
range sort(range rg)
  post (res: is_sorted(res)) [audit];
\end{codeblock}
\end{minipage}

\vspace{3mm}
\textbf{Possible option: labels at the beginning, using \tcode{<...>} delimiters}
\vspace{3mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

range sort(range rg)
  [[ post audit res: is_sorted(res) ]];
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:
  
range sort(range rg)
  post <audit> (res: is_sorted(res));
\end{codeblock}
\end{minipage}

\subsubsection{Procedural interfaces}
\label{subsubsec:comp_interfaces}

To spell procedural interfaces, \cite{P2935R0} resorts to an interface block delimited with double square brackets, which leads to nested double square brackets. On the other hand, with our proposal, we can adopt a much more natural-looking syntax that uses braces for the block of statements. This syntax is also much closer to the notation in Lisa Lippincott's original paper on procedural interfaces, \cite{P0465R0}:
\vspace{5mm}

\begin{minipage}{8cm}
\begin{codeblock}
// P2935R0:

void f(int x)
  [[ interface :
    try {
      implementation;
    } 
    catch (...) {
      [[assert: false]];
    }
  ]];
\end{codeblock}
\end{minipage}
\begin{minipage}{8cm}
\begin{codeblock}
// This paper:

void f(int x)
interface {
  try {
    implementation;
  } 
  catch (...) {
    assrt(false);
  }
};
\end{codeblock}
\end{minipage}

\section{Requirements from P2885}
\label{sec:requirements}

Our proposal satisfies all \emph{must-have}, \emph{important}, and \emph{nice-to-have} requirements for a Contracts syntax from \cite{P2885R2}, except the requirement for implementation experience. If this proposal generates interest, we hope that someone will be able to help us with implementing this syntax in a C++ compiler to satisfy this requirement as well.

Below we list all these requirements and discuss how our syntax satisfies them.

\subsection{Basic requirements}

\subsubsection{Aesthetics  [basic.aesthetic]}

We believe that our syntax is more elegant and readable than either attribute-like or closure-based syntax.

\subsubsection{Brevity  [basic.brief]}

Our syntax uses the least amount of tokens and characters possible.

\subsubsection{Teachability  [basic.teach]}

We believe that this syntax is easy to learn and teach, and more self-explanatory and intuitive than either attribute-like or closure-based syntax.

\subsubsection{Consistency with existing practice  [basic.practice]}

We believe that this syntax is more consistent with existing practice than either attribute-like or closure-based syntax. Today, contracts facilities are implemented using macros, using the syntax \tcode{\emph{MACRO_NAME}(predicate)}. We use the exact same basic syntax, also placing the predicate in parentheses. The only differences are that instead of a macro name, we use a contextual keyword, preconditions and postconditions are placed onto declarations instead of inside the function body, and the user can additionally name the return value in a postcondition, a feature that is not possible with macros.

\subsubsection{Consistency with the rest of the C++ language  [basic.cpp]}

We believe that this syntax is more consistent with the rest of the C++ language than either attribute-like or closure-based syntax. We do not make contract-checking annotations look like attributes, and we do not place predicates (which are expressions) between curly braces. In C++ today, expressions go between parentheses, while statements go between curly braces.

\subsection{Compatibility requirements}

\subsubsection{No breaking changes  [compat.break]}

As long as we use a keyword other than \tcode{assert} for assertions (see discussion in section \ref{subsec:assrt}), our syntax does not break or alter the meaning of any existing C++ code.

\subsubsection{No macros  [compat.macro]}

Our syntax does not require the use of macros or the preprocessor to be used effectively.

\subsubsection{Parsability  [compat.parse]}

To our best knowledge the syntax we propose does not introduce any parsing ambiguities; see detailed discussion in section \ref{subsec:noambig}.

\subsubsection{Implementation experience  [compat.impl]}

Unfortunately, we do not yet have any implementation experience with the syntax proposed here in a C++ compiler.

\subsubsection{Backwards-compatibility  [compat.back]}

According to the SG21 electronic poll in \cite{P2885R2}, this is an \emph{irrelevant} requirement.

\subsubsection{Toolability [compat.tools]}

In order for a C++ tool to implement meaningful functionality for Contracts, the tool needs to be able to not only recognise the contract-checking annotation itself, but also be capable of correctly parsing most parts of a C++ function declaration. We do not see any reason why this should be any more difficult with our proposed syntax than with attribute-like or closure-based syntax.

\subsubsection{C compatibility  [compat.c]}

We do not know what the C committee intends to do and whether they are interested in standardising Contracts for C. We should not block progress on C++ Contracts while waiting for that decision to form. However, we do not see any reason why our proposed syntax should create more hurdles for adopting it in C than the other syntax proposals do.

\subsection{Functional requirements}

\subsubsection{Predicate  [func.pred]}

Requirement satisfied.

\subsubsection{Contract kind  [func.kind]}

Since with the natural syntax, \tcode{assrt(expr)} is an expression, \tcode{assrt} (or whichever other keyword we choose) must be a full keyword, not a contextual keyword. We can therefore not use the same keyword for the enum value in \tcode{std::contracts::contract_kind} corresponding to assertions. We can keep using the identifier \tcode{assert} for this purpose as in the current MVP, or choose any other identifier.

\subsubsection{Position and name lookup [func.pos]}

Requirement satisfied.

\subsubsection{Pre/postconditions after parameters [func.pos.prepost]}

Requirement satisfied.

\subsubsection{Assertions anywhere an expression can go [func.pos.assert]}

Requirement satisfied.

\subsubsection{Multiple pre/postconditions  [func.multi]}

Requirement satisfied.

\subsubsection{Mixed order of pre/postconditions  [func.mix]}

Requirement satisfied.

\subsubsection{Return value  [func.retval]}

Requirement satisfied.

\subsubsection{Predefined name for return value  [func.retval.predef]}

According to the SG21 electronic poll in \cite{P2885R2}, this is a \emph{questionable} requirement. We decided not to satisfy it because we believe that letting the user define their own name for the return value is the better approach.

\subsubsection{User-defined name for return value  [func.retval.userdef]}

Requirement satisfied.

\subsection{Future evolution requirements}

\subsubsection{Non-const non-reference parameters  [future.params]}

Requirement satisfied via captures.

\subsubsection{Captures  [future.captures]}

The syntax proposed here can naturally be extended to support captures; see section \ref{subsec:captures} for discussion.

\subsubsection{Structured binding return value  [future.struct]}

The syntax proposed here can naturally be extended to support destructuring the return value; see discussion in section \ref{subsec:struct} and comparison with attribute-like syntax in \ref{subsubsec:struct}.

\subsubsection{Contract reuse  [future.reuse]}

According to the SG21 electronic poll in \cite{P2885R2}, this is a \emph{questionable} requirement. Joshua Berne suggested that this idea might be better addressed by introducing some kind of hygienic macro. We therefore decided not to consider this requirement further.

\subsubsection{Meta-annotations  [future.meta]}

The syntax proposed here can naturally be extended to support labels and meta-annotations, offering the same syntactic freedom as attribute-like syntax; see section \ref{subsec:labels} for discussion.

\subsubsection{Parametrised meta-annotations  [future.meta.param]}

There is nothing specific to the syntax proposed here that precludes this direction.

\subsubsection{User-defined meta-annotations  [future.meta.user]}

There is nothing specific to the syntax proposed here that precludes this direction.

\subsubsection{Meta-annotations re-using existing keywords  [future.meta.keyword]}

There is nothing specific to the syntax proposed here that precludes this direction.

\subsubsection{Non-ignorable meta-annotations  [future.meta.noignore]}

There is nothing specific to the syntax proposed here that precludes this direction.

\subsubsection{Primary vs. secondary information  [future.prim]}

We believe that our syntax satisfies this requirement much better than attribute-like syntax.

\subsubsection{Invariants  [future.invar]}

The syntax proposed here can be naturally extended to a \emph{invariant} contract kind that can be declared at class scope, should SG21 decide to pursue this direction further. However, the syntactic space at class scope is somewhat crowded so we will most likely need to reserve a full keyword for this purpose.

\subsubsection{Procedural interfaces  [future.interface]}

The syntax proposed here can be naturally extended to support procedural interfaces as proposed in \cite{P0465R0}; see discussion in section \ref{subsec:interfaces} and comparison with attribute-like syntax in \ref{subsubsec:comp_interfaces}.

\subsubsection{requires clauses  [future.requires]}

The syntax proposed here can be naturally extended to support \emph{requires} clauses on individual contract-checking annotations; see discussion in section \ref{subsec:requires}.

\subsubsection{Abbreviated syntax on parameter declarations  [future.abbrev]}

According to the SG21 electronic poll in \cite{P2885R2}, this is the lowest-ranked \emph{nice-to-have} requirement. We therefore did not dedicate any time considering this requirement in detail. However at first glance there does not seem to be anything specific to this proposal that precludes this direction.

\subsubsection{General extensibility  [future.general]}

As we have shown above, the syntax proposed here can be naturally extended to a wide range of known ideas for future features. We therefore believe that it offers a high degree of extensibility also for future features not yet discussed.

\label{subsec:future}

%\section*{Document history}

%\begin{itemize}
%\item \textbf{R0}, 2023-03-08: Initial version.
%\item \textbf{R1}, 20XX-XX-XX: ??
%\end{itemize}

\section*{Acknowledgements}

We would like to thank Ville Voutilainen, Joshua Berne, Peter Brett, Ga\v sper A\v zman, and Andrzej Krzemie\' nski for their helpful feedback on an earlier draft of this paper.

\renewcommand{\bibname}{References}
\bibliographystyle{abstract}
\bibliography{ref}

\end{document}

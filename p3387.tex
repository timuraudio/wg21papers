\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Contract assertions on coroutines}
\author{
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\
Iain Sandoe \small(\href{mailto:iain@sandoe.co.uk}{iain@sandoe.co.uk}) \\
Peter Bindels \small(\href{mailto:dascandy@gmail.com}{dascandy@gmail.com}) 
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3387R0 \\
Date: &2024-09-23 \\
Project: & Programming Language C++ \\
Audience: & SG21, EWG
\end{tabular}

\begin{abstract}
In this paper, we explore the design space for an extension to the Contracts MVP proposal \cite{P2900R8} that allows placing function contract assertions --- \tcode{pre} and 
\tcode{post} --- on coroutines. We discuss the questions that such a proposal must answer, such as the point of evaluation of \tcode{pre} and \tcode{post} on a coroutine and the treatment of coroutine parameters in the predicate of \tcode{post}. We analyse the available solution space, based on the design proposed in \cite{P2957R1} and exploring some additional options, formulate our design goals, and conclude with the solution that best satisfies those design goals, taking into account the fundamental design principles of both coroutines and Contracts.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{intro}

The C++2a Contracts proposal \cite{P0542R5}, and the Contracts proposals before it, did not take coroutines into account because they were not yet part of the C++ Standard at the time. Post-C++20, SG21 initially decided to not support \tcode{pre} and \tcode{post} on coroutines in the Contracts MVP proposal, ``until we have a more complete picture of what we intend to provide'' (see \cite{P2932R3}). This remains the case in the current revision \cite{P2900R8}, which makes it ill-formed for a function \tcode{f} to have function contract assertions --- \tcode{pre} and \tcode{post} --- if \tcode{f} is a coroutine; it merely allows \tcode{contract_assert} inside the body of \tcode{f}. 

However, there are good reasons to remove this limitation from the Contracts MVP. The benefits of adding \tcode{pre} and \tcode{post} to a function declaration also extend to coroutines, especially if we consider the fundamental design principle behind coroutines  that the coroutine-ness of a function is an implementation detail. We should not give users more reasons to avoid coroutines by hampering the ability to apply \tcode{pre} and \tcode{post} to them. As pointed out in \cite{P3173R0}, coroutines are a foundational facility of modern C++ and thus a Contracts proposal should adequately address uses of contract assertions in combination with coroutines. In that paper, a major compiler vendor names support for \tcode{pre} and \tcode{post} on coroutines as one of the criteria for the viability of a Contracts MVP proposal.

Significant progress towards a solution was made in \cite{P2957R0},  the first proposal to add support for \tcode{pre} and \tcode{post} on coroutines. In this paper, the authors argue why the only viable semantics for \tcode{pre} and \tcode{post} on a coroutine declaration are that they apply to the function interface that this declaration exposes to the caller, and not to the internal coroutine aspects of the function; and that they express the preconditions and postconditions on the so-called \emph{ramp function}, and not on the suspend and resume points of the coroutine produced by it. This paper was seen by SG21 in Kona (November 2023). The proposed solution did not gain consensus at the time due to some remaining uncertainty on the proposed design direction. 

A revision of the paper, \cite{P2957R1}, contained a change that made \tcode{post} on a coroutine ill-formed (while \tcode{pre} on a coroutine would still work as proposed before), to address concerns in SG21 over how \tcode{post} as proposed relates to the coroutine body (not in any straightforward way), and how parameters would behave in \tcode{post} (a parameter may be moved-from by the ramp function even if the parameter has been declared \tcode{const} by the user). A later paper, \cite{P3251R0}, proposed the same solution, and additionally considered how contract assertions could be applied to the return channel of a coroutine by adding \tcode{pre} and \tcode{post} on the promise type without any changes to \cite{P2900R8}.

The present paper does not add any fundamental new ideas to these previous proposals; we support the design direction developed in \cite{P2957R0} and \cite{P2957R1}. What this paper contributes is a more exhaustive exploration of the available design space, including some options and design goals not explicitly discussed in other papers, as well as a specification strategy and formal wording for the concrete solution that best satisfies all relevant design goals and the fundamental design principles of both coroutines and Contracts.

\section{Discussion}

\subsection{Coroutine-ness is an implementation detail}
\label{impldetail}

The fundamental design principle of coroutines is that whether \tcode{f} is a coroutine is an implementation detail that is not known at the declaration of \tcode{f}, or to the caller of \tcode{f}. This design principle can and should be applied to Contracts as well. If a Contracts proposal introduces new ways in which coroutines are different from other functions --- such as disallowing the usage of \tcode{pre} and \tcode{post} on them --- then such a design is in contradiction with how coroutines are designed and specified in C++ today. Our design direction should therefore be that, as much as possible, coroutines should work exactly the same as other functions with respect to Contracts.

To illustrate the implementation detail nature of coroutine-ness, let us assume that \tcode{generator<T>} is a conforming coroutine return type (\href{https://eel.is/c++draft/dcl.fct.def.coroutine}{[dcl.fct.def.coroutine]}). Now, consider the following function declaration:
\begin{codeblock}
generator<int> iota(int n); 
\end{codeblock}
This function could be implemented as a coroutine, for example as follows:
\begin{codeblock}
generator<int> iota(int n) {
  while (true)
    co_yield n++;
}
\end{codeblock}
However, another option is to implement \tcode{iota} as a non-coroutine function that manually initialises an object of type \tcode{generator<int>} and returns it, without using any of the C++ coroutine machinery. It is possible to do this without any observable change in behaviour between the two implementations.

A third possible implementation is to implement \tcode{iota} as a non-coroutine function that wraps a coroutine \tcode{iota_coro_impl} as follows:
\begin{codeblock}
generator<int> iota(int n) {
  return iota_coro_impl(n);
}
\end{codeblock}
In general, it is impossible to distinguish between these three implementations from the declaration or from the call site of the function. This should remain the case in the presence of \tcode{pre} and \tcode{post}. To achieve this, it is necessary to remove the current restriction in \cite{P2900R8} that \tcode{pre} and \tcode{post} cannot be applied to a coroutine.

Consider a coroutine \tcode{f} that we wish to augment with \tcode{pre} and \tcode{post}. Note that, with the current specification in \cite{P2900R8}, any call to \tcode{f} an be indirected through a single non-coroutine function \tcode{g} with the same function signature, and any \tcode{pre} and \tcode{post} the user wishes to apply to \tcode{f} can instead be applied to \tcode{g}:
\begin{codeblock}
auto g()  // not a coroutine
  pre (/*...*/) 
  post (r: /*...*/) { 
  return f();  // a coroutine
} 
\end{codeblock}
Given the existence of this workaround, it seems straightforward to specify that \tcode{pre} and \tcode{post} when placed on  \tcode{f} directly should behave exactly the same  as they would when placed on the wrapper function \tcode{g}. However, as with any other attempt to wrap a function in C++, once additional parameters are being passed there are subtle yet important differences in behaviour that must be considered, in particular regarding odr-use of a non-reference parameter in the predicate of \tcode{post}, which we discuss in more detail in Section~\ref{paramsinpost}. Before we get there, let us consider the conceptual meaning of \tcode{pre} and \tcode{post} on a coroutine declaration in more detail.

\subsection{The interface of a coroutine}

The full interface of a coroutine consists of two parts. First, there is the \emph{function interface}, that is, the function declaration that the caller sees. This interface covers the initial function call. From the caller's perspective, this function call behaves like a factory function that initiates the coroutine body and creates and returns the coroutine return object. This factory function is informally called the \emph{ramp function}. The implementation of the ramp function is generated entirely by the compiler according to the rules specified in \href{https://eel.is/c++draft/dcl.fct.def.coroutine#5}{[dcl.fct.def.coroutine]/5} and is composed of the user-provided coroutine body, together with start-up and termination functionality, part of which is specified by customisation methods in the promise type.

From some perspectives, the coroutine has a second, extended, \emph{coroutine interface}. This interface covers the actions of the coroutine body which might, for example, repeatedly yield values via \tcode{co_yield}, suspend activity pending some condition via \tcode{co_await}, or return a final value via \tcode{co_return}.  The behaviour of this extended interface is governed both by the user-provided body and the promise and awaiter types that implement the C++ customisation points required. The extended interface is unknown and opaque to the caller, which might no longer exist when parts of the coroutine body execute.

From the design principle that coroutine-ness is an implementation detail it follows directly that the function contract assertions --- \tcode{pre} and \tcode{post} --- on a coroutine declaration must specify the contract of the function interface, i.e. the ramp function, as this is the only interface known at the site of the function call.

One of the design principles of the Contracts MVP (\cite{P2900R8}, Section 3.1, Design Principle 11) is that \tcode{pre} and \tcode{post} serve both caller and callee. In this case, crucially, the callee is \emph{not} the user-provided coroutine body, but the compiler-generated ramp function: \tcode{pre} on a coroutine is an assertion on the parameters passed into the ramp function when it is called, \emph{before} the coroutine state is constructed, and the state of the program at that point; \tcode{post} on a coroutine is an assertion on the object that the ramp function returns to the caller. On the other hand, the coroutine body does not have direct access to the return value of the ramp function;\footnote{It is possible to provide access to the return value to the body of the coroutine, but it is tricky to do and not very common. For example, implementations of a \tcode{std::optional}-returning coroutine can make use of a special constructor in the \tcode{std::optional} type that takes a pointer to the \tcode{promise_type} and that registers itself with the promise object when the return value is returned from \tcode{get_return_object()}. Then, if the coroutine does not suspend at \tcode{initial_suspend()} and continues executing the body, the body can have access to the return-value.} it may resume execution long after \tcode{post} is checked; and it may run on another thread.

This lack of a direct connection between function declaration and user-provided function body may seem strange and unintuitive to users not familiar with coroutines; but it is a fundamental part of their design. Adding \tcode{pre} and \tcode{post} to the function declaration does not change this design and does not make things any more complex than they already are. This key insight allows us to move past ``postpone until we have a more complete picture'' and propose a coherent design for \tcode{pre} and \tcode{post} applied to coroutines.

In addition to contract assertions on the function interface, we could consider a novel language feature to express assertions on the extended coroutine interface, i.e., preconditions and postconditions on a coroutine's suspension and resumption. However, such assertions could not be specified on the function declaration as the coroutine-ness of a function is not known there. We believe that most, if not all, use cases for such assertions can already be accomplished with the existing functionality in \cite{P2900R8} by using \tcode{contract_assert} inside the coroutine body or, for contracts that hold for \emph{any} entity that uses a given promise type, by applying \tcode{pre} and/or \tcode{post} to the various customisation functions in the promise and awaiter types. This latter approach is described in more detail in \cite{P3251R0}. A novel language feature to support this functionality is therefore not required for a viable Contracts MVP. Note also that for any coroutine, it is possible to construct a non-coroutine function with the same observable behaviour (although that might require multithreading in some cases). For the remainder of this paper, we therefore do not discuss contract assertions on the suspend and resume points of a coroutine any further, and focus solely on contract assertions on its function interface.
%IDS I will send separate email about this - but I am begining to think that we (collectively) are over-thinking the internals - I can construct non-coroutine examples that have all these properties (with the exception of being a single-threaded impl).
% TD: I edited this part with your suggestions in mind. Hopefully it is better now? We can continue to edit it later if needed.

\subsection{Point of evaluation of \tcode{pre} and \tcode{post}}

As pointed out in \cite{P2957R1}, correctly specifying the point of evaluation of \tcode{pre} and \tcode{post} needs some slight clarifications for coroutines, however, according to the mental model described in the previous section, this does not conceptually change the point of evaluation itself or compromise the equivalence between coroutines and non-coroutine functions.

\cite{P2900R8} specifies that the precondition assertions are evaluated ``immediately after function parameters are initialised and before entering the function body''. For a coroutine, by ``function body'', we do \emph{not} mean the coroutine body that the user wrote, but the body of the ramp function that the compiler generated. Therefore, the precondition assertions of a coroutine are evaluated \emph{before} any of the coroutine-specific events that happen in the ramp function, such as creating a copy of the parameters, allocating the coroutine state, initialising the promise object, etc.

\cite{P2900R8} further specifies that the postcondition assertions are evaluated ``after the return value has been initialised and local automatic variables have been destroyed but prior to the destruction of function parameters''. Again, for a coroutine, this specification should be applied to the body of the ramp function and not the coroutine body. This means that the ``return value'' is that of the ramp function, \emph{not} (for example) values yielded by the coroutine; its type is the declared return type of the coroutine; and there are no ``local variables'' since the local variables of the coroutine body are not in the scope of the ramp function and are not destroyed when the latter returns.

\subsection{odr-using parameters in \tcode{post}}
\label{paramsinpost}

In \cite{P2900R8}, in order to odr-use a non-reference parameter in the predicate of \tcode{post}, it has to be declared \tcode{const} on every declaration of the function. This allows us to reason about the parameter value not having been modified between the function call and the evaluation of that function's postcondition assertions, which is a prerequisite for writing meaningful postcondition assertions on such a parameter (see \cite{P2900R8}, Section 3.4.4). As it turns out, there is one implementation detail of coroutines that is unobservable caller-side today but leads to an interaction with the above rule if we wish to allow \tcode{post} on coroutines.

As part of the standard-mandated activity of the ramp, a copy of each parameter may be created in the coroutine state, and the value of each parameter moved into that copy (\href{https://eel.is/c++draft/dcl.fct.def.coroutine#13}{[dcl.fct.def.coroutine]/13}), potentially leaving the original parameter object in a moved-from state. This is necessary to make the parameters accessible inside the coroutine body, whose lifetime can extend far beyond the ramp function returning. Notably, a parameter may be moved from in this fashion even if it is a non-reference parameter declared \tcode{const} by the user. The ramp function effectively removes the top-level \tcode{const} from the parameter, and then modifies that parameter by using it to move-construct the copy. Put another way, in a coroutine, a parameter object is never actually \tcode{const}, even if declared as such in the function declaration.

This specification may seem strange, but does not cause issues in C++ today because the moved-from parameter values are not exposed to the user in any way. Such a ramp function implementation is in fact fully consistent with the design principle that coroutine-ness is an implementation detail. Consider the following declaration of a function \tcode{f}:
\begin{codeblock}
awaitable<int> f(const Widget w);
\end{codeblock}
Assuming that \tcode{awaitable<int>} is a valid coroutine return type, this function could be  implemented either as a coroutine or as a non-coroutine. Note that according to \href{https://eel.is/c++draft/dcl.fct#4.sentence-2}{[dcl.fct]/4}, the following declaration declares the exact same function as the previous one:
\begin{codeblock}
awaitable<int> f(Widget w);
\end{codeblock}
Note further that while the function \tcode{f} has the same type in both declarations, the parameter \tcode{w} does not: it is \tcode{const} in the first declaration, but non-\tcode{const} in the second.

Now, as an implementation detail, the user could choose to provide a non-coroutine definition of \tcode{f} that modifies \tcode{w} in its body:
\begin{codeblock}
// f.h
awaitable<int> f(const Widget w);

// f.cpp
awaitable<int> f(Widget w) {
  Widget w_copy = std::move(w); // OK
  // some other code; not a coroutine
}
\end{codeblock}
Note that the user \emph{must} remove \tcode{const} from the parameter declaration on the definition of \tcode{f}, because otherwise, any attempt to move from \tcode{w} or otherwise modify \tcode{w} in the body of \tcode{f} cannot work because it would either not compile (if no \tcode{const_cast} is used) or be undefined behaviour as per \href{https://eel.is/c++draft/dcl.type.cv#4.sentence-1}{[dcl.type.cv]/4}. This is fine; it is possible to declare \tcode{w} is non-\tcode{const} on the definition even if an earlier declaration of \tcode{f} declares it as \tcode{const}.

With the above implementation of \tcode{f}, according to the rules specified by \cite{P2900R8} one would not be able to odr-use \tcode{w} in the predicate of a \tcode{post} that applies to \tcode{f}, because for that to work, \tcode{w} needs to be declared \tcode{const} on \emph{all} declarations of \tcode{f}.

Now, if the user instead chooses to provide a definition of \tcode{f} that makes \tcode{f} a coroutine, then the implementation of \tcode{f} will not actually be the function body that the user wrote, but instead the compiler-generated ramp function. Since this compiler-generated ramp function modifies the parameter object, it will effectively have a non-\tcode{const} \tcode{Widget} parameter, just like the last implementation of \tcode{f} above. In other words, the ramp function behaves as if its defining declaration was rewritten to have any top-level $cv$-qualifiers stripped from parameter declarations (and as we will see in Section~\ref{wording}, our proposed wording includes a clarification of this reality that we intend to see adopted).

Considering the above, the question that any viable Contracts proposal needs to answer --- in a consistent and user-friendly way --- is how to handle the case of a non-reference parameter being used in the predicate of \tcode{post} on a coroutine. On the one hand, if that non-reference parameter is declared \tcode{const} on \emph{all} declarations of \tcode{f}, including the defining declaration, it would be eligible for odr-use in the predicate of post under the current rules in \cite{P2900R8}, which assume that \tcode{f} is not a coroutine. On the other hand, as we saw above, if \tcode{f} is a coroutine, the parameter is never actually \tcode{const}, and therefore the reasoning behind the current rules in \cite{P2900R8} does not apply.

Note that reference parameters are not affected by any of the above. For reference parameters, there is no assumption that the underlying object will not be modified between the function call and the evaluation of that function's postcondition assertions,\footnote{Note that this is true even for \tcode{const} reference parameters: the implementation of a function could \tcode{const_cast} away the \tcode{const} and modify the object through the resulting non-\tcode{const} reference, which is fine as long as the underlying original object has not been declared \tcode{const}.} and therefore the current rule that reference parameters can be freely used in the predicate of \tcode{post} can be applied without modifications to coroutines.

\section{The solution space}
\label{solutions}

We are aware of the following potential solutions for how \tcode{pre} and \tcode{post} should behave on a coroutine, all of which have been formally or informally proposed by a WG21 member at some point:
\begin{enumerate}
\item Do not allow \tcode{pre} or \tcode{post} on coroutines at all (status quo in \cite{P2900R8});
\item Allow \tcode{pre} on coroutines, but not \tcode{post} (first proposed in \cite{P2957R1});
\item Allow \tcode{post} on coroutines, but do not allow odr-using parameters in its predicate (first mentioned in \cite{P2957R1} as an alternative);
\item Allow odr-using parameters in the predicate of \tcode{post}; an \emph{id-expression} naming a non-reference parameter refers to the copy made for the coroutine state;
\item Allow odr-using parameters in the predicate of \tcode{post}; an \emph{id-expression} naming a non-reference parameter refers to the original object, and:
\begin{enumerate}[label=\alph*.,ref=\theenumi\alph*]
        \item the parameter copy made in the ramp function is copy-constructed instead of move-constructed;
        \item is ill-formed if the parameter type has a non-trivial move constructor (i.e., the parameter can have a moved-from value);
        \item no further provision is added, i.e. the \emph{id-expression} may refer to a moved-from value, even if the parameter is declared \tcode{const} by the user (first proposed in \cite{P2957R0}).
\end{enumerate}
\end{enumerate}
All of the above solutions handle the question of odr-using non-reference parameters in \tcode{post} in different ways. In order to choose the correct solution, we need to formulate our design goals and determine which of these solutions best satisfies these design goals. This analysis is performed in the following section.

Some of the above solutions have minor variations we will not discuss explicitly (for example, 5b could be modified to make \tcode{post} ill-formed only for parameters of non-trivial type). We believe that the above selection provides an adequate sampling of the entire solution space for the purposes of our analysis.

\section{Design goals}

\subsection{Allow \tcode{pre} and \tcode{post} on coroutines}

The simplest and most practical design goal of this proposal is to allow applying \tcode{pre} and \tcode{post} to the declaration of a coroutine. This would enable us to use contract assertions to specify preconditions on the parameters passed into the coroutine, postconditions on the object that this function call returns to the caller, as well as preconditions and postconditions on other reachable program state at the point when the coroutine is called and when it returns.

Such assertions can be useful for the same reasons that assertions on any other function can be useful: they allow enhancing the program with configurable checks of its correctness, thereby helping to diagnose and fix program defects.

Solution 1 does not allow either \tcode{pre} or \tcode{post} on coroutines, while Solution 2 does not allow \tcode{post}; all other solutions satisfy this design goal in some form.

\subsection{Treat coroutine-ness as an implementation detail}
\label{goal_coro_principle}

Any solution should be consistent with the fundamental design principle of coroutines that whether a function \tcode{f} is a coroutine is an implementation detail that is not known at the declaration of \tcode{f}, or at a call to \tcode{f}.

Solutions 4 and 5c violate this principle because they make it so that the user of a function will evaluate a \tcode{post} differently depending on whether the function is a coroutine. They do so by exposing the parameter copies internal to the coroutine state (Solution 4) or the moved-from values of the original parameter objects (Solution 5c).

The other solutions do not directly violate this principle. Solutions 1, 2, 3, and 5b does not expose coroutine-ness in the declaration, but make the definition ill-formed under certain circumstances if that definition happens to make the function a coroutine. But that does not let the callsite of a function detect whether or not the function is a coroutine, i.e. from the caller's perspective it is still just a normal function; the compiler error occurs in the function definition.

One way to think about this is that solutions 1, 2, 3, and 5b add a few more cases to the language in which a function with a given declaration cannot be implemented as a coroutine, but can only be implemented as a non-coroutine. Note that there are already many such cases in the language today, for example a function that has a non-coroutine-compatible return type, or a function that has a parameter of non-copyable non-movable type. We do not consider any of these cases to be exposing the coroutine-ness of a function.

One could perhaps argue that solutions 1, 2, and 5b \emph{indirectly} fail to fully satisfy the implementation-detail principle: without looking at the definition of a function, one could reason that it must be a coroutine if adding certain kinds of function contract assertions makes the program ill-formed due to an error that is \emph{specific} to coroutines, even if that is not apparent at the callsite. However, with solution 3, no such reasoning is possible, as the coroutine-ness of a function is not the only possible reason why odr-using a non-reference parameter in \tcode{post} would make the program ill-formed.\footnote{As discussed in Section \ref{paramsinpost}, any non-coroutine function that has a non-reference parameter declared \tcode{const} on its first declaration could be implemented such that the same parameter is not declared \tcode{const} on a subsequent declaration (which may be a definition). With the rules in \cite{P2900R8} today, this would render  render the program ill-formed at the place of that subsequent declaration if that parameter is used in \tcode{post}, even if that \tcode{post} syntactically appears only on the first declaration.}

\subsection{Do not expose moved-from parameters in \tcode{post}}

On the one hand, exposing the moved-from parameter value in \tcode{post} is the ``honest'' choice, as it simply reflects what is going on under the hood. On the other hand, it exposes an implementation detail of C++ coroutines to the caller that is currently not being exposed. Apart from violating the fundamental design principle of coroutines (see previous section), observing such moved-from values when odr-using \tcode{const} parameters is likely to be surprising to the user, and can lead to unexpected behaviour and unintended bugs that will be very difficult to diagnose and fix. It should therefore be a design goal to avoid this, guided by an underlying design principle that Contracts and coroutines should not be unnecessarily user-hostile.

Furthermore, it does not seem useful to be able to write a postcondition on a non-reference parameter that can be moved-from, as we cannot reason about the meaning of such a postcondition, in the same way in which we cannot reason about the meaning of a postcondition on a non-reference parameter that is not declared \tcode{const} by the user (which is the reason why \cite{P2900R8} makes such postcondition assertions ill-formed). Overall, it is therefore a reasonable design goal to avoid this scenario.

Solution 5c directly violates this design goal, as it makes parameter names in \tcode{post} refer to moved-from objects. Whether solution 5b violates this goal as well is a matter of interpretation. On the one hand, it \emph{morally} does, as the parameter names in \tcode{post} refer to moved-from objects as well; on the other hand, such a \tcode{post} will only compile for types for which the move operation is equivalent to a copy and no actual moved-from values exist.
\subsection{Satisfy the Contracts Prime Directive}
\label{goal_prime_directive}

The most fundamendal design principle of the Contracts MVP, the so-called Contracts Prime Directive (\cite{P2900R8}, Section 3.1, Principle 1) states that adding \tcode{pre} or \tcode{post} to an existing program should not alter the correctness of that program, as this would undermine the purpose of contract assertions --- instead of checking the correctness of the program the user wrote, they would check the correctness of some other program, potentially leading to so-called ``Heisenbugs'' as well as other problems.

A corollary of this fundamental principle is that adding \tcode{pre} or \tcode{post} to an existing program should not change the compile-time or run-time semantics of that program (see \cite{P2900R8}, Section 3.1, Principles 2 and 3).

Solution 4 violates this principle. Note that the coroutine state, along with its copies of the function parameters, can be destroyed on initial suspend, which happens before control is returned to the caller, and thus before \tcode{post} is checked. Therefore, making parameters in \tcode{post} refer to the parameter copy would require changes to the semantics of the coroutine state to extend its lifetime accordingly, thereby violating the Contracts Prime Directive. Furthermore, such an approach would require heavy lifting in both wording and implementation changes, as we would have to change the nesting of lifetimes in significant ways; but without such changes, there would be no point at which the parameter copies and the return value necessarily exist at the same time, and therefore no point at which \tcode{post} could be checked.

Solution 5a violates the Contracts Prime Directive in a different way. With this solution, adding \tcode{post} to a coroutine would incur an additional copy of each non-reference parameter odr-used in \tcode{post}, even if the \emph{ignore} semantic is used and predicate is never checked. \cite{P2900R8} has been carefully designed to avoid such scenarios. This is the reason why, for example, the program is ill-formed if a contract assertion would trigger an implicit lambda capture. To avoid incurring an additional copy by merely adding a (potentially unchecked) contract assertion, we would have to perform an additional copy of \emph{each} parameter, on \emph{any} coroutine, regardless whether contract assertions are being used. Such an approach would  violate the ``don't pay for what you don't use'' principle of C++, and would introduce performance regressions to existing code.

\subsection{Do not introduce additional inconsistencies between \tcode{pre} and \tcode{post}}

A well-designed Contracts feature will naturally compose with other C++ language features, including coroutines. We should avoid adding more complexity to make Contracts and coroutines work together. In particular, we should avoid introducing new inconsistencies between \tcode{pre} and \tcode{post} that do not exist in the current design, as that could be surprising to the user and hinder effective usage and wider adoption of Contracts.

Arguably, Solution 2 violates this design goal, because being able to apply \tcode{pre}, but not \tcode{post} to a function would be a new inconsistency and arguably surprising.

Solution 4 also violates this design goal. Currently, if a function has a \tcode{pre} and a \tcode{post}, and their predicates odr-use the same parameter, then the corresponding \emph{id-expression} will refer to the same parameter object with the same address. Solution 4 breaks this symmetry, which will be unexpected to most users.

Finally, Solution 5c violates this design goal as well. Currently, if a function has a \tcode{pre} and a \tcode{post}, and their predicates odr-use the same non-reference parameter, that parameter must be \tcode{const} and therefore \tcode{pre} and \tcode{post} are guaranteed to see the same value for that parameter (at least, if the parameter type has been implemented with \tcode{const}-correctness). Solution 4 however would lead to potentially different values being observed in \tcode{pre} and \tcode{post}, respectively.

Note that Solution 3 does not violate this design goal because it does not introduce a new inconsistency. As already discussed above, one of the necessary limitations of \tcode{post}, compared to \tcode{pre}, is that it is ill-formed to odr-use non-\tcode{const} non-reference parameters in the predicate of \tcode{post}. However, due to the nature of how coroutines are implemented by the compiler, the parameters of a coroutine are never \tcode{const}, even if declared \tcode{const} everywhere by the user. Therefore, implementing a function as a coroutine is just another way of making a non-reference parameter non-\tcode{const}.

\subsection{Do not facilitate remote code breakage}

Our design for how Contracts and coroutines work together should not facilitate situations that can lead to unintended, remote code breakage. Solution 5b violates this design goal because it would create a new dependency between the trivial movability of a type and the ability to use it as a function parameter.

For example, if the user adds a move constructor to a type that previously only had a copy constructor (something that we explicitly encourage people to do to modernise their code!), this will break clients who happen to use this type as a coroutine parameter. Likewise, if there is a struct with an \tcode{int} and a \tcode{float} data member, and the user adds a \tcode{std::string} data member, this will also break clients who happen to use this type as a coroutine parameter. Such breakage would happen for highly non-obvious reasons, does not have a good workaround --- at least not until we get postcondition captures (\cite{P2461R1}, \cite{P3098R0}) as a post-MVP extensions --- and therefore seems user-hostile.

\subsection{Support caller-side checking of \tcode{pre} and \tcode{post}}

The Contracts MVP has been designed from the start to accommodate a wide range of implementation strategies and usage scenarios. In particular, it allows implementations to check precondition and postcondition assertions caller-side and/or callee-side, and enables the two translation units involved to make the decision on contract evaluation semantics independently, which has important use cases (\cite{P2751R1}, \cite{P3228R1}, \cite{P3119R1}, \cite{P3267R1}, \cite{P3321R0}).

In particular, if one has deployed a pre-built library with all contracts ignored, and the user of that pre-built library wishes to verify that it is working correctly when used from particular other translation units, enabling caller-side checking of that library's precondition and postcondition assertions can be very useful, for example to validate a new version of such a library before integrating it into the shipping product. In general, any time we cross the boundary between translation units, it is very helpful (and currently intentionally supported by \cite{P2900R8}) to have both sides of that boundary be able to enable contract checks.

However, in order to be able to enable caller-side checking of \tcode{pre} and \tcode{post}, the predicate cannot depend on anything that is not accessible caller-side and only known callee-side. For coroutines in particular, it means that \tcode{post} cannot refer to the copies of parameter objects that belong to the coroutine state. Solution 4 is therefore not compatible with caller-side checking of \tcode{post}, even though it does allow caller-side checking of \tcode{pre}.

Admittedly, we are aware of fewer use cases for caller-side checking of \tcode{post} than for \tcode{pre}. The former seems useful but overall less important to support than the latter. It might also be unimplementable on some platforms.\footnote{Notably, the Microsoft ABI performs argument destruction callee-side, not caller-side. Since postcondition assertions are specified in \cite{P2900R8} to be evaluated before argument destruction happens, they cannot be checked caller-side on this platform without an ABI break.} Whether supporting caller-side checking of \tcode{post} should be considered a design goal therefore depends on the intended use cases; if we strive to enable the widest range of known use cases for Contracts (``design for the multiverse''), then it arguably should be.

\section{Proposed solution}

Having formulated our design goals, we can now construct a decision matrix that visualises which possible solutions in the available design space satisfy which design goals (question marks represent cases where one could argue one way or the other):


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\yes}{\includegraphics[width=4mm]{images/yes.png}}
\newcommand{\no}{\includegraphics[width=4mm]{images/no.png}}
\newcommand{\maybe}{\includegraphics[width=4mm]{images/maybe.png}}
%\vspace{4mm}
\begin{table}[!h]
\begin{tabular}{|p{7.4cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|}
\hline 
 & $1$ & $2$ & $3$ & $4$ & $5$a & $5$b & $5$c  \\
\hline
Allow \tcode{pre} on coroutines & \no & \yes & \yes & \yes & \yes & \yes & \yes  \\
\hline
Allow \tcode{post} on coroutines  & \no & \no & \yes & \yes & \yes & \yes & \yes  \\
\hline
Treat coroutine-ness as implementation detail  & \maybe & \maybe & \yes & \no & \yes & \maybe & \no  \\
\hline
Do not expose moved-from parameters  & \yes & \yes & \yes & \yes  & \yes & \maybe & \no  \\
\hline
Satisfy Contracts Prime Directive & \yes & \yes & \yes & \no & \no & \yes & \yes  \\
\hline
Do not make \tcode{pre} and \tcode{post} more inconsistent & \yes & \no & \yes & \no & \yes & \yes & \no \\
\hline
Do not facilitate remote code breakage & \yes & \yes & \yes & \yes & \yes & \no & \yes \\
\hline
Support caller-side checking of \tcode{pre} and \tcode{post} & \yes & \yes & \yes & \no & \yes & \yes & \yes  \\
\hline
\end{tabular}
\vspace{2mm}
\label{table:matrix}
\end{table}

The above decision matrix visualises that the only solution that satisfies all our design goals, and furthermore the only possible solution that is compatible with the fundamental design principles of both coroutines (Section~\ref{goal_coro_principle}) and Contracts (Section~\ref{goal_prime_directive}), is Solution 3: allow \tcode{pre} and \tcode{post} on coroutines, but make it ill-formed to odr-use a parameter of a coroutine in the predicate of \tcode{post} (even if that parameter is declared \tcode{const} by the user). 

Therefore, we propose to adopt Solution 3 for the Contracts MVP. It is the correct solution for contract assertions on coroutines and provides the most value for the C++ language and its users. Furthermore, as we will see in Section~\ref{wording}, Solution 3 can be specified on top of the existing Contracts and coroutines wording in an elegant way: it reduces to essentially just clarifications in the existing coroutines wording plus the actual removal of the prohibition to place \tcode{pre} and \tcode{post} on a coroutine. The desired behaviour regarding point of evaluation, non-reference parameters, etc. just automatically falls out from those clarifications. This is another strong hint that it is indeed the most natural and consistent composition of the Contracts and coroutines features.

Note that if we adopt Solution 3, but for whatever reason the user really must odr-use non-reference parameters in the predicate of \tcode{post}, a workaround exists: one can wrap the coroutine into a non-coroutine wrapper as shown at the end of Section \ref{impldetail}. With such a wrapper, there is no question as to whether \tcode{post} applies to the original or copy of the parameter, or whether that parameter might have been moved from, as only the original parameter object is visible to the wrapper, and that parameter object is not modifiable. It is then up to the user how to pass that parameter on to the wrapped coroutine (e.g., by copy).

The situation will become even simpler once we get postcondition captures (\cite{P2461R1}, \cite{P3098R0}) as a post-MVP extension. Postcondition captures will allow the user to explicitly capture parameters when a function is called, by copy or by reference, with a syntax analogous to lambda captures, and use these captured parameters later in the predicate of \tcode{post} when the function returns. This will work even if the parameter in question is non-\tcode{const}. With this post-MVP extension, the need for a wrapper will go away completely.

\section{Proposed wording}
\label{wording}

Our wording strategy is to not modify the normative Contracts wording in \cite{P2900R8} at all other than removing of the prohibition for \tcode{pre} and \tcode{post} to apply to a coroutine, consistent with the principle that coroutine-ness is an implementation detail. Instead, we clarify the wording in [dcl.fct.def.coroutine] in the necessary places such that the behaviour of \tcode{pre} and \tcode{post} on the declaration of a function that happens to be implemented as a coroutine simply follows from the existing specification.

The evaluation of both precondition and postcondition assertions should be semantically equivalent whether a function actually \emph{is} a coroutine or not.  We believe this is the case in the current intent of the coroutine wording, but we believe clarifications are needed for that purpose:
\begin{itemize}
\item Precondition assertions should be evaluated after the normal function parameters are initialised (just as with any other function call) and prior to any coroutine-specific evaluations such as allocating space for the coroutine state (using a possibly user-defined coroutine state frame allocator\footnote{Note that the coroutine state frame allocator has access to the original parameter objects}), making copies of the original parameter objects and moving their values into these copies, or evaluating anything in the replacement function body defined in [dcl.fct.def.coroutine] paragraph 5.  To clarify this, we  introduce the term \emph{replacement body} so we can directly refer to it, and add ``as part of the replacement body'' to descriptions of both the allocating function invocation and the making of copies of the parameters.
\item Postconditions should be evaluated when the coroutine returns to its caller (but not a resumer).  The return to the caller can correspond to the first suspension\footnote{It need not correspond to a suspension in general --- the coroutine could run synchronously to completion, or be destroyed in response to some interaction before reaching any active suspension.} of a coroutine; all other suspension points return to an alternate resumer (i.e. not to the ramp).   Returns that correspond to a suspension do \emph{not} destroy local variables because suspending is not considered leaving the relevant scope within the coroutine.   To achieve the effects we want, we recommend a minor rearranging of the wording in \cite{P2900R8} to describe postcondition evaluation along with precondition evaluation in [expr.call] and not tie it to the return statement (leaving just a note in the [stmt.return] and in [dcl.fct.def.coroutine] describing when postconditions are expected to be evaluated.)
\item To make it ill-formed to odr-use parameters in the predicate of \tcode{post}, we need to clarify that a coroutine does not just rewrite its body but also rewrites its declaration to not have top-level $cv$-qualifiers on its parameter declarations (though the copies do retain those $cv$-qualifiers).  This is already implied by the existing wording for the generated ramp function body, but is currently not specified clearly enough and contains a misleading note. We suggest removal of the note as well as other drive-by fixes of the preceding wording.
\end{itemize}

The proposed wording is relative to \cite{P2900R8}.

Modify [dcl.contract.func], paragraph 6:
\begin{adjustwidth}{0.5cm}{0.5cm}
A \removed{coroutine ([dcl.fct.def.coroutine]), }a deleted function ([dcl.fct.def.delete])\removed{,} or a function defaulted on its first declaration ([dcl.fct.def.default]) may not have a \emph{function-contract-specifier-seq}.
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 5:
\begin{adjustwidth}{0.5cm}{0.5cm}
A coroutine behaves as if \added{the top-level $cv$-qualifiers in all \emph{parameter-declaration}s in the declarator of its \grammarterm{function-definition} were removed, and }its \grammarterm{function-body} were replaced by\added{ the following \emph{replacement body}}: 

\phantom{~~~}\tcode{\{} \\
\phantom{~~~~~~}\emph{promise-type \tcode{promise} promise-constructor-arguments} \tcode{;} \\
\phantom{~~~~~~}\tcode{[...]}
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 9:
\begin{adjustwidth}{0.5cm}{0.5cm}
An implementation may need to allocate additional storage for a coroutine. This storage is known as the \emph{coroutine state} and is obtained by calling a non-array allocation function ([basic.stc.dynamic.allocation])\added{ as part of the replacement body}. The allocation function's name is looked up by searching for it in the scope of the promise type.
\begin{itemize}
\item{If the search finds any declarations,
overload resolution is performed on a function call created by assembling an
argument list. The first argument is the amount of space requested, and
is a prvalue of type \tcode{std::size_t}.
The lvalues $\tcode{p}_1 \dotsc \tcode{p}_n$ \added{with their original $cv$-qualifiers} are the successive arguments.
If no viable function is found ([over.match.viable]),
overload resolution is performed again
on a function call created by passing just
the amount of space required as a prvalue of type \tcode{std::size_t}.
}
\end{itemize}
\end{adjustwidth}

Modify [dcl.fct.def.coroutine], paragraph 13:
\begin{adjustwidth}{0.5cm}{0.5cm}
When a coroutine is invoked, \removed{after initializing its parameters ([expr.call])}\added{at the beginning of the replacement body}, a copy is created for each coroutine parameter. For a parameter \added{whose original declaration was }of type $cv$ \tcode{T}\added{:}
\begin{itemize}
\item{\added{If \tcode{T} is a reference type, the copy is a reference of type $cv$ \tcode{T} bound to the same object as the parameter,}}
\item{\added{Otherwise}, the copy is a variable of type $cv$ \tcode{T} with automatic storage duration that is direct-initialized from an xvalue of type \tcode{T} referring to the parameter.}
\added{[ \emph{Note:} An identifier that names one of these parameters refers to the created copy and not the original paramter ([expr.prim.id.unqual]) --- \emph{end note} ]}
\end{itemize}

\removed{[ \emph{Note:} An original parameter object is never a const or volatile object ([basic.type.qualifier]). --- \emph{end note} ]}
\end{adjustwidth}

Modify [intro.execution], paragraph 11:

\begin{adjustwidth}{0.5cm}{0.5cm}
[11]  When invoking a function \tcode{f} (whether or not the function is inline),
every argument expression and the postfix expression designating \tcode{f} are
sequenced before every precondition assertion of \removed{\tcode{f}}\added{the function call ([expr.call])}, which in turn are sequenced before
every expression or statement in the body of
\tcode{f}\added{, which in turn are sequenced before every postcondition assertion of the function call}.
Several contexts in C++ cause evaluation of a function call, even though no
corresponding function call syntax appears in the translation unit.
\end{adjustwidth}

Add a new paragraph after [expr.call], paragraph 8:

\begin{adjustwidth}{0.5cm}{0.5cm}
\added{When control is transferred back to this function call ([stmt.return], [expr.await]), all post\-condition assertions of the function call are evaluated in sequence ([dcl.contract.func]).
[\emph{Note:} This in turn is sequenced before the destruction of any function parameters.  --- \emph{end note}]}
\end{adjustwidth}

Modify the new paragraph added after [stmt.return], paragraph 3:

\begin{adjustwidth}{0.5cm}{0.5cm}
\removed{
All postcondition assertions ([dcl.contract.func]) of the function call ([expr.call])
are evaluated in sequence. 
The destruction of all local
variables within the function body
is sequenced before the evaluation of any postcondition assertions.}

[\emph{Note:} Postcondition assertions\added{ of the function call ([expr.call])} are\added{ evaluated in sequence after the destruction of any local variables in scopes exited by the return statement, and are}, in turn, sequenced before the destruction of function parameters. --- \emph{end note}]

\end{adjustwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Acknowledgements}
Thanks to Andrzej Krzemie\' nski and Lewis Baker for their thorough review of the paper; to Gabriel Dos Reis, Gor Nishanov, and Lisa Lippincott for fruitful discussions of the proposal; and to Ville Voutilainen for his helpful remarks regarding caller-side checking.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% No ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

